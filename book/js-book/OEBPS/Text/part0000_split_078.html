<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>未知</title>
  <link href="../Styles/Style.css" rel="stylesheet" type="text/css" />
  <link href="../Styles/custom.css" rel="stylesheet" type="text/css" />
</head>

<body class="calibre">
  <h2 class="calibre9" id="nav_point_81">11.2　元素遍历</h2>

  <p class="calibre2">对于元素间的空格，IE9及之前版本不会返回文本节点，而其他所有浏览器都会返回文本节点。这样，就导致了在使用<code class="calibre15">childNodes</code>和<code class="calibre15">firstChild</code>等属性时的行为不一致。为了弥补这一差异，而同时又保持DOM规范不变，Element Traversal规范（<a class="calibre6" href="http://www.w3.org/TR/ElementTraversal/">www.w3.org/TR/ElementTraversal/</a>）新定义了一组属性。</p>

  <p class="calibre2">Element Traversal API为DOM元素添加了以下5个属性。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">childElementCount</code>：返回子元素（不包括文本节点和注释）的个数。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">firstElementChild</code>：指向第一个子元素；<code class="calibre15">firstChild</code>的元素版。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">lastElementChild</code>：指向最后一个子元素；<code class="calibre15">lastChild</code>的元素版。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">previousElementSibling</code>：指向前一个同辈元素；<code class="calibre15">previousSibling</code>的元素版。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">nextElementSibling</code>：指向后一个同辈元素；<code class="calibre15">nextSibling</code>的元素版。</p>
    </li>
  </ul>

  <p class="calibre2">支持的浏览器为DOM元素添加了这些属性，利用这些元素不必担心空白文本节点，从而可以更方便地查找DOM元素了。</p>

  <p class="calibre2">下面来看一个例子。过去，要跨浏览器遍历某元素的所有子元素，需要像下面这样写代码。</p>
  <pre class="calibre18"><code class="calibre15">var i, 
    len,
    child = element.firstChild;
while(child != element.lastChild){
    if (child.nodeType == 1){   //检查是不是元素
       processChild(child);
    }
    child = child.nextSibling;
}
</code></pre>

  <p class="calibre2">而使用Element Traversal新增的元素，代码会更简洁。</p>
  <pre class="calibre18"><code class="calibre15">var i, 
    len,
    child = element.firstElementChild;
while(child != element.lastElementChild){
    processChild(child);   //已知其是元素
    child = child.nextElementSibling;
}
</code></pre>

  <p class="calibre2">支持Element Traversal规范的浏览器有IE 9+、Firefox 3.5+、Safari 4+、Chrome和Opera 10+。</p>
</body>
</html>
