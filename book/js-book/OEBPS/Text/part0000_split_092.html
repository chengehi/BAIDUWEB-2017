<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>未知</title>
  <link href="../Styles/Style.css" rel="stylesheet" type="text/css" />
  <link href="../Styles/custom.css" rel="stylesheet" type="text/css" />
</head>

<body class="calibre">
  <h2 class="calibre9" id="nav_point_95">13.4　事件类型</h2>

  <p class="calibre2">Web浏览器中可能发生的事件有很多类型。如前所述，不同的事件类型具有不同的信息，而“DOM3级事件”规定了以下几类事件。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2">UI（User Interface，用户界面）事件，当用户与页面上的元素交互时触发；</p>
    </li>

    <li class="calibre12">
      <p class="calibre2">焦点事件，当元素获得或失去焦点时触发；</p>
    </li>

    <li class="calibre12">
      <p class="calibre2">鼠标事件，当用户通过鼠标在页面上执行操作时触发；</p>
    </li>

    <li class="calibre12">
      <p class="calibre2">滚轮事件，当使用鼠标滚轮（或类似设备）时触发；</p>
    </li>

    <li class="calibre12">
      <p class="calibre2">文本事件，当在文档中输入文本时触发；</p>
    </li>

    <li class="calibre12">
      <p class="calibre2">键盘事件，当用户通过键盘在页面上执行操作时触发；</p>
    </li>

    <li class="calibre12">
      <p class="calibre2">合成事件，当为IME（Input Method Editor，输入法编辑器）输入字符时触发；</p>
    </li>

    <li class="calibre12">
      <p class="calibre2">变动（mutation）事件，当底层DOM结构发生变化时触发。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2">变动名称事件，当元素或属性名变动时触发。此类事件已经被废弃，没有任何浏览器实现它们，因此本章不做介绍。</p>
    </li>
  </ul>

  <p class="calibre2">除了这几类事件之外，HTML5也定义了一组事件，而有些浏览器还会在DOM和BOM中实现其他专有事件。这些专有的事件一般都是根据开发人员需求定制的，没有什么规范，因此不同浏览器的实现有可能不一致。</p>

  <p class="calibre2">DOM3级事件模块在DOM2级事件模块基础上重新定义了这些事件，也添加了一些新事件。包括IE9在内的所有主流浏览器都支持DOM2级事件。IE9也支持DOM3级事件。</p>

  <h3 class="calibre22" id="nav_point_96">13.4.1　UI事件</h3>

  <p class="calibre2">UI事件事件指的是那些不一定与用户操作有关的事件。这些事件在DOM规范出现之前，都是以这种或那种形式存在的，而在DOM规范中保留是为了向后兼容。现有的UI事件如下。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">DOMActivate</code>：表示元素已经被用户操作（通过鼠标或键盘）激活。这个事件在DOM3级事件中被废弃，但Firefox 2+和Chrome支持它。考虑到不同浏览器实现的差异，不建议使用这个事件。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">load</code>：当页面完全加载后在<code class="calibre15">window</code>上面触发，当所有框架都加载完毕时在框架集上面触发，当图像加载完毕时在<code class="calibre15">&lt;img&gt;</code>元素上面触发，或者当嵌入的内容加载完毕时在<code class="calibre15">&lt;object&gt;</code>元素上面触发。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">unload</code>：当页面完全卸载后在<code class="calibre15">window</code>上面触发，当所有框架都卸载后在框架集上面触发，或者当嵌入的内容卸载完毕后在<code class="calibre15">&lt;object&gt;</code>元素上面触发。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">abort</code>：在用户停止下载过程时，如果嵌入的内容没有加载完，则在<code class="calibre15">&lt;object&gt;</code>元素上面触发。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">error</code>：当发生JavaScript错误时在<code class="calibre15">window</code>上面触发，当无法加载图像时在<code class="calibre15">&lt;img&gt;</code>元素上面触发，当无法加载嵌入内容时在<code class="calibre15">&lt;object&gt;</code>元素上面触发，或者当有一或多个框架无法加载时在框架集上面触发。第17章将继续讨论这个事件。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">select</code>：当用户选择文本框（<code class="calibre15">&lt;input&gt;</code>或<code class="calibre15">&lt;texterea&gt;</code>）中的一或多个字符时触发。第14章将继续讨论这个事件。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">resize</code>：当窗口或框架的大小变化时在<code class="calibre15">window</code>或框架上面触发。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">scroll</code>：当用户滚动带滚动条的元素中的内容时，在该元素上面触发。<code class="calibre15">&lt;body&gt;</code>元素中包含所加载页面的滚动条。</p>
    </li>
  </ul>

  <p class="calibre2">多数这些事件都与<code class="calibre15">window</code>对象或表单控件相关。</p>

  <p class="calibre2">除了<code class="calibre15">DOMActivate</code>之外，其他事件在DOM2级事件中都归为HTML事件（<code class="calibre15">DOMActivate</code>在DOM2级中仍然属于UI事件）。要确定浏览器是否支持DOM2级事件规定的HTML事件，可以使用如下代码：</p>
  <pre class="calibre18"><code class="calibre15">var isSupported = document.implementation.hasFeature("HTMLEvents", "2.0");
</code></pre>

  <p class="calibre2">注意，只有根据“DOM2级事件”实现这些事件的浏览器才会返回<code class="calibre15">true</code>。而以非标准方式支持这些事件的浏览器则会返回<code class="calibre15">false</code>。要确定浏览器是否支持“DOM3级事件”定义的事件，可以使用如下代码：</p>
  <pre class="calibre18"><code class="calibre15">var isSupported = document.implementation.hasFeature("UIEvent", "3.0");
</code></pre>

  <p class="calibre2">1. <strong class="calibre3"><code class="calibre15">load</code>事件</strong></p>

  <p class="calibre2">JavaScript中最常用的一个事件就是<code class="calibre15">load</code>。当页面完全加载后（包括所有图像、JavaScript文件、CSS文件等外部资源），就会触发<code class="calibre15">window</code>上面的<code class="calibre15">load</code>事件。有两种定义<code class="calibre15">onload</code>事件处理程序的方式。第一种方式是使用如下所示的JavaScript代码：</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">EventUtil.addHandler(window, "load", function(event){
    alert("Loaded!"); 
});
</code></pre>

  <p class="calibre8"><i class="calibre7">LoadEventExample01.htm</i></p>

  <p class="calibre2">这是通过JavaScript来指定事件处理程序的方式，使用了本章前面定义的跨浏览器的<code class="calibre15">EventUtil</code>对象。与添加其他事件一样，这里也给事件处理程序传入了一个<code class="calibre15">event</code>对象。这个<code class="calibre15">event</code>对象中不包含有关这个事件的任何附加信息，但在兼容DOM的浏览器中，<code class="calibre15">event.target</code>属性的值会被设置为<code class="calibre15">document</code>，而IE并不会为这个事件设置<code class="calibre15">srcElement</code>属性。</p>

  <p class="calibre2">第二种指定<code class="calibre15">onload</code>事件处理程序的方式是为<code class="calibre15">&lt;body&gt;</code>元素添加一个<code class="calibre15">onload</code>特性，如下面的例子所示：</p>
  <pre class="calibre18"><code class="calibre15">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Load Event Example&lt;/title&gt;
&lt;/head&gt;
&lt;body onload="alert('Loaded!')"&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>

  <p class="calibre8"><i class="calibre7">LoadEventExample02.htm</i></p>

  <p class="calibre2">一般来说，在<code class="calibre15">window</code>上面发生的任何事件都可以在<code class="calibre15">&lt;body/&gt;</code>元素中通过相应的特性来指定，因为在HTML中无法访问<code class="calibre15">window</code>元素。实际上，这只是为了保证向后兼容的一种权宜之计，但所有浏览器都能很好地支持这种方式。我们建议读者尽可能使用JavaScript方式。</p>

  <blockquote class="calibre14">
    <p class="calibre2"><img alt="" class="calibre17" src="../Images/00002.gif" /> 根据“DOM2级事件”规范，应该在<strong class="calibre3"><code class="calibre15">document</code></strong>而非<strong class="calibre3"><code class="calibre15">window</code></strong>上面触发<strong class="calibre3"><code class="calibre15">load</code></strong>事件。但是，所有浏览器都在<strong class="calibre3"><code class="calibre15">window</code></strong>上面实现了该事件，以确保向后兼容。</p>
  </blockquote>

  <p class="calibre2">图像上面也可以触发<code class="calibre15">load</code>事件，无论是在DOM中的图像元素还是HTML中的图像元素。因此，可以在HTML中为任何图像指定<code class="calibre15">onload</code>事件处理程序，例如：</p>
  <pre class="calibre18"><code class="calibre15">&lt;img src="smile.gif" onload="alert('Image loaded.')"&gt;
</code></pre>

  <p class="calibre8"><i class="calibre7">LoadEventExample03.htm</i></p>

  <p class="calibre2">这样，当例子中的图像加载完毕后就会显示一个警告框。同样的功能也可以使用JavaScript来实现，例如：</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">var image = document.getElementById("myImage");
EventUtil.addHandler(image, "load", function(event){
    event = EventUtil.getEvent(event);
    alert(EventUtil.getTarget(event).src);
});
</code></pre>

  <p class="calibre8"><i class="calibre7">LoadEventExample04.htm</i></p>

  <p class="calibre2">这里，使用JavaScript指定了<code class="calibre15">onload</code>事件处理程序。同时也传入了<code class="calibre15">event</code>对象，尽管它也不包含什么有用的信息。不过，事件的目标是<code class="calibre15">&lt;img&gt;</code>元素，因此可以通过<code class="calibre15">src</code>属性访问并显示该信息。</p>

  <p class="calibre2">在创建新的<code class="calibre15">&lt;img&gt;</code>元素时，可以为其指定一个事件处理程序，以便图像加载完毕后给出提示。此时，最重要的是要在指定<code class="calibre15">src</code>属性之前先指定事件，如下面的例子所示。</p>
  <pre class="calibre18"><code class="calibre15">EventUtil.addHandler(window, "load", function(){
    var image = document.createElement("img");
    EventUtil.addHandler(image, "load", function(event){
        event = EventUtil.getEvent(event);
        alert(EventUtil.getTarget(event).src);
    });
    document.body.appendChild(image);
    image.src = "smile.gif";
});
</code></pre>

  <p class="calibre8"><i class="calibre7">LoadEventExample05.htm</i></p>

  <p class="calibre2">在这个例子中，首先为<code class="calibre15">window</code>指定了<code class="calibre15">onload</code>事件处理程序。原因在于，我们是想向DOM中添加一个新元素，所以必须确定页面已经加载完毕——如果在页面加载前操作<code class="calibre15">document.body</code>会导致错误。然后，创建了一个新的图像元素，并设置了其<code class="calibre15">onload</code>事件处理程序。最后又将这个图像添加到页面中，还设置了它的<code class="calibre15">src</code>属性。这里有一点需要格外注意：新图像元素不一定要从添加到文档后才开始下载，只要设置了<code class="calibre15">src</code>属性就会开始下载。</p>

  <p class="calibre2">同样的功能也可以通过使用DOM0级的<code class="calibre15">Image</code>对象实现。在DOM出现之前，开发人员经常使用<code class="calibre15">Image</code>对象在客户端预先加载图像。可以像使用<code class="calibre15">&lt;img&gt;</code>元素一样使用<code class="calibre15">Image</code>对象，只不过无法将其添加到DOM树中。下面来看一个例子。</p>
  <pre class="calibre18">EventUtil.addHandler(window, "load", function(){
    <b class="calibre3">var image = new Image();</b>
    EventUtil.addHandler(image, "load", function(event){
        alert("Image loaded!");
    });
    image.src = "smile.gif";
});
</pre>

  <p class="calibre8"><i class="calibre7">LoadEventExample06.htm</i></p>

  <p class="calibre2">在此，我们使用<code class="calibre15">Image</code>构造函数创建了一个新图像的实例，然后又为它指定了事件处理程序。有的浏览器将<code class="calibre15">Image</code>对象实现为<code class="calibre15">&lt;img&gt;</code>元素，但并非所有浏览器都如此，所以最好将它们区别对待。</p>

  <blockquote class="calibre14">
    <p class="calibre2"><img alt="" class="calibre17" src="../Images/00002.gif" /> 在不属于DOM文档的图像（包括未添加到文档的<strong class="calibre3"><code class="calibre15">&lt;img&gt;</code></strong>元素和<strong class="calibre3"><code class="calibre15">Image</code></strong>对象）上触发<strong class="calibre3"><code class="calibre15">load</code></strong>事件时，IE8及之前版本不会生成<strong class="calibre3"><code class="calibre15">event</code></strong>对象。IE9修复了这个问题。</p>
  </blockquote>

  <p class="calibre2">还有一些元素也以非标准的方式支持<code class="calibre15">load</code>事件。在IE9+、Firefox、Opera、Chrome和Safari 3+及更高版本中，<code class="calibre15">&lt;script&gt;</code>元素也会触发<code class="calibre15">load</code>事件，以便开发人员确定动态加载的JavaScript文件是否加载完毕。与图像不同，只有在设置了<code class="calibre15">&lt;script&gt;</code>元素的<code class="calibre15">src</code>属性并将该元素添加到文档后，才会开始下载JavaScript文件。换句话说，对于<code class="calibre15">&lt;script&gt;</code>元素而言，指定<code class="calibre15">src</code>属性和指定事件处理程序的先后顺序就不重要了。以下代码展示了怎样为<code class="calibre15">&lt;script&gt;</code>元素指定事件处理程序。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18">EventUtil.addHandler(window, "load", function(){
    <b class="calibre3">var script = document.createElement("script");</b>
    <b class="calibre3">EventUtil.addHandler(script, "load", function(event){</b>
        <b class="calibre3">alert("Loaded");</b>
    <b class="calibre3">});</b>
    <b class="calibre3">script.src = "example.js";</b>
    <b class="calibre3">document.body.appendChild(script);</b>

});
</pre>

  <p class="calibre8"><i class="calibre7">LoadEventExample07.htm</i></p>

  <p class="calibre2">这个例子使用了跨浏览器的<code class="calibre15">EventUtil</code>对象为新创建的<code class="calibre15">&lt;script&gt;</code>元素指定了<code class="calibre15">onload</code>事件处理程序。此时，大多数浏览器中<code class="calibre15">event</code>对象的<code class="calibre15">target</code>属性引用的都是<code class="calibre15">&lt;script&gt;</code>节点，而在Firefox 3之前的版本中，引用的则是<code class="calibre15">document</code>。IE8及更早版本不支持<code class="calibre15">&lt;script&gt;</code>元素上的<code class="calibre15">load</code>事件。</p>

  <p class="calibre2">IE和Opera还支持<code class="calibre15">&lt;link&gt;</code>元素上的<code class="calibre15">load</code>事件，以便开发人员确定样式表是否加载完毕。例如：</p>
  <pre class="calibre18">EventUtil.addHandler(window, "load", function(){
    <b class="calibre3">var link = document.createElement("link");</b>
    <b class="calibre3">link.type = "text/css";</b>
    <b class="calibre3">link.rel= "stylesheet";</b>
    <b class="calibre3">EventUtil.addHandler(link, "load", function(event){</b>
        <b class="calibre3">alert("css loaded");</b>
    <b class="calibre3">});</b>
    <b class="calibre3">link.href = "example.css";</b>
    <b class="calibre3">document.getElementsByTagName("head")[0].appendChild(link);</b>
});
</pre>

  <p class="calibre8"><i class="calibre7">LoadEventExample07.htm</i></p>

  <p class="calibre2">与<code class="calibre15">&lt;script&gt;</code>节点类似，在未指定<code class="calibre15">href</code>属性并将<code class="calibre15">&lt;link&gt;</code>元素添加到文档之前也不会开始下载样式表。</p>

  <p class="calibre2">2. <strong class="calibre3"><code class="calibre15">unload</code>事件</strong></p>

  <p class="calibre2">与<code class="calibre15">load</code>事件对应的是<code class="calibre15">unload</code>事件，这个事件在文档被完全卸载后触发。只要用户从一个页面切换到另一个页面，就会发生<code class="calibre15">unload</code>事件。而利用这个事件最多的情况是清除引用，以避免内存泄漏。与<code class="calibre15">load</code>事件类似，也有两种指定<code class="calibre15">onunload</code>事件处理程序的方式。第一种方式是使用JavaScript，如下所示：</p>
  <pre class="calibre18"><code class="calibre15">EventUtil.addHandler(window, "unload", function(event){
    alert("Unloaded");
});
</code></pre>

  <p class="calibre2">此时生成的<code class="calibre15">event</code>对象在兼容DOM的浏览器中只包含<code class="calibre15">target</code>属性（值为<code class="calibre15">document</code>）。IE8及之前版本则为这个事件对象提供了<code class="calibre15">srcElement</code>属性。</p>

  <p class="calibre2">指定事件处理程序的第二种方式，也是为<code class="calibre15">&lt;body&gt;</code>元素添加一个特性（与<code class="calibre15">load</code>事件相似），如下面的例子所示：</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Unload Event Example&lt;/title&gt;
&lt;/head&gt;
&lt;body onunload="alert('Unloaded!')"&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>

  <p class="calibre8"><i class="calibre7">UnloadEventExample01.htm</i></p>

  <p class="calibre2">无论使用哪种方式，都要小心编写<code class="calibre15">onunload</code>事件处理程序中的代码。既然<code class="calibre15">unload</code>事件是在一切都被卸载之后才触发，那么在页面加载后存在的那些对象，此时就不一定存在了。此时，操作DOM节点或者元素的样式就会导致错误。</p>

  <blockquote class="calibre14">
    <p class="calibre2"><img alt="" class="calibre17" src="../Images/00002.gif" /> 根据“DOM2级事件”，应该在<strong class="calibre3"><code class="calibre15">&lt;body&gt;</code></strong>元素而非<strong class="calibre3"><code class="calibre15">window</code></strong>对象上面触发<strong class="calibre3"><code class="calibre15">unload</code></strong>事件。不过，所有浏览器都在<strong class="calibre3"><code class="calibre15">window</code></strong>上实现了<strong class="calibre3"><code class="calibre15">unload</code></strong>事件，以确保向后兼容。</p>
  </blockquote>

  <p class="calibre2">3. <strong class="calibre3"><code class="calibre15">resize</code>事件</strong></p>

  <p class="calibre2">当浏览器窗口被调整到一个新的高度或宽度时，就会触发<code class="calibre15">resize</code>事件。这个事件在<code class="calibre15">window</code>（窗口）上面触发，因此可以通过JavaScript或者<code class="calibre15">&lt;body&gt;</code>元素中的<code class="calibre15">onresize</code>特性来指定事件处理程序。如前所述，我们还是推荐使用如下所示的JavaScript方式：</p>
  <pre class="calibre18"><code class="calibre15">EventUtil.addHandler(window, "resize", function(event){
    alert("Resized");
});
</code></pre>

  <p class="calibre2">与其他发生在<code class="calibre15">window</code>上的事件类似，在兼容DOM的浏览器中，传入事件处理程序中的<code class="calibre15">event</code>对象有一个<code class="calibre15">target</code>属性，值为<code class="calibre15">document</code>；而IE8及之前版本则未提供任何属性。</p>

  <p class="calibre2">关于何时会触发<code class="calibre15">resize</code>事件，不同浏览器有不同的机制。IE、Safari、Chrome和Opera会在浏览器窗口变化了1像素时就触发<code class="calibre15">resize</code>事件，然后随着变化不断重复触发。Firefox则只会在用户停止调整窗口大小时才会触发<code class="calibre15">resize</code>事件。由于存在这个差别，应该注意不要在这个事件的处理程序中加入大计算量的代码，因为这些代码有可能被频繁执行，从而导致浏览器反应明显变慢。</p>

  <blockquote class="calibre14">
    <p class="calibre2"><img alt="" class="calibre17" src="../Images/00002.gif" /> 浏览器窗口最小化或最大化时也会触发<strong class="calibre3"><code class="calibre15">resize</code></strong>事件。</p>
  </blockquote>

  <p class="calibre2">4. <strong class="calibre3"><code class="calibre15">scroll</code>事件</strong></p>

  <p class="calibre2">虽然<code class="calibre15">scroll</code>事件是在<code class="calibre15">window</code>对象上发生的，但它实际表示的则是页面中相应元素的变化。在混杂模式下，可以通过<code class="calibre15">&lt;body&gt;</code>元素的<code class="calibre15">scrollLeft</code>和<code class="calibre15">scrollTop</code>来监控到这一变化；而在标准模式下，除Safari之外的所有浏览器都会通过<code class="calibre15">&lt;html&gt;</code>元素来反映这一变化（Safari仍然基于<code class="calibre15">&lt;body&gt;</code>跟踪滚动位置），如下面的例子所示：</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">EventUtil.addHandler(window, "scroll", function(event){
    if (document.compatMode == "CSS1Compat"){
        alert(document.documentElement.scrollTop);
    } else {
        alert(document.body.scrollTop);
    }
});
</code></pre>

  <p class="calibre8"><i class="calibre7">ScrollEventExample01.htm</i></p>

  <p class="calibre2">以上代码指定的事件处理程序会输出页面的垂直滚动位置——根据呈现模式不同使用了不同的元素。由于Safari 3.1之前的版本不支持<code class="calibre15">document.compatMode</code>，因此旧版本的浏览器就会满足第二个条件。</p>

  <p class="calibre2">与<code class="calibre15">resize</code>事件类似，<code class="calibre15">scroll</code>事件也会在文档被滚动期间重复被触发，所以有必要尽量保持事件处理程序的代码简单。</p>

  <h3 class="calibre22" id="nav_point_97">13.4.2　焦点事件</h3>

  <p class="calibre2">焦点事件会在页面获得或失去焦点时触发。利用这些事件并与<code class="calibre15">document.hasFocus()</code>方法及<code class="calibre15">document.activeElement</code>属性配合，可以知晓用户在页面上的行踪。有以下6个焦点事件。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">blur</code>：在元素失去焦点时触发。这个事件不会冒泡；所有浏览器都支持它。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">DOMFocusIn</code>：在元素获得焦点时触发。这个事件与HTML事件<code class="calibre15">focus</code>等价，但它冒泡。只有Opera支持这个事件。DOM3级事件废弃了<code class="calibre15">DOMFocusIn</code>，选择了<code class="calibre15">focusin</code>。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">DOMFocusOut</code>：在元素失去焦点时触发。这个事件是HTML事件<code class="calibre15">blur</code>的通用版本。只有Opera支持这个事件。DOM3级事件废弃了<code class="calibre15">DOMFocusOut</code>，选择了<code class="calibre15">focusout</code>。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">focus</code>：在元素获得焦点时触发。这个事件不会冒泡；所有浏览器都支持它。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">focusin</code>：在元素获得焦点时触发。这个事件与HTML事件<code class="calibre15">focus</code>等价，但它冒泡。支持这个事件的浏览器有IE5.5+、Safari 5.1+、Opera 11.5+和Chrome。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">focusout</code>：在元素失去焦点时触发。这个事件是HTML事件<code class="calibre15">blur</code>的通用版本。支持这个事件的浏览器有IE5.5+、Safari 5.1+、Opera 11.5+和Chrome。</p>
    </li>
  </ul>

  <p class="calibre2">这一类事件中最主要的两个是<code class="calibre15">focus</code>和<code class="calibre15">blur</code>，它们都是JavaScript早期就得到所有浏览器支持的事件。这些事件的最大问题是它们不冒泡。因此，IE的<code class="calibre15">focusin</code>和<code class="calibre15">focusout</code>与Opera的<code class="calibre15">DOMFocusIn</code>和DOMFocusOut才会发生重叠。IE的方式最后被DOM3级事件采纳为标准方式。</p>

  <p class="calibre2">当焦点从页面中的一个元素移动到另一个元素，会依次触发下列事件：</p>

  <ol class="calibre11">
    <li class="calibre12" value="1">
      <p class="calibre2"><code class="calibre15">focusout</code>在失去焦点的元素上触发；</p>
    </li>

    <li class="calibre12" value="2">
      <p class="calibre2"><code class="calibre15">focusin</code>在获得焦点的元素上触发；</p>
    </li>

    <li class="calibre12" value="3">
      <p class="calibre2"><code class="calibre15">blur</code>在失去焦点的元素上触发；</p>
    </li>

    <li class="calibre12" value="4">
      <p class="calibre2"><code class="calibre15">DOMFocusOut</code>在失去焦点的元素上触发；</p>
    </li>

    <li class="calibre12" value="5">
      <p class="calibre2"><code class="calibre15">focus</code>在获得焦点的元素上触发；</p>
    </li>

    <li class="calibre12" value="6">
      <p class="calibre2"><code class="calibre15">DOMFocusIn</code>在获得焦点的元素上触发。</p>
    </li>
  </ol>

  <p class="calibre2">其中，<code class="calibre15">blur</code>、<code class="calibre15">DOMFocusOut</code>和<code class="calibre15">focusout</code>的事件目标是失去焦点的元素；而<code class="calibre15">focus</code>、<code class="calibre15">DOMFocusIn</code>和<code class="calibre15">focusin</code>的事件目标是获得焦点的元素。</p>

  <p class="calibre2">要确定浏览器是否支持这些事件，可以使用如下代码：</p>
  <pre class="calibre18"><code class="calibre15">var isSupported = document.implementation.hasFeature("FocusEvent", "3.0");
</code></pre>

  <blockquote class="calibre14">
    <p class="calibre2"><img alt="" class="calibre17" src="../Images/00002.gif" /> 即使<strong class="calibre3"><code class="calibre15">focus</code></strong>和<strong class="calibre3"><code class="calibre15">blur</code></strong>不冒泡，也可以在捕获阶段侦听到它们。Peter-Paul Koch就此写过一篇非常棒的文章：<a class="calibre6" href="http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html">www.quirksmode.org/blog/archives/2008/04/delegating_the.html</a>。</p>
  </blockquote>

  <h3 class="calibre22" id="nav_point_98">13.4.3　鼠标与滚轮事件</h3>

  <p class="calibre2">鼠标事件是Web开发中最常用的一类事件，毕竟鼠标还是最主要的定位设备。DOM3级事件中定义了9个鼠标事件，简介如下。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">click</code>：在用户单击主鼠标按钮（一般是左边的按钮）或者按下回车键时触发。这一点对确保易访问性很重要，意味着<code class="calibre15">onclick</code>事件处理程序既可以通过键盘也可以通过鼠标执行。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">dblclick</code>：在用户双击主鼠标按钮（一般是左边的按钮）时触发。从技术上说，这个事件并不是DOM2级事件规范中规定的，但鉴于它得到了广泛支持，所以DOM3级事件将其纳入了标准。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">mousedown</code>：在用户按下了任意鼠标按钮时触发。不能通过键盘触发这个事件。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">mouseenter</code>：在鼠标光标从元素外部首次移动到元素范围之内时触发。这个事件不冒泡，而且在光标移动到后代元素上不会触发。DOM2级事件并没有定义这个事件，但DOM3级事件将它纳入了规范。IE、Firefox 9+和Opera支持这个事件。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">mouseleave</code>：在位于元素上方的鼠标光标移动到元素范围之外时触发。这个事件不冒泡，而且在光标移动到后代元素上不会触发。DOM2级事件并没有定义这个事件，但DOM3级事件将它纳入了规范。IE、Firefox 9+和Opera支持这个事件。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">mousemove</code>：当鼠标指针在元素内部移动时重复地触发。不能通过键盘触发这个事件。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">mouseout</code>：在鼠标指针位于一个元素上方，然后用户将其移入另一个元素时触发。又移入的另一个元素可能位于前一个元素的外部，也可能是这个元素的子元素。不能通过键盘触发这个事件。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">mouseover</code>：在鼠标指针位于一个元素外部，然后用户将其首次移入另一个元素边界之内时触发。不能通过键盘触发这个事件。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">mouseup</code>：在用户释放鼠标按钮时触发。不能通过键盘触发这个事件。</p>
    </li>
  </ul>

  <p class="calibre2">页面上的所有元素都支持鼠标事件。除了<code class="calibre15">mouseenter</code>和<code class="calibre15">mouseleave</code>，所有鼠标事件都会冒泡，也可以被取消，而取消鼠标事件将会影响浏览器的默认行为。取消鼠标事件的默认行为还会影响其他事件，因为鼠标事件与其他事件是密不可分的关系。</p>

  <p class="calibre2">只有在同一个元素上相继触发<code class="calibre15">mousedown</code>和<code class="calibre15">mouseup</code>事件，才会触发<code class="calibre15">click</code>事件；如果<code class="calibre15">mousedown</code>或<code class="calibre15">mouseup</code>中的一个被取消，就不会触发<code class="calibre15">click</code>事件。类似地，只有触发两次<code class="calibre15">click</code>事件，才会触发一次<code class="calibre15">dblclick</code>事件。如果有代码阻止了连续两次触发<code class="calibre15">click</code>事件（可能是直接取消<code class="calibre15">click</code>事件，也可能通过取消<code class="calibre15">mousedown</code>或<code class="calibre15">mouseup</code>间接实现），那么就不会触发<code class="calibre15">dblclick</code>事件了。这4个事件触发的顺序始终如下：</p>

  <ol class="calibre11">
    <li class="calibre12" value="1">
      <p class="calibre2"><code class="calibre15">mousedown</code></p>
    </li>

    <li class="calibre12" value="2">
      <p class="calibre2"><code class="calibre15">mouseup</code></p>
    </li>

    <li class="calibre12" value="3">
      <p class="calibre2"><code class="calibre15">click</code></p>
    </li>

    <li class="calibre12" value="4">
      <p class="calibre2"><code class="calibre15">mousedown</code></p>
    </li>

    <li class="calibre12" value="5">
      <p class="calibre2"><code class="calibre15">mouseup</code></p>
    </li>

    <li class="calibre12" value="6">
      <p class="calibre2"><code class="calibre15">click</code></p>
    </li>

    <li class="calibre12" value="7">
      <p class="calibre2"><code class="calibre15">dblclick</code></p>
    </li>
  </ol>

  <p class="calibre2">显然，<code class="calibre15">click</code>和<code class="calibre15">dblclick</code>事件都会依赖于其他先行事件的触发；而<code class="calibre15">mousedown</code>和<code class="calibre15">mouseup</code>则不受其他事件的影响。</p>

  <p class="calibre2">IE8及之前版本中的实现有一个小bug，因此在双击事件中，会跳过第二个<code class="calibre15">mousedown</code>和<code class="calibre15">click</code>事件，其顺序如下：</p>

  <ol class="calibre11">
    <li class="calibre12" value="1">
      <p class="calibre2"><code class="calibre15">mousedown</code></p>
    </li>

    <li class="calibre12" value="2">
      <p class="calibre2"><code class="calibre15">mouseup</code></p>
    </li>

    <li class="calibre12" value="3">
      <p class="calibre2"><code class="calibre15">click</code></p>
    </li>

    <li class="calibre12" value="4">
      <p class="calibre2"><code class="calibre15">mouseup</code></p>
    </li>

    <li class="calibre12" value="5">
      <p class="calibre2"><code class="calibre15">dblclick</code></p>
    </li>
  </ol>

  <p class="calibre2">IE9修复了这个bug，之后顺序就正确了。</p>

  <p class="calibre2">使用以下代码可以检测浏览器是否支持以上DOM2级事件（除<code class="calibre15">dbclick</code>、<code class="calibre15">mouseenter</code>和<code class="calibre15">mouseleave</code>之外）：</p>
  <pre class="calibre18"><code class="calibre15">var isSupported = document.implementation.hasFeature("MouseEvents", "2.0");
</code></pre>

  <p class="calibre2">要检测浏览器是否支持上面的所有事件，可以使用以下代码：</p>
  <pre class="calibre18"><code class="calibre15">var isSupported = document.implementation.hasFeature("MouseEvent", "3.0")
</code></pre>

  <p class="calibre2">注意，DOM3级事件的<code class="calibre15">feature</code>名是<code class="calibre15">"MouseEvent"</code>，而非<code class="calibre15">"MouseEvents"</code>。</p>

  <p class="calibre2">鼠标事件中还有一类滚轮事件。而说是一类事件，其实就是一个<code class="calibre15">mousewheel</code>事件。这个事件跟踪鼠标滚轮，类似于Mac的触控板。</p>

  <p class="calibre2">1. <strong class="calibre3">客户区坐标位置</strong></p>

  <p class="calibre2">鼠标事件都是在浏览器视口中的特定位置上发生的。这个位置信息保存在事件对象的<code class="calibre15">clientX</code>和<code class="calibre15">clientY</code>属性中。所有浏览器都支持这两个属性，它们的值表示事件发生时鼠标指针在视口中的水平和垂直坐标。图13-4展示了视口中客户区坐标位置的含义。</p>

  <p class="p-img"><img alt="" class="calibre37" src="../Images/00042.gif" /></p>

  <p class="calibre2"><strong class="calibre3">图　13-4</strong></p>

  <p class="calibre2">可以使用类似下列代码取得鼠标事件的客户端坐标信息：</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">var div = document.getElementById("myDiv");
EventUtil.addHandler(div, "click", function(event){
    event = EventUtil.getEvent(event);
    alert("Client coordinates: " + event.clientX + "," + event.clientY);
});
</code></pre>

  <p class="calibre8"><i class="calibre7">ClientCoordinatesExample01.htm</i></p>

  <p class="calibre2">这里为一个<code class="calibre15">&lt;div&gt;</code>元素指定了<code class="calibre15">onclick</code>事件处理程序。当用户单击这个元素时，就会看到事件的客户端坐标信息。注意，这些值中不包括页面滚动的距离，因此这个位置并不表示鼠标在页面上的位置。</p>

  <p class="calibre2">2. <strong class="calibre3">页面坐标位置</strong></p>

  <p class="calibre2">通过客户区坐标能够知道鼠标是在视口中什么位置发生的，而页面坐标通过事件对象的<code class="calibre15">pageX</code>和<code class="calibre15">pageY</code>属性，能告诉你事件是在页面中的什么位置发生的。换句话说，这两个属性表示鼠标光标在页面中的位置，因此坐标是从页面本身而非视口的左边和顶边计算的。</p>

  <p class="calibre2">以下代码可以取得鼠标事件在页面中的坐标：</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">var div = document.getElementById("myDiv");
EventUtil.addHandler(div, "click", function(event){
    event = EventUtil.getEvent(event);
    alert("Page coordinates: " + event.pageX + "," + event.pageY);
}); 
</code></pre>

  <p class="calibre8"><i class="calibre7">PageCoordinatesExample01.htm</i></p>

  <p class="calibre2">在页面没有滚动的情况下，<code class="calibre15">pageX</code>和<code class="calibre15">pageY</code>的值与<code class="calibre15">clientX</code>和<code class="calibre15">clientY</code>的值相等。</p>

  <p class="calibre2">IE8及更早版本不支持事件对象上的页面坐标，不过使用客户区坐标和滚动信息可以计算出来。这时候需要用到<code class="calibre15">document.body</code>（混杂模式）或<code class="calibre15">document.documentElement</code>（标准模式）中的<code class="calibre15">scrollLeft</code>和<code class="calibre15">scrollTop</code>属性。计算过程如下所示：</p>
  <pre class="calibre18"><code class="calibre15">var div = document.getElementById("myDiv");
EventUtil.addHandler(div, "click", function(event){
    event = EventUtil.getEvent(event);
    var pageX = event.pageX,
        pageY = event.pageY;

    if (pageX === undefined){
        pageX = event.clientX + (document.body.scrollLeft ||
                document.documentElement.scrollLeft);
    } 

    if (pageY === undefined){
        pageY = event.clientY + (document.body.scrollTop ||
                document.documentElement.scrollTop);
    }

    alert("Page coordinates: " + pageX + "," + pageY);
});
</code></pre>

  <p class="calibre8"><i class="calibre7">PageCoordinatesExample01.htm</i></p>

  <p class="calibre2">3. <strong class="calibre3">屏幕坐标位置</strong></p>

  <p class="calibre2">鼠标事件发生时，不仅会有相对于浏览器窗口的位置，还有一个相对于整个电脑屏幕的位置。而通过<code class="calibre15">screenX</code>和<code class="calibre15">screenY</code>属性就可以确定鼠标事件发生时鼠标指针相对于整个屏幕的坐标信息。图13-5展示了浏览器中屏幕坐标的含义。</p>

  <p class="p-img"><img alt="" class="calibre37" src="../Images/00043.jpeg" /></p>

  <p class="calibre2"><strong class="calibre3">图　13-5</strong></p>

  <p class="calibre2">可以使用类似下面的代码取得鼠标事件的屏幕坐标：</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18">var div = document.getElementById("myDiv");
EventUtil.addHandler(div, "click", function(event){
    event = EventUtil.getEvent(event);
    <b class="calibre3">alert("Screen coordinates: " + event.screenX + "," + event.screenY);</b>
});
</pre>

  <p class="calibre8"><i class="calibre7">ScreenCoordinatesExample01.htm</i></p>

  <p class="calibre2">与前一个例子类似，这里也是为<code class="calibre15">&lt;div&gt;</code>元素指定了一个<code class="calibre15">onclick</code>事件处理程序。当这个元素被单击时，就会显示出事件的屏幕坐标信息了。</p>

  <p class="calibre2">4. <strong class="calibre3">修改键</strong></p>

  <p class="calibre2">虽然鼠标事件主要是使用鼠标来触发的，但在按下鼠标时键盘上的某些键的状态也可以影响到所要采取的操作。这些修改键就是Shift、Ctrl、Alt和Meta（在Windows键盘中是Windows键，在苹果机中是Cmd键），它们经常被用来修改鼠标事件的行为。DOM为此规定了4个属性，表示这些修改键的状态：<code class="calibre15">shiftKey</code>、<code class="calibre15">ctrlKey</code>、<code class="calibre15">altKey</code>和<code class="calibre15">metaKey</code>。这些属性中包含的都是布尔值，如果相应的键被按下了，则值为<code class="calibre15">true</code>，否则值为<code class="calibre15">false</code>。当某个鼠标事件发生时，通过检测这几个属性就可以确定用户是否同时按下了其中的键。来看下面的例子。</p>
  <pre class="calibre18"><code class="calibre15">var div = document.getElementById("myDiv");
EventUtil.addHandler(div, "click", function(event){
    event = EventUtil.getEvent(event);
    var keys = new Array();

    if (event.shiftKey){
        keys.push("shift");
    }

    if (event.ctrlKey){
        keys.push("ctrl");
    }

    if (event.altKey){
        keys.push("alt");
    }

    if (event.metaKey){
        keys.push("meta");
    }

    alert("Keys: " + keys.join(","));

});
</code></pre>

  <p class="calibre8"><i class="calibre7">ModifierKeysExample01.htm</i></p>

  <p class="calibre2">在这个例子中，我们通过一个<code class="calibre15">onclick</code>事件处理程序检测了不同修改键的状态。数组<code class="calibre15">keys</code>中包含着被按下的修改键的名称。换句话说，如果有属性值为<code class="calibre15">true</code>，就会将对应修改键的名称添加到<code class="calibre15">keys</code>数组中。在事件处理程序的最后，有一个警告框将检测到的键的信息显示给用户。</p>

  <blockquote class="calibre14">
    <p class="calibre2"><img alt="" class="calibre17" src="../Images/00002.gif" /> IE9、Firefox、Safari、Chrome和Opera都支持这4个键。IE8及之前版本不支持<strong class="calibre3"><code class="calibre15">metaKey</code></strong>属性。</p>
  </blockquote>

  <p class="calibre2">5. <strong class="calibre3">相关元素</strong></p>

  <p class="calibre2">在发生<code class="calibre15">mouseover</code>和<code class="calibre15">mouserout</code>事件时，还会涉及更多的元素。这两个事件都会涉及把鼠标指针从一个元素的边界之内移动到另一个元素的边界之内。对<code class="calibre15">mouseover</code>事件而言，事件的主目标是获得光标的元素，而相关元素就是那个失去光标的元素。类似地，对<code class="calibre15">mouseout</code>事件而言，事件的主目标是失去光标的元素，而相关元素则是获得光标的元素。来看下面的例子。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Related Elements Example&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="myDiv" style="background-color:red;height:100px;width:100px;"&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

  <p class="calibre8"><i class="calibre7">RelatedElementsExample01.htm</i></p>

  <p class="calibre2">这个例子会在页面上显示一个<code class="calibre15">&lt;div&gt;</code>元素。如果鼠标指针一开始位于这个<code class="calibre15">&lt;div&gt;</code>元素上，然后移出了这个元素，那么就会在<code class="calibre15">&lt;div&gt;</code>元素上触发<code class="calibre15">mouseout</code>事件，相关元素就是<code class="calibre15">&lt;body&gt;</code>元素。与此同时，<code class="calibre15">&lt;body&gt;</code>元素上面会触发<code class="calibre15">mouseover</code>事件，而相关元素变成了<code class="calibre15">&lt;div&gt;</code>。</p>

  <p class="calibre2">DOM通过<code class="calibre15">event</code>对象的<code class="calibre15">relatedTarget</code>属性提供了相关元素的信息。这个属性只对于<code class="calibre15">mouseover</code>和<code class="calibre15">mouseout</code>事件才包含值；对于其他事件，这个属性的值是<code class="calibre15">null</code>。IE8及之前版本不支持<code class="calibre15">relatedTarget</code>属性，但提供了保存着同样信息的不同属性。在<code class="calibre15">mouseover</code>事件触发时，IE的<code class="calibre15">fromElement</code>属性中保存了相关元素；在<code class="calibre15">mouseout</code>事件触发时，IE的<code class="calibre15">toElement</code>属性中保存着相关元素。（IE9支持所有这些属性。）可以把下面这个跨浏览器取得相关元素的方法添加到<code class="calibre15">EventUtil</code>对象中。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18">var EventUtil = {

    //省略了其他代码

    <b class="calibre3">getRelatedTarget: function(event){</b>
        <b class="calibre3">if (event.relatedTarget){</b>
            <b class="calibre3">return event.relatedTarget;</b>
        <b class="calibre3">} else if (event.toElement){</b>
            <b class="calibre3">return event.toElement;</b>
        <b class="calibre3">} else if (event.fromElement){</b>
            <b class="calibre3">return event.fromElement;</b>
        <b class="calibre3">} else {</b>
            <b class="calibre3">return null;</b>
        <b class="calibre3">}</b>

    <b class="calibre3">},</b>

    //省略了其他代码

};
</pre>

  <p class="calibre8"><i class="calibre7">EventUtil.js</i></p>

  <p class="calibre2">与以前添加的跨浏览器方法一样，这个方法也使用了特性检测来确定返回哪个值。可以像下面这样使用<code class="calibre15">EventUtil.getRelatedTarget()</code>方法：</p>
  <pre class="calibre18"><code class="calibre15">var div = document.getElementById("myDiv");
EventUtil.addHandler(div, "mouseout", function(event){
    event = EventUtil.getEvent(event);
    var target = EventUtil.getTarget(event);
    var relatedTarget = EventUtil.getRelatedTarget(event);
    alert("Moused out of " + target.tagName + " to " + relatedTarget.tagName);        
}); 
</code></pre>

  <p class="calibre8"><i class="calibre7">RelatedElementsExample01.htm</i></p>

  <p class="calibre2">这个例子为<code class="calibre15">&lt;div&gt;</code>元素的<code class="calibre15">mouseout</code>事件注册了一个事件处理程序。当事件触发时，会有一个警告框显示鼠标移出和移入的元素信息。</p>

  <p class="calibre2">6. <strong class="calibre3">鼠标按钮</strong></p>

  <p class="calibre2">只有在主鼠标按钮被单击（或键盘回车键被按下）时才会触发<code class="calibre15">click</code>事件，因此检测按钮的信息并不是必要的。但对于<code class="calibre15">mousedown</code>和<code class="calibre15">mouseup</code>事件来说，则在其<code class="calibre15">event</code>对象存在一个<code class="calibre15">button</code>属性，表示按下或释放的按钮。DOM的<code class="calibre15">button</code>属性可能有如下3个值：<code class="calibre15">0</code>表示主鼠标按钮，<code class="calibre15">1</code>表示中间的鼠标按钮（鼠标滚轮按钮），<code class="calibre15">2</code>表示次鼠标按钮。在常规的设置中，主鼠标按钮就是鼠标左键，而次鼠标按钮就是鼠标右键。</p>

  <p class="calibre2">IE8及之前版本也提供了<code class="calibre15">button</code>属性，但这个属性的值与DOM的<code class="calibre15">button</code>属性有很大差异。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">0</code>：表示没有按下按钮。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">1</code>：表示按下了主鼠标按钮。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">2</code>：表示按下了次鼠标按钮。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">3</code>：表示同时按下了主、次鼠标按钮。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">4</code>：表示按下了中间的鼠标按钮。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">5</code>：表示同时按下了主鼠标按钮和中间的鼠标按钮。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">6</code>：表示同时按下了次鼠标按钮和中间的鼠标按钮。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">7</code>：表示同时按下了三个鼠标按钮。</p>
    </li>
  </ul>

  <p class="calibre2">不难想见，DOM模型下的<code class="calibre15">button</code>属性比IE模型下的<code class="calibre15">button</code>属性更简单也更为实用，因为同时按下多个鼠标按钮的情形十分罕见。最常见的做法就是将IE模型规范化为DOM方式，毕竟除IE8及更早版本之外的其他浏览器都原生支持DOM模型。而对主、中、次按钮的映射并不困难，只要将IE的其他选项分别转换成如同按下这三个按键中的一个即可（同时将主按钮作为优先选取的对象）。换句话说，IE中返回的<code class="calibre15">5</code>和<code class="calibre15">7</code>会被转换成DOM模型中的<code class="calibre15">0</code>。</p>

  <p class="calibre2">由于单独使用能力检测无法确定差异（两种模型有同名的<code class="calibre15">button</code>属性），因此必须另辟蹊径。我们知道，支持DOM版鼠标事件的浏览器可以通过<code class="calibre15">hasFeature()</code>方法来检测，所以可以再为<code class="calibre15">EventUtil</code>对象添加如下<code class="calibre15">getButton()</code>方法。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18">var EventUtil = {

    //省略了其他代码

    <b class="calibre3">getButton: function(event){</b>
        <b class="calibre3">if (document.implementation.hasFeature("MouseEvents", "2.0")){</b>
            <b class="calibre3">return event.button;</b>
        <b class="calibre3">} else {</b>
            <b class="calibre3">switch(event.button){</b>
                <b class="calibre3">case 0:</b>
                <b class="calibre3">case 1:</b>
                <b class="calibre3">case 3:</b>
                <b class="calibre3">case 5:</b>
                <b class="calibre3">case 7:</b>
                    <b class="calibre3">return 0;</b>
                <b class="calibre3">case 2:</b>
                <b class="calibre3">case 6:</b>
                    <b class="calibre3">return 2;</b>
                <b class="calibre3">case 4:</b>
                    <b class="calibre3">return 1;</b>
            <b class="calibre3">}</b>
        <b class="calibre3">}</b>
    <b class="calibre3">},</b>

    //省略了其他代码

};
</pre>

  <p class="calibre8"><i class="calibre7">EventUtil.js</i></p>

  <p class="calibre2">通过检测<code class="calibre15">"MouseEvents"</code>这个特性，就可以确定<code class="calibre15">event</code>对象中存在的<code class="calibre15">button</code>属性中是否包含正确的值。如果测试失败，说明是IE，就必须对相应的值进行规范化。以下是使用该方法的示例。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18">var div = document.getElementById("myDiv");
<b class="calibre3">EventUtil.addHandler(div, "mousedown", function(event){</b>
    <b class="calibre3">event = EventUtil.getEvent(event);</b>
    <b class="calibre3">alert(EventUtil.getButton(event));</b>
<b class="calibre3">});</b>
</pre>

  <p class="calibre8"><i class="calibre7">ButtonExample01.htm</i></p>

  <p class="calibre2">在这个例子中，我们为一个<code class="calibre15">&lt;div&gt;</code>元素添加了一个<code class="calibre15">onmousedown</code>事件处理程序。当在这个元素上按下鼠标按钮时，会有警告框显示按钮的代码。</p>

  <blockquote class="calibre14">
    <p class="calibre2"><img alt="" class="calibre17" src="../Images/00002.gif" /> 在使用<strong class="calibre3"><code class="calibre15">onmouseup</code></strong>事件处理程序时，<strong class="calibre3"><code class="calibre15">button</code></strong>的值表示释放的是哪个按钮。此外，如果不是按下或释放了主鼠标按钮，Opera不会触发<code class="calibre15">mouseup</code>或<code class="calibre15">mousedown</code> 事件。</p>
  </blockquote>

  <p class="calibre2">7. <strong class="calibre3">更多的事件信息</strong></p>

  <p class="calibre2">“DOM2级事件”规范在<code class="calibre15">event</code>对象中还提供了<code class="calibre15">detail</code>属性，用于给出有关事件的更多信息。对于鼠标事件来说，<code class="calibre15">detail</code>中包含了一个数值，表示在给定位置上发生了多少次单击。在同一个像素上相继地发生一次<code class="calibre15">mousedown</code>和一次<code class="calibre15">mouseup</code>事件算作一次单击。<code class="calibre15">detail</code>属性从<code class="calibre15">1</code>开始计数，每次单击发生后都会递增。如果鼠标在<code class="calibre15">mousedown</code>和<code class="calibre15">mouseup</code>之间移动了位置，则<code class="calibre15">detail</code>会被重置为<code class="calibre15">0</code>。</p>

  <p class="calibre2">IE也通过下列属性为鼠标事件提供了更多信息。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">altLeft</code>：布尔值，表示是否按下了Alt键。如果<code class="calibre15">altLeft</code>的值为<code class="calibre15">true</code>，则<code class="calibre15">altKey</code>的值也为<code class="calibre15">true</code>。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">ctrlLeft</code>：布尔值，表示是否按下了Ctrl键。如果<code class="calibre15">ctrlLeft</code>的值为<code class="calibre15">true</code>，则<code class="calibre15">ctrlKey</code>的值也为<code class="calibre15">true</code>。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">offsetX</code>：光标相对于目标元素边界的x坐标。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">offsetY</code>：光标相对于目标元素边界的y坐标。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">shiftLeft</code>：布尔值，表示是否按下了Shift键。如果<code class="calibre15">shiftLeft</code>的值为<code class="calibre15">true</code>，则<code class="calibre15">shiftKey</code>的值也为<code class="calibre15">true</code>。</p>
    </li>
  </ul>

  <p class="calibre2">这些属性的用处并不大，原因一方面是只有IE支持它们，另一方是它们提供的信息要么没有什么价值，要么可以通过其他方式计算得来。</p>

  <p class="calibre2">8. <strong class="calibre3">鼠标滚轮事件</strong></p>

  <p class="calibre2">IE 6.0首先实现了<code class="calibre15">mousewheel</code>事件。此后，Opera、Chrome和Safari也都实现了这个事件。当用户通过鼠标滚轮与页面交互、在垂直方向上滚动页面时（无论向上还是向下），就会触发<code class="calibre15">mousewheel</code>事件。这个事件可以在任何元素上面触发，最终会冒泡到<code class="calibre15">document</code>（IE8）或<code class="calibre15">window</code>（IE9、Opera、Chrome及Safari）对象。与<code class="calibre15">mousewheel</code>事件对应的<code class="calibre15">event</code>对象除包含鼠标事件的所有标准信息外，还包含一个特殊的<code class="calibre15">wheelDelta</code>属性。当用户向前滚动鼠标滚轮时，<code class="calibre15">wheelDelta</code>是120的倍数；当用户向后滚动鼠标滚轮时，<code class="calibre15">wheelDelta</code>是-120的倍数。图13-6展示了这个属性。</p>

  <p class="p-img"><img alt="" class="calibre42" src="../Images/00044.gif" /></p>

  <p class="calibre2"><strong class="calibre3">图　13-6</strong></p>

  <p class="calibre2">将<code class="calibre15">mousewheel</code>事件处理程序指定给页面中的任何元素或<code class="calibre15">document</code>对象，即可处理鼠标滚轮的交互操作。来看下面的例子。</p>
  <pre class="calibre18"><code class="calibre15">EventUtil.addHandler(document, "mousewheel", function(event){
    event = EventUtil.getEvent(event);
    alert(event.wheelDelta);
});
</code></pre>

  <p class="calibre2">这个例子会在发生<code class="calibre15">mousewheel</code>事件时显示<code class="calibre15">wheelDelta</code>的值。多数情况下，只要知道鼠标滚轮滚动的方向就够了，而这通过检测<code class="calibre15">wheelDelta</code>的正负号就可以确定。</p>

  <p class="calibre2">有一点要注意：在Opera 9.5之前的版本中，<code class="calibre15">wheelDelta</code>值的正负号是颠倒的。如果你打算支持早期的Opera版本，就需要使用浏览器检测技术来确定实际的值，如下面的例子所示。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18">EventUtil.addHandler(document, "mousewheel", function(event){
    event = EventUtil.getEvent(event);
    <b class="calibre3">var delta = (client.engine.opera &amp;&amp; client.engine.opera </b>
                <b class="calibre3">-event.wheelDelta : event.wheelDelta);</b>
    alert(delta);
});
</pre>

  <p class="calibre8"><i class="calibre7">MouseWheelEventExample01.htm</i></p>

  <p class="calibre2">以上代码使用第9章创建的<code class="calibre15">client</code>对象检测了浏览器是不是早期版本的Opera。</p>

  <blockquote class="calibre14">
    <p class="calibre2"><img alt="" class="calibre17" src="../Images/00002.gif" /> 由于<strong class="calibre3"><code class="calibre15">mousewheel</code></strong>事件非常流行，而且所有浏览器都支持它，所以HTML 5也加入了该事件。</p>
  </blockquote>

  <p class="calibre2">Firefox支持一个名为<code class="calibre15">DOMMouseScroll</code>的类似事件，也是在鼠标滚轮滚动时触发。与<code class="calibre15">mousewheel</code>事件一样，<code class="calibre15">DOMMouseScroll</code>也被视为鼠标事件，因而包含与鼠标事件有关的所有属性。而有关鼠标滚轮的信息则保存在<code class="calibre15">detail</code>属性中，当向前滚动鼠标滚轮时，这个属性的值是<code class="calibre15">-3</code>的倍数，当向后滚动鼠标滚轮时，这个属性的值是<code class="calibre15">3</code>的倍数。图13-7展示了这个属性。</p>

  <p class="p-img"><img alt="" class="calibre42" src="../Images/00045.gif" /></p>

  <p class="calibre2"><strong class="calibre3">图　13-7</strong></p>

  <p class="calibre2">可以将<code class="calibre15">DOMMouseScroll</code>事件添加到页面中的任何元素，而且该事件会冒泡到<code class="calibre15">window</code>对象。因此，可以像下面这样针对这个事件来添加事件处理程序。</p>
  <pre class="calibre18"><code class="calibre15">EventUtil.addHandler(window, "DOMMouseScroll", function(event){
    event = EventUtil.getEvent(event);
    alert(event.detail);
});
</code></pre>

  <p class="calibre8"><i class="calibre7">DOMMouseScrollEventExample01.htm</i></p>

  <p class="calibre2">这个简单的事件处理程序会在鼠标滚轮滚动时显示<code class="calibre15">detail</code>属性的值。</p>

  <p class="calibre2">若要给出跨浏览器环境下的解决方案，第一步就是创建一个能够取得鼠标滚轮增量值（delta）的方法。下面是我们添加到<code class="calibre15">EventUtil</code>对象中的这个方法。</p>
  <pre class="calibre18">var EventUtil = {

    //省略了其他代码

    <b class="calibre3">getWheelDelta: function(event){</b>
        <b class="calibre3">if (event.wheelDelta){</b>
            <b class="calibre3">return (client.engine.opera &amp;&amp; client.engine.opera </b>
                    <b class="calibre3">-event.wheelDelta : event.wheelDelta);</b>
        <b class="calibre3">} else {</b>
            <b class="calibre3">return -event.detail * 40;</b>
        <b class="calibre3">}</b>
    <b class="calibre3">},</b>

    //省略了其他代码
};
</pre>

  <p class="calibre8"><i class="calibre7">EventUtil.js</i></p>

  <p class="calibre2">这里，<code class="calibre15">getWheelDelta()</code>方法首先检测了事件对象是否包含<code class="calibre15">wheelDelta</code>属性，如果是则通过浏览器检测代码确定正确的值。如果<code class="calibre15">wheelDelta</code>不存在，则假设相应的值保存在<code class="calibre15">detail</code>属性中。由于Firefox的值有所不同，因此首先要将这个值的符号反向，然后再乘以40，就可以保证与其他浏览器的值相同了。有了这个方法之后，就可以将相同的事件处理程序指定给<code class="calibre15">mousewheel</code>和<code class="calibre15">DOMMouseScroll</code>事件了，例如：</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">(function(){

    function handleMouseWheel(event){
        event = EventUtil.getEvent(event);
        var delta = EventUtil.getWheelDelta(event);
        alert(delta);
    }

    EventUtil.addHandler(document, "mousewheel", handleMouseWheel);
    EventUtil.addHandler(document, "DOMMouseScroll", handleMouseWheel);

})();
</code></pre>

  <p class="calibre8"><i class="calibre7">CrossBrowserMouseWheelExample01.htm</i></p>

  <p class="calibre2">我们将相关代码放在了一个私有作用域中，从而不会让新定义的函数干扰全局作用域。这里定义的<code class="calibre15">handleMouseWheel()</code>函数可以用作两个事件的处理程序（如果指定的事件不存在，则为该事件指定处理程序的代码就会静默地失败）。由于使用了<code class="calibre15">EventUtil.getWheelDelta()</code>方法，我们定义的这个事件处理程序函数可以适用于任何一种情况。</p>

  <p class="calibre2">9. <strong class="calibre3">触摸设备</strong></p>

  <p class="calibre2">iOS和Android设备的实现非常特别，因为这些设备没有鼠标。在面向iPhone和iPod中的Safari开发时，要记住以下几点。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2">不支持<code class="calibre15">dblclick</code>事件。双击浏览器窗口会放大画面，而且没有办法改变该行为。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2">轻击可单击元素会触发<code class="calibre15">mousemove</code>事件。如果此操作会导致内容变化，将不再有其他事件发生；如果屏幕没有因此变化，那么会依次发生<code class="calibre15">mousedown</code>、<code class="calibre15">mouseup</code>和<code class="calibre15">click</code>事件。轻击不可单击的元素不会触发任何事件。可单击的元素是指那些单击可产生默认操作的元素（如链接），或者那些已经被指定了<code class="calibre15">onclick</code>事件处理程序的元素。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">mousemove</code>事件也会触发<code class="calibre15">mouseover</code>和<code class="calibre15">mouseout</code>事件。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2">两个手指放在屏幕上且页面随手指移动而滚动时会触发<code class="calibre15">mousewheel</code>和<code class="calibre15">scroll</code>事件。</p>
    </li>
  </ul>

  <p class="calibre2">10. <strong class="calibre3">无障碍性问题</strong></p>

  <p class="calibre2">如果你的Web应用程序或网站要确保残疾人特别是那些使用屏幕阅读器的人都能访问，那么在使用鼠标事件时就要格外小心。前面提到过，可以通过键盘上的回车键来触发<code class="calibre15">click</code>事件，但其他鼠标事件却无法通过键盘来触发。为此，我们不建议使用<code class="calibre15">click</code>之外的其他鼠标事件来展示功能或引发代码执行。因为这样会给盲人或视障用户造成极大不便。以下是在使用鼠标事件时应当注意的几个易访问性问题。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2">使用<code class="calibre15">click</code>事件执行代码。有人指出通过<code class="calibre15">onmousedown</code>执行代码会让人觉得速度更快，对视力正常的人来说这是没错的。但是，在屏幕阅读器中，由于无法触发<code class="calibre15">mousedown</code>事件，结果就会造成代码无法执行。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2">不要使用<code class="calibre15">onmouseover</code>向用户显示新的选项。原因同上，屏幕阅读器无法触发这个事件。如果确实非要通过这种方式来显示新选项，可以考虑添加显示相同信息的键盘快捷方式。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2">不要使用<code class="calibre15">dblclick</code>执行重要的操作。键盘无法触发这个事件。</p>
    </li>
  </ul>

  <p class="calibre2">遵照以上提示可以极大地提升残疾人在访问你的Web应用程序或网站时的易访问性。</p>

  <blockquote class="calibre14">
    <p class="calibre2"><img alt="" class="calibre17" src="../Images/00002.gif" /> 要了解如何在网页中实现无障碍访问的内容，请访问<a class="calibre6" href="http://www.webaim.org">www.webaim.org</a>和<a class="calibre6" href="http://yaccessibilityblog.com/">http://yaccessibilityblog.com/</a>。</p>
  </blockquote>

  <h3 class="calibre22" id="nav_point_99">13.4.4　键盘与文本事件</h3>

  <p class="calibre2">用户在使用键盘时会触发键盘事件。“DOM2级事件”最初规定了键盘事件，但在最终定稿之前又删除了相应的内容。结果，对键盘事件的支持主要遵循的是DOM0级。</p>

  <p class="calibre2">“DOM3级事件”为键盘事件制定了规范，IE9率先完全实现了该规范。其他浏览器也在着手实现这一标准，但仍然有很多遗留的问题。</p>

  <p class="calibre2">有3个键盘事件，简述如下。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">keydown</code>：当用户按下键盘上的任意键时触发，而且如果按住不放的话，会重复触发此事件。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">keypress</code>：当用户按下键盘上的字符键时触发，而且如果按住不放的话，会重复触发此事件。按下Esc键也会触发这个事件。Safari 3.1之前的版本也会在用户按下非字符键时触发<code class="calibre15">keypress</code>事件。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">keyup</code>：当用户释放键盘上的键时触发。</p>
    </li>
  </ul>

  <p class="calibre2">虽然所有元素都支持以上3个事件，但只有在用户通过文本框输入文本时才最常用到。</p>

  <p class="calibre2">只有一个文本事件：<code class="calibre15">textInput</code>。这个事件是对<code class="calibre15">keypress</code>的补充，用意是在将文本显示给用户之前更容易拦截文本。在文本插入文本框之前会触发<code class="calibre15">textInput</code>事件。</p>

  <p class="calibre2">在用户按了一下键盘上的字符键时，首先会触发<code class="calibre15">keydown</code>事件，然后紧跟着是<code class="calibre15">keypress</code>事件，最后会触发<code class="calibre15">keyup</code>事件。其中，<code class="calibre15">keydown</code>和<code class="calibre15">keypress</code>都是在文本框发生变化之前被触发的；而<code class="calibre15">keyup</code>事件则是在文本框已经发生变化之后被触发的。如果用户按下了一个字符键不放，就会重复触发<code class="calibre15">keydown</code>和<code class="calibre15">keypress</code>事件，直到用户松开该键为止。</p>

  <p class="calibre2">如果用户按下的是一个非字符键，那么首先会触发<code class="calibre15">keydown</code>事件，然后就是<code class="calibre15">keyup</code>事件。如果按住这个非字符键不放，那么就会一直重复触发<code class="calibre15">keydown</code>事件，直到用户松开这个键，此时会触发<code class="calibre15">keyup</code>事件。</p>

  <blockquote class="calibre14">
    <p class="calibre2"><img alt="" class="calibre17" src="../Images/00002.gif" /> 键盘事件与鼠标事件一样，都支持相同的修改键。而且，键盘事件的事件对象中也有<code class="calibre15">shiftKey</code>、<code class="calibre15">ctrlKey</code>、<code class="calibre15">altKey</code>和<code class="calibre15">metaKey</code>属性。IE不支持<code class="calibre15">metaKey</code>。</p>
  </blockquote>

  <p class="calibre2">1. <strong class="calibre3">键码</strong></p>

  <p class="calibre2">在发生<code class="calibre15">keydown</code>和<code class="calibre15">keyup</code>事件时，<code class="calibre15">event</code>对象的<code class="calibre15">keyCode</code>属性中会包含一个代码，与键盘上一个特定的键对应。对数字字母字符键，<code class="calibre15">keyCode</code>属性的值与ASCII码中对应小写字母或数字的编码相同。因此，数字键7的<code class="calibre15">keyCode</code>值为55，而字母A键的<code class="calibre15">keyCode</code>值为65——与Shift键的状态无关。DOM和IE的<code class="calibre15">event</code>对象都支持<code class="calibre15">keyCode</code>属性。请看下面这个例子：</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">var textbox = document.getElementById("myText");
EventUtil.addHandler(textbox, "keyup", function(event){
    event = EventUtil.getEvent(event);
    alert(event.keyCode);
});
</code></pre>

  <p class="calibre8"><i class="calibre7">KeyUpEventExample01.htm</i></p>

  <p class="calibre2">在这个例子中，用户每次在文本框中按键触发<code class="calibre15">keyup</code>事件时，都会显示<code class="calibre15">keyCode</code>的值。下表列出了所有非字符键的键码。</p>

  <table class="table">
    <tbody class="calibre23">
      <tr class="calibre24">
        <th class="calibre25" width="50%">键</th>

        <th class="calibre25" width="50%">键　　码</th>
      </tr>

      <tr class="calibre26">
        <td class="calibre27">退格（Backspace）</td>

        <td class="calibre28">8</td>
      </tr>

      <tr class="calibre24">
        <td class="calibre27">制表（Tab）</td>

        <td class="calibre28">9</td>
      </tr>

      <tr class="calibre26">
        <td class="calibre27">回车（Enter）</td>

        <td class="calibre28">13</td>
      </tr>

      <tr class="calibre24">
        <td class="calibre27">上档（Shift）</td>

        <td class="calibre28">16</td>
      </tr>

      <tr class="calibre26">
        <td class="calibre27">控制（Ctrl）</td>

        <td class="calibre28">17</td>
      </tr>

      <tr class="calibre24">
        <td class="calibre27">Alt</td>

        <td class="calibre28">18</td>
      </tr>

      <tr class="calibre26">
        <td class="calibre27">暂停/中断（Pause/Break）</td>

        <td class="calibre28">19</td>
      </tr>

      <tr class="calibre24">
        <td class="calibre27">大写锁定（Caps Lock）</td>

        <td class="calibre28">20</td>
      </tr>

      <tr class="calibre26">
        <td class="calibre27">退出（Esc）</td>

        <td class="calibre28">27</td>
      </tr>

      <tr class="calibre24">
        <td class="calibre27">上翻页（Page Up）</td>

        <td class="calibre28">33</td>
      </tr>

      <tr class="calibre26">
        <td class="calibre27">下翻页（Page Down）</td>

        <td class="calibre28">34</td>
      </tr>

      <tr class="calibre24">
        <td class="calibre27">结尾（End）</td>

        <td class="calibre28">35</td>
      </tr>

      <tr class="calibre26">
        <td class="calibre27">开头（Home）</td>

        <td class="calibre28">36</td>
      </tr>

      <tr class="calibre24">
        <td class="calibre27">左箭头（Left Arrow）</td>

        <td class="calibre28">37</td>
      </tr>

      <tr class="calibre26">
        <td class="calibre27">上箭头（Up Arrow）</td>

        <td class="calibre28">38</td>
      </tr>

      <tr class="calibre24">
        <td class="calibre27">右箭头（Right Arrow）</td>

        <td class="calibre28">39</td>
      </tr>

      <tr class="calibre26">
        <td class="calibre27">下箭头（Down Arrow）</td>

        <td class="calibre28">40</td>
      </tr>

      <tr class="calibre24">
        <td class="calibre27">插入（Ins）</td>

        <td class="calibre28">45</td>
      </tr>

      <tr class="calibre26">
        <td class="calibre27">删除（Del）</td>

        <td class="calibre28">46</td>
      </tr>

      <tr class="calibre24">
        <td class="calibre27">左Windows键</td>

        <td class="calibre28">91</td>
      </tr>

      <tr class="calibre26">
        <td class="calibre27">右Windows键</td>

        <td class="calibre28">92</td>
      </tr>

      <tr class="calibre24">
        <td class="calibre27">上下文菜单键</td>

        <td class="calibre28">93</td>
      </tr>

      <tr class="calibre26">
        <td class="calibre27">数字小键盘0</td>

        <td class="calibre28">96</td>
      </tr>

      <tr class="calibre24">
        <td class="calibre27">数字小键盘1</td>

        <td class="calibre28">97</td>
      </tr>

      <tr class="calibre26">
        <td class="calibre27">数字小键盘2</td>

        <td class="calibre28">98</td>
      </tr>

      <tr class="calibre24">
        <td class="calibre27">数字小键盘3</td>

        <td class="calibre28">99</td>
      </tr>

      <tr class="calibre26">
        <td class="calibre27">数字小键盘4</td>

        <td class="calibre28">100</td>
      </tr>

      <tr class="calibre24">
        <td class="calibre27">数字小键盘5</td>

        <td class="calibre28">101</td>
      </tr>

      <tr class="calibre26">
        <td class="calibre27">数字小键盘6</td>

        <td class="calibre28">102</td>
      </tr>

      <tr class="calibre24">
        <td class="calibre27">数字小键盘7</td>

        <td class="calibre28">103</td>
      </tr>

      <tr class="calibre26">
        <td class="calibre27">数字小键盘8</td>

        <td class="calibre28">104</td>
      </tr>

      <tr class="calibre24">
        <td class="calibre27">数字小键盘9</td>

        <td class="calibre28">105</td>
      </tr>

      <tr class="calibre26">
        <td class="calibre27">数字小键盘+</td>

        <td class="calibre28">107</td>
      </tr>

      <tr class="calibre24">
        <td class="calibre27">数字小键盘及大键盘上的-</td>

        <td class="calibre28">109</td>
      </tr>

      <tr class="calibre26">
        <td class="calibre27">数字小键盘 .</td>

        <td class="calibre28">110</td>
      </tr>

      <tr class="calibre24">
        <td class="calibre27">数字小键盘 /</td>

        <td class="calibre28">111</td>
      </tr>

      <tr class="calibre26">
        <td class="calibre27">F1</td>

        <td class="calibre28">112</td>
      </tr>

      <tr class="calibre24">
        <td class="calibre27">F2</td>

        <td class="calibre28">113</td>
      </tr>

      <tr class="calibre26">
        <td class="calibre27">F3</td>

        <td class="calibre28">114</td>
      </tr>

      <tr class="calibre24">
        <td class="calibre27">F4</td>

        <td class="calibre28">115</td>
      </tr>

      <tr class="calibre26">
        <td class="calibre27">F5</td>

        <td class="calibre28">116</td>
      </tr>

      <tr class="calibre24">
        <td class="calibre27">F6</td>

        <td class="calibre28">117</td>
      </tr>

      <tr class="calibre26">
        <td class="calibre27">F7</td>

        <td class="calibre28">118</td>
      </tr>

      <tr class="calibre24">
        <td class="calibre27">F8</td>

        <td class="calibre28">119</td>
      </tr>

      <tr class="calibre26">
        <td class="calibre27">F9</td>

        <td class="calibre28">120</td>
      </tr>

      <tr class="calibre24">
        <td class="calibre27">F10</td>

        <td class="calibre28">121</td>
      </tr>

      <tr class="calibre26">
        <td class="calibre27">F11</td>

        <td class="calibre28">122</td>
      </tr>

      <tr class="calibre24">
        <td class="calibre27">F12</td>

        <td class="calibre28">123</td>
      </tr>

      <tr class="calibre26">
        <td class="calibre27">数字锁（Num Lock）</td>

        <td class="calibre28">144</td>
      </tr>

      <tr class="calibre24">
        <td class="calibre27">滚动锁（Scroll Lock）</td>

        <td class="calibre28">145</td>
      </tr>

      <tr class="calibre26">
        <td class="calibre27">分号（IE/Safari/Chrome中）</td>

        <td class="calibre28">186</td>
      </tr>

      <tr class="calibre24">
        <td class="calibre27">分号（Opera/FF中）</td>

        <td class="calibre28">59</td>
      </tr>

      <tr class="calibre26">
        <td class="calibre27">小于</td>

        <td class="calibre28">188</td>
      </tr>

      <tr class="calibre24">
        <td class="calibre27">大于</td>

        <td class="calibre28">190</td>
      </tr>

      <tr class="calibre26">
        <td class="calibre27">正斜杠</td>

        <td class="calibre28">191</td>
      </tr>

      <tr class="calibre24">
        <td class="calibre27">沉音符（`）</td>

        <td class="calibre28">192</td>
      </tr>

      <tr class="calibre26">
        <td class="calibre27">等于</td>

        <td class="calibre28">61</td>
      </tr>

      <tr class="calibre24">
        <td class="calibre27">左方括号</td>

        <td class="calibre28">219</td>
      </tr>

      <tr class="calibre26">
        <td class="calibre27">反斜杠（\）</td>

        <td class="calibre28">220</td>
      </tr>

      <tr class="calibre24">
        <td class="calibre27">右方括号</td>

        <td class="calibre28">221</td>
      </tr>

      <tr class="calibre26">
        <td class="calibre27">单引号</td>

        <td class="calibre28">222</td>
      </tr>
    </tbody>
  </table>

  <p class="calibre2">无论<code class="calibre15">keydown</code>或<code class="calibre15">keyup</code>事件都会存在的一些特殊情况。在Firefox和Opera中，按分号键时<code class="calibre15">keyCode</code>值为59，也就是ASCII中分号的编码；但IE和Safari返回186，即键盘中按键的键码。</p>

  <p class="calibre2">2. <strong class="calibre3">字符编码</strong></p>

  <p class="calibre2">发生<code class="calibre15">keypress</code>事件意味着按下的键会影响到屏幕中文本的显示。在所有浏览器中，按下能够插入或删除字符的键都会触发<code class="calibre15">keypress</code>事件；按下其他键能否触发此事件因浏览器而异。由于截止到2008年，尚无浏览器实现“DOM3级事件”规范，所以浏览器之间的键盘事件并没有多大的差异。</p>

  <p class="calibre2">IE9、Firefox、Chrome和Safari的<code class="calibre15">event</code>对象都支持一个<code class="calibre15">charCode</code>属性，这个属性只有在发生<code class="calibre15">keypress</code>事件时才包含值，而且这个值是按下的那个键所代表字符的ASCII编码。此时的<code class="calibre15">keyCode</code>通常等于0或者也可能等于所按键的键码。IE8及之前版本和Opera则是在<code class="calibre15">keyCode</code>中保存字符的ASCII编码。要想以跨浏览器的方式取得字符编码，必须首先检测<code class="calibre15">charCode</code>属性是否可用，如果不可用则使用<code class="calibre15">keyCode</code>，如下面的例子所示。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18">var EventUtil = {

    //省略的代码

    <b class="calibre3">getCharCode: function(event){</b>
        <b class="calibre3">if (typeof event.charCode == "number"){</b>
            <b class="calibre3">return event.charCode;</b>
        <b class="calibre3">} else {</b>
            <b class="calibre3">return event.keyCode;</b>
        <b class="calibre3">}</b>
    <b class="calibre3">},</b>

    //省略的代码

};
</pre>

  <p class="calibre8"><i class="calibre7">EventUtil.js</i></p>

  <p class="calibre2">这个方法首先检测<code class="calibre15">charCode</code>属性是否包含数值（在不支持这个属性的浏览器中，值为undefined），如果是，则返回该值。否则，就返回<code class="calibre15">keyCode</code>属性值。下面是使用这个方法的示例。</p>
  <pre class="calibre18">var textbox = document.getElementById("myText");
EventUtil.addHandler(textbox, "keypress", function(event){
    event = EventUtil.getEvent(event);
    <b class="calibre3">alert(EventUtil.getCharCode(event));</b>
});
</pre>

  <p class="calibre8"><i class="calibre7">KeyPressEventExample01.htm</i></p>

  <p class="calibre2">在取得了字符编码之后，就可以使用<code class="calibre15">String.fromCharCode()</code>将其转换成实际的字符。</p>

  <p class="calibre2">3. <strong class="calibre3">DOM3级变化</strong></p>

  <p class="calibre2">尽管所有浏览器都实现了某种形式的键盘事件，DOM3级事件还是做出了一些改变。比如，DOM3级事件中的键盘事件，不再包含<code class="calibre15">charCode</code>属性，而是包含两个新属性：<code class="calibre15">key</code>和<code class="calibre15">char</code>。</p>

  <p class="calibre2">其中，<code class="calibre15">key</code>属性是为了取代<code class="calibre15">keyCode</code>而新增的，它的值是一个字符串。在按下某个字符键时，<code class="calibre15">key</code>的值就是相应的文本字符（如“k”或“M”）；在按下非字符键时，<code class="calibre15">key</code>的值是相应键的名（如“Shift”或“Down”）。而<code class="calibre15">char</code>属性在按下字符键时的行为与<code class="calibre15">key</code>相同，但在按下非字符键时值为<code class="calibre15">null</code>。</p>

  <p class="calibre2">IE9支持<code class="calibre15">key</code>属性，但不支持<code class="calibre15">char</code>属性。Safari 5和Chrome支持名为<code class="calibre15">keyIdentifier</code>的属性，在按下非字符键（例如Shift）的情况下与<code class="calibre15">key</code>的值相同。对于字符键，<code class="calibre15">keyIdentifier</code>返回一个格式类似“U+0000”的字符串，表示<code class="calibre15">Unicode</code>值。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18">var textbox = document.getElementById("myText");
EventUtil.addHandler(textbox, "keypress", function(event){
    event = EventUtil.getEvent(event);
    <b class="calibre3">var identifier = event.key || event.keyIdentifier;</b>
    <b class="calibre3">if (identifier){</b>
        <b class="calibre3">alert(identifi er);</b>
    <b class="calibre3">}</b>
});
</pre>

  <p class="calibre8"><i class="calibre7">DOMLevel3KeyPropertyExample01.htm</i></p>

  <p class="calibre2">由于存在跨浏览器问题，因此本书不推荐使用<code class="calibre15">key</code>、<code class="calibre15">keyIdentifier</code>或<code class="calibre15">char</code>。</p>

  <p class="calibre2">DOM3级事件还添加了一个名为<code class="calibre15">location</code>的属性，这是一个数值，表示按下了什么位置上的键：0表示默认键盘，1表示左侧位置（例如左位的Alt键），2表示右侧位置（例如右侧的Shift键），3表示数字小键盘，4表示移动设备键盘（也就是虚拟键盘），5表示手柄（如任天堂Wii控制器）。IE9支持这个属性。Safari和Chrome支持名为<code class="calibre15">keyLocation</code>的等价属性，但即有bug——值始终是0，除非按下了数字键盘（此时，值 为3）；否则，不会是1、2、4、5。</p>
  <pre class="calibre18">var textbox = document.getElementById("myText");
EventUtil.addHandler(textbox, "keypress", function(event){
    event = EventUtil.getEvent(event);
    <b class="calibre3">var loc = event.location || event.keyLocation;</b>
    <b class="calibre3">if (loc){</b>
        <b class="calibre3">alert(loc);</b>
    <b class="calibre3">}</b>
});
</pre>

  <p class="calibre8"><i class="calibre7">DOMLevel3LocationPropertyExample01.htm</i></p>

  <p class="calibre2">与<code class="calibre15">key</code>属性一样，支持<code class="calibre15">location</code>的浏览器也不多，所以在跨浏览器开发中不推荐使用。</p>

  <p class="calibre2">最后是给<code class="calibre15">event</code>对象添加了<code class="calibre15">getModifierState()</code>方法。这个方法接收一个参数，即等于<code class="calibre15">Shift</code>、<code class="calibre15">Control</code>、<code class="calibre15">AltGraph</code>或<code class="calibre15">Meta</code>的字符串，表示要检测的修改键。如果指定的修改键是活动的（也就是处于被按下的状态），这个方法返回<code class="calibre15">true</code>，否则返回<code class="calibre15">false</code>。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18">var textbox = document.getElementById("myText");
EventUtil.addHandler(textbox, "keypress", function(event){
    event = EventUtil.getEvent(event);
    <b class="calibre3">if (event.getModifierState){</b>
        <b class="calibre3">alert(event.getModifierState("Shift"));</b>
    <b class="calibre3">}</b>
});
</pre>

  <p class="calibre8"><i class="calibre7">DOMLevel3LocationGetModifierStateExample01.htm</i></p>

  <p class="calibre2">实际上，通过<code class="calibre15">event</code>对象的<code class="calibre15">shiftKey</code>、<code class="calibre15">altKey</code>、<code class="calibre15">ctrlKey</code>和<code class="calibre15">metaKey</code>属性已经可以取得类似的属性了。IE9是唯一支持<code class="calibre15">getModifierState()</code>方法的浏览器。</p>

  <p class="calibre2">4. <strong class="calibre3"><code class="calibre15">textInput</code>事件</strong></p>

  <p class="calibre2">“DOM3级事件”规范中引入了一个新事件，名叫<code class="calibre15">textInput</code>。根据规范，当用户在可编辑区域中输入字符时，就会触发这个事件。这个用于替代<code class="calibre15">keypress</code>的<code class="calibre15">textInput</code>事件的行为稍有不同。区别之一就是任何可以获得焦点的元素都可以触发<code class="calibre15">keypress</code>事件，但只有可编辑区域才能触发<code class="calibre15">textInput</code>事件。区别之二是<code class="calibre15">textInput</code>事件只会在用户按下能够输入实际字符的键时才会被触发，而<code class="calibre15">keypress</code>事件则在按下那些能够影响文本显示的键时也会触发（例如退格键）。</p>

  <p class="calibre2">由于<code class="calibre15">textInput</code>事件主要考虑的是字符，因此它的<code class="calibre15">event</code>对象中还包含一个<code class="calibre15">data</code>属性，这个属性的值就是用户输入的字符（而非字符编码）。换句话说，用户在没有按上档键的情况下按下了S键，<code class="calibre15">data</code>的值就是<code class="calibre15">"s"</code>，而如果在按住上档键时按下该键，<code class="calibre15">data</code>的值就是<code class="calibre15">"S"</code>。</p>

  <p class="calibre2">以下是一个使用<code class="calibre15">textInput</code>事件的例子：</p>
  <pre class="calibre18">var textbox = document.getElementById("myText");
<b class="calibre3">EventUtil.addHandler(textbox, "textInput", function(event){</b>
    <b class="calibre3">event = EventUtil.getEvent(event);</b>
    <b class="calibre3">alert(event.data);</b>
<b class="calibre3">});</b>
</pre>

  <p class="calibre8"><i class="calibre7">TextInputEventExample01.htm</i></p>

  <p class="calibre2">在这个例子中，插入到文本框中的字符会通过一个警告框显示出来。</p>

  <p class="calibre2">另外，<code class="calibre15">event</code>对象上还有一个属性，叫<code class="calibre15">inputMethod</code>，表示把文本输入到文本框中的方式。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2">0，表示浏览器不确定是怎么输入的。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2">1，表示是使用键盘输入的。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2">2，表示文本是粘贴进来的。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2">3，表示文本是拖放进来的。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2">4，表示文本是使用IME输入的。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2">5，表示文本是通过在表单中选择某一项输入的。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2">6，表示文本是通过手写输入的（比如使用手写笔）。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2">7，表示文本是通过语音输入的。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2">8，表示文本是通过几种方法组合输入的。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2">9，表示文本是通过脚本输入的。</p>
    </li>
  </ul>

  <p class="calibre2">使用这个属性可以确定文本是如何输入到控件中的，从而可以验证其有效性。支持<code class="calibre15">textInput</code>属性的浏览器有IE9+、Safari和Chrome。只有IE支持<code class="calibre15">inputMethod</code>属性。</p>

  <p class="calibre2">5. <strong class="calibre3">设备中的键盘事件</strong></p>

  <p class="calibre2">任天堂Wii会在用户按下Wii遥控器上的按键时触发键盘事件。尽管没有办法访问Wii遥控器中的所有按键，但还是有一些键可以触发键盘事件。图13-6展示了一些键的键码，通过这些键码可以知道用户按下了哪个键。</p>

  <p class="p-img"><img alt="" class="calibre21" src="../Images/00046.gif" /></p>

  <p class="calibre2"><strong class="calibre3">图　13-8</strong></p>

  <p class="calibre2">当用户按下十字键盘（键码为175～178）、减号（170）、加号（174）、1（172）或2（173）键时就会触发键盘事件。但没有办法得知用户是否按下了电源开关、A、B或主页键。</p>

  <p class="calibre2">iOS版Safari和Android版WebKit在使用屏幕键盘时会触发键盘事件。</p>

  <h3 class="calibre22" id="nav_point_100">13.4.5　复合事件</h3>

  <p class="calibre2">复合事件（composition event）是DOM3级事件中新添加的一类事件，用于处理IME 的输入序列。IME（Input Method Editor，输入法编辑器）可以让用户输入在物理键盘上找不到的字符。例如，使用拉丁文键盘的用户通过IME照样能输入日文字符。IME通常需要同时按住多个键，但最终只输入一个字符。复合事件就是针对检测和处理这种输入而设计的。有以下三种复合事件。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">compositionstart</code>：在IME的文本复合系统打开时触发，表示要开始输入了。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">compositionupdate</code>：在向输入字段中插入新字符时触发。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">compositionend</code>：在IME的文本复合系统关闭时触发，表示返回正常键盘输入状态。</p>
    </li>
  </ul>

  <p class="calibre2">复合事件与文本事件在很多方面都很相似。在触发复合事件时，目标是接收文本的输入字段。但它比文本事件的事件对象多一个属性<code class="calibre15">data</code>，其中包含以下几个值中的一个：</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2">如果在<code class="calibre15">compositionstart</code>事件发生时访问，包含正在编辑的文本（例如，已经选中的需要马上替换的文本）；</p>
    </li>

    <li class="calibre12">
      <p class="calibre2">如果在<code class="calibre15">compositionupdate</code>事件发生时访问，包含正插入的新字符；</p>
    </li>

    <li class="calibre12">
      <p class="calibre2">如果在<code class="calibre15">compositionend</code>事件发生时访问，包含此次输入会话中插入的所有字符。</p>
    </li>
  </ul>

  <p class="calibre2">与文本事件一样，必要时可以利用复合事件来筛选输入。可以像下面这样使用它们：</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18">var textbox = document.getElementById("myText");
<b class="calibre3">EventUtil.addHandler(textbox, "compositionstart", function(event){</b>
    <b class="calibre3">event = EventUtil.getEvent(event);</b>
    <b class="calibre3">alert(event.data);</b>
<b class="calibre3">});</b>

<b class="calibre3">EventUtil.addHandler(textbox, "compositionupdate", function(event){</b>
    <b class="calibre3">event = EventUtil.getEvent(event);</b>
    <b class="calibre3">alert(event.data);</b>
<b class="calibre3">});</b>

<b class="calibre3">EventUtil.addHandler(textbox, "compositionend", function(event){</b>
    <b class="calibre3">event = EventUtil.getEvent(event);</b>
    <b class="calibre3">alert(event.data);</b>
<b class="calibre3">});</b>
</pre>

  <p class="calibre8"><i class="calibre7">CompositionEventsExample01.htm</i></p>

  <p class="calibre2">IE9+是到2011年唯一支持复合事件的浏览器。由于缺少支持，对于需要开发跨浏览器应用的开发人员，它的用处不大。要确定浏览器是否支持复合事件，可以使用以下代码：</p>
  <pre class="calibre18"><code class="calibre15">var isSupported = document.implementation.hasFeature("CompositionEvent", "3.0"); 
</code></pre>

  <h3 class="calibre22" id="nav_point_101">13.4.6　变动事件</h3>

  <p class="calibre2">DOM2级的变动（mutation）事件能在DOM中的某一部分发生变化时给出提示。变动事件是为XML或HTML DOM设计的，并不特定于某种语言。DOM2级定义了如下变动事件。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">DOMSubtreeModified</code>：在DOM结构中发生任何变化时触发。这个事件在其他任何事件触发后都会触发。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">DOMNodeInserted</code>：在一个节点作为子节点被插入到另一个节点中时触发。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">DOMNodeRemoved</code>：在节点从其父节点中被移除时触发。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">DOMNodeInsertedIntoDocument</code>：在一个节点被直接插入文档或通过子树间接插入文档之后触发。这个事件在DOMNodeInserted之后触发。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">DOMNodeRemovedFromDocument</code>：在一个节点被直接从文档中移除或通过子树间接从文档中移除之前触发。这个事件在<code class="calibre15">DOMNodeRemoved</code>之后触发。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">DOMAttrModified</code>：在特性被修改之后触发。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">DOMCharacterDataModified</code>：在文本节点的值发生变化时触发。</p>
    </li>
  </ul>

  <p class="calibre2">使用下列代码可以检测出浏览器是否支持变动事件：</p>
  <pre class="calibre18"><code class="calibre15">var isSupported = document.implementation.hasFeature("MutationEvents", "2.0");
</code></pre>

  <p class="calibre2">IE8及更早版本不支持任何变动事件。下表列出了不同浏览器对不同变动事件的支持情况。</p>

  <table class="table">
    <tbody class="calibre23">
      <tr class="calibre24">
        <th class="calibre25" width="25%">事　　件</th>

        <th class="calibre25" width="18.75%">Opera 9+</th>

        <th class="calibre25" width="18.75%">Firefox 3+</th>

        <th class="calibre25" width="18.75%">Safari 3+及Chrome</th>

        <th class="calibre25" width="18.75%">IE9+</th>
      </tr>

      <tr class="calibre26">
        <td class="calibre27"><code class="calibre31">DOMSubtreeModified</code></td>

        <td class="calibre28">－</td>

        <td class="calibre28">支持</td>

        <td class="calibre28">支持</td>

        <td class="calibre28">支持</td>
      </tr>

      <tr class="calibre24">
        <td class="calibre27"><code class="calibre31">DOMNodeInserted</code></td>

        <td class="calibre28">支持</td>

        <td class="calibre28">支持</td>

        <td class="calibre28">支持</td>

        <td class="calibre28">支持</td>
      </tr>

      <tr class="calibre26">
        <td class="calibre27"><code class="calibre31">DOMNodeRemoved</code></td>

        <td class="calibre28">支持</td>

        <td class="calibre28">支持</td>

        <td class="calibre28">支持</td>

        <td class="calibre28">支持</td>
      </tr>
    </tbody>
  </table>

  <p class="calibre2">由于DOM3级事件模块作废了很多变动事件，所以本节只介绍那些将来仍然会得到支持的事件。</p>

  <p class="calibre2">1. <strong class="calibre3">删除节点</strong></p>

  <p class="calibre2">在使用<code class="calibre15">removeChild()</code>或<code class="calibre15">replaceChild()</code>从DOM中删除节点时，首先会触发<code class="calibre15">DOMNodeRemoved</code>事件。这个事件的目标（<code class="calibre15">event.target</code>）是被删除的节点，而<code class="calibre15">event.relatedNode</code>属性中包含着对目标节点父节点的引用。在这个事件触发时，节点尚未从其父节点删除，因此其<code class="calibre15">parentNode</code>属性仍然指向父节点（与<code class="calibre15">event.relatedNode</code>相同）。这个事件会冒泡，因而可以在DOM的任何层次上面处理它。</p>

  <p class="calibre2">如果被移除的节点包含子节点，那么在其所有子节点以及这个被移除的节点上会相继触发<code class="calibre15">DOMNodeRemovedFromDocument</code>事件。但这个事件不会冒泡，所以只有直接指定给其中一个子节点的事件处理程序才会被调用。这个事件的目标是相应的子节点或者那个被移除的节点，除此之外<code class="calibre15">event</code>对象中不包含其他信息。</p>

  <p class="calibre2">紧随其后触发的是<code class="calibre15">DOMSubtreeModified</code>事件。这个事件的目标是被移除节点的父节点；此时的<code class="calibre15">event</code>对象也不会提供与事件相关的其他信息。</p>

  <p class="calibre2">为了理解上述事件的触发过程，下面我们就以一个简单的HTML页面为例。</p>
  <pre class="calibre18"><code class="calibre15">&lt;! DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Node Removal Events Example&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;ul id="myList"&gt;
        &lt;li&gt;Item 1&lt;/li&gt;
        &lt;li&gt;Item 2&lt;/li&gt;
        &lt;li&gt;Item 3&lt;/li&gt;
    &lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

  <p class="calibre2">在这个例子中，我们假设要移除<code class="calibre15">&lt;ul&gt;</code>元素。此时，就会依次触发以下事件。</p>

  <ol class="calibre11">
    <li class="calibre12" value="1">
      <p class="calibre2">在<code class="calibre15">&lt;ul&gt;</code>元素上触发<code class="calibre15">DOMNodeRemoved</code>事件。<code class="calibre15">relatedNode</code>属性等于<code class="calibre15">document.body</code>。</p>
    </li>

    <li class="calibre12" value="2">
      <p class="calibre2">在<code class="calibre15">&lt;ul&gt;</code>元素上触发<code class="calibre15">DOMNodeRemovedFromDocument</code>事件。</p>
    </li>

    <li class="calibre12" value="3">
      <p class="calibre2">在身为<code class="calibre15">&lt;ul&gt;</code>元素子节点的每个<code class="calibre15">&lt;li&gt;</code>元素及文本节点上触发<code class="calibre15">DOMNodeRemovedFromDocument</code>事件。</p>
    </li>

    <li class="calibre12" value="4">
      <p class="calibre2">在<code class="calibre15">document.body</code>上触发<code class="calibre15">DOMSubtreeModified</code>事件，因为<code class="calibre15">&lt;ul&gt;</code>元素是<code class="calibre15">document.body</code>的直接子元素。</p>
    </li>
  </ol>

  <p class="calibre2">运行下列代码可以验证以上事件发生的顺序。</p>
  <pre class="calibre18"><code class="calibre15">EventUtil.addHandler(window, "load", function(event){
    var list = document.getElementById("myList");

    EventUtil.addHandler(document, "DOMSubtreeModified", function(event){
        alert(event.type);
        alert(event.target);
    });
    EventUtil.addHandler(document, "DOMNodeRemoved", function(event){
        alert(event.type);
        alert(event.target);
        alert(event.relatedNode);
    });
    EventUtil.addHandler(list.firstChild, "DOMNodeRemovedFromDocument", function(event){
        alert(event.type);
        alert(event.target);
    });            

    list.parentNode.removeChild(list);
});
</code></pre>

  <p class="calibre2">以上代码为<code class="calibre15">document</code>添加了针对<code class="calibre15">DOMSubtreeModified</code>和<code class="calibre15">DOMNodeRemoved</code>事件的处理程序，以便在页面上处理这些事件。由于<code class="calibre15">DOMNodeRemovedFromDocument</code>不会冒泡，所以我们将针对它的事件处理程序直接添加给了<code class="calibre15">&lt;ul&gt;</code>元素的第一个子节点（在兼容DOM的浏览器中是一个文本节点）。在设置了以上事件处理程序后，代码从文档中移除了<code class="calibre15">&lt;ul&gt;</code>元素。</p>

  <p class="calibre2">2. <strong class="calibre3">插入节点</strong></p>

  <p class="calibre2">在使用<code class="calibre15">appendChild()</code>、<code class="calibre15">replaceChild()</code>或<code class="calibre15">insertBefore()</code>向DOM中插入节点时，首先会触发<code class="calibre15">DOMNodeInserted</code>事件。这个事件的目标是被插入的节点，而<code class="calibre15">event.relatedNode</code>属性中包含一个对父节点的引用。在这个事件触发时，节点已经被插入到了新的父节点中。这个事件是冒泡的，因此可以在DOM的各个层次上处理它。</p>

  <p class="calibre2">紧接着，会在新插入的节点上面触发<code class="calibre15">DOMNodeInsertedIntoDocument</code>事件。这个事件不冒泡，因此必须在插入节点之前为它添加这个事件处理程序。这个事件的目标是被插入的节点，除此之外<code class="calibre15">event</code>对象中不包含其他信息。</p>

  <p class="calibre2">最后一个触发的事件是<code class="calibre15">DOMSubtreeModified</code>，触发于新插入节点的父节点。</p>

  <p class="calibre2">我们仍以前面的HTML文档为例，可以通过下列JavaScript代码来验证上述事件的触发顺序。</p>
  <pre class="calibre18"><code class="calibre15">EventUtil.addHandler(window, "load", function(event){
    var list = document.getElementById("myList");
    var item = document.createElement("li");
    item.appendChild(document.createTextNode("Item 4"));

    EventUtil.addHandler(document, "DOMSubtreeModified", function(event){
        alert(event.type);
        alert(event.target);
    });
    EventUtil.addHandler(document, "DOMNodeInserted", function(event){
        alert(event.type);
        alert(event.target);
        alert(event.relatedNode);
    });
    EventUtil.addHandler(item, "DOMNodeInsertedIntoDocument", function(event){
        alert(event.type);
        alert(event.target);
    });            

    list.appendChild(item);
});
</code></pre>

  <p class="calibre2">以上代码首先创建了一个包含文本<code class="calibre15">"Item 4"</code>的新<code class="calibre15">&lt;li&gt;</code>元素。由于<code class="calibre15">DOMSubtreeModified</code>和<code class="calibre15">DOMNodeInserted</code>事件是冒泡的，所以把它们的事件处理程序添加到了文档中。在将列表项插入到其父节点之前，先将<code class="calibre15">DOMNodeInsertedIntoDocument</code>事件的事件处理程序添加给它。最后一步就是使用<code class="calibre15">appendChild()</code>来添加这个列表项；此时，事件开始依次被触发。首先是在新<code class="calibre15">&lt;li&gt;</code>元素项上触发<code class="calibre15">DOMNodeInserted</code>事件，其<code class="calibre15">relatedNode</code>是<code class="calibre15">&lt;ul&gt;</code>元素。然后是触发新<code class="calibre15">&lt;li&gt;</code>元素上的<code class="calibre15">DOMNodeInsertedIntoDocument</code>事件，最后触发的是<code class="calibre15">&lt;ul&gt;</code>元素上的<code class="calibre15">DOMSubtreeModified</code>事件。</p>

  <h3 class="calibre22" id="nav_point_102">13.4.7　HTML5事件</h3>

  <p class="calibre2">DOM规范没有涵盖所有浏览器支持的所有事件。很多浏览器出于不同的目的——满足用户需求或解决特殊问题，还实现了一些自定义的事件。HTML5详尽列出了浏览器应该支持的所有事件。本节只讨论其中得到浏览器完善支持的事件，但并非全部事件。（其他事件会在本书其他章节讨论。）</p>

  <p class="calibre2">1. <strong class="calibre3"><code class="calibre15">contextmenu</code>事件</strong></p>

  <p class="calibre2">Windows 95在PC中引入了上下文菜单的概念，即通过单击鼠标右键可以调出上下文菜单。不久，这个概念也被引入了Web领域。为了实现上下文菜单，开发人员面临的主要问题是如何确定应该显示上下文菜单（在Windows中，是右键单击；在Mac中，是Ctrl+单击），以及如何屏蔽与该操作关联的默认上下文菜单。为解决这个问题，就出现了<code class="calibre15">contextmenu</code>这个事件，用以表示何时应该显示上下文菜单，以便开发人员取消默认的上下文菜单而提供自定义的菜单。</p>

  <p class="calibre2">由于<code class="calibre15">contextmenu</code>事件是冒泡的，因此可以为<code class="calibre15">document</code>指定一个事件处理程序，用以处理页面中发生的所有此类事件。这个事件的目标是发生用户操作的元素。在所有浏览器中都可以取消这个事件：在兼容DOM的浏览器中，使用<code class="calibre15">event.preventDefalut()</code>；在IE中，将<code class="calibre15">event.returnValue</code>的值设置为<code class="calibre15">false</code>。因为<code class="calibre15">contextmenu</code>事件属于鼠标事件，所以其事件对象中包含与光标位置有关的所有属性。通常使用<code class="calibre15">contextmenu</code>事件来显示自定义的上下文菜单，而使用<code class="calibre15">onclick</code>事件处理程序来隐藏该菜单。以下面的HTML页面为例。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt; 
    &lt;title&gt;ContextMenu Event Example&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="myDiv"&gt;Right click or Ctrl+click me to get a custom context menu.
        Click anywhere else to get the default context menu.&lt;/div&gt;
    &lt;ul id="myMenu" style="position:absolute;visibility:hidden;background-color:
        silver"&gt;
        &lt;li&gt;&lt;a href="http://www.nczonline.net"&gt;Nicholas’ site&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href="http://www.wrox.com"&gt;Wrox site&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href="http://www.yahoo.com"&gt;Yahoo!&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

  <p class="calibre8"><i class="calibre7">ContextMenuEventExample01.htm</i></p>

  <p class="calibre2">这里的<code class="calibre15">&lt;div&gt;</code>元素包含一个自定义的上下文菜单。其中，<code class="calibre15">&lt;ul&gt;</code>元素作为自定义上下文菜单，并且在初始时是隐藏的。实现这个例子的JavaScript代码如下所示。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">EventUtil.addHandler(window, "load", function(event){
    var div = document.getElementById("myDiv");

    EventUtil.addHandler(div, "contextmenu", function(event){
        event = EventUtil.getEvent(event);
        EventUtil.preventDefault(event);

        var menu = document.getElementById("myMenu");
        menu.style.left = event.clientX + "px";
        menu.style.top = event.clientY + "px";
        menu.style.visibility = "visible";
    });

    EventUtil.addHandler(document, "click", function(event){
        document.getElementById("myMenu").style.visibility = "hidden";
    });
});
</code></pre>

  <p class="calibre8"><i class="calibre7">ContextMenuEventExample01.htm</i></p>

  <p class="calibre2">在这个例子中，我们为<code class="calibre15">&lt;div&gt;</code>元素添加了<code class="calibre15">oncontextmenu</code>事件的处理程序。这个事件处理程序首先会取消默认行为，以保证不显示浏览器默认的上下文菜单。然后，再根据<code class="calibre15">event</code>对象<code class="calibre15">clientX</code>和<code class="calibre15">clientY</code>属性的值，来确定放置<code class="calibre15">&lt;ul&gt;</code>元素的位置。最后一步就是通过将<code class="calibre15">visibility</code>属性设置为<code class="calibre15">"visible"</code>来显示自定义上下文菜单。另外，还为<code class="calibre15">document</code>添加了一个<code class="calibre15">onclick</code>事件处理程序，以便用户能够通过鼠标单击来隐藏菜单（单击也是隐藏系统上下文菜单的默认操作）。</p>

  <p class="calibre2">虽然这个例子很简单，但它却展示了Web上所有自定义上下文菜单的基本结构。只需为这个例子中的上下文菜单添加一些CSS样式，就可以得到非常棒的效果。</p>

  <p class="calibre2">支持<code class="calibre15">contextmenu</code>事件的浏览器有IE、Firefox、Safari、Chrome和Opera 11+。</p>

  <p class="calibre2">2.<strong class="calibre3"><code class="calibre15">beforeunload</code>事件</strong></p>

  <p class="calibre2">之所以有发生在<code class="calibre15">window</code>对象上的<code class="calibre15">beforeunload</code>事件，是为了让开发人员有可能在页面卸载前阻止这一操作。这个事件会在浏览器卸载页面之前触发，可以通过它来取消卸载并继续使用原有页面。但是，不能彻底取消这个事件，因为那就相当于让用户无法离开当前页面了。为此，这个事件的意图是将控制权交给用户。显示的消息会告知用户页面行将被卸载（正因为如此才会显示这个消息），询问用户是否真的要关闭页面，还是希望继续留下来（见图13-9）。</p>

  <p class="p-img"><img alt="" class="calibre42" src="../Images/00047.gif" /></p>

  <p class="calibre2"><strong class="calibre3">图　13-9</strong></p>

  <p class="calibre2">为了显示这个弹出对话框，必须将<code class="calibre15">event.returnValue</code>的值设置为要显示给用户的字符串（对IE及Fiefox而言），同时作为函数的值返回（对Safari和Chrome而言），如下面的例子所示。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">EventUtil.addHandler(window, "beforeunload", function(event){
    event = EventUtil.getEvent(event);
    var message = "I'm really going to miss you if you go.";
    event.returnValue = message;
    return message;
}); 
</code></pre>

  <p class="calibre8"><i class="calibre7">BeforeUnloadEventExample01.htm</i></p>

  <p class="calibre2">IE和Firefox、Safari和Chrome都支持<code class="calibre15">beforeunload</code>事件，也都会弹出这个对话框询问用户是否真想离开。Opera 11及之前的版本不支持<code class="calibre15">beforeunload</code>事件。</p>

  <p class="calibre2">3. <strong class="calibre3"><code class="calibre15">DOMContentLoaded</code>事件</strong></p>

  <p class="calibre2">如前所述，<code class="calibre15">window</code>的<code class="calibre15">load</code>事件会在页面中的一切都加载完毕时触发，但这个过程可能会因为要加载的外部资源过多而颇费周折。而<code class="calibre15">DOMContentLoaded</code>事件则在形成完整的DOM树之后就会触发，不理会图像、JavaScript文件、CSS文件或其他资源是否已经下载完毕。与<code class="calibre15">load</code>事件不同，<code class="calibre15">DOMContentLoaded</code>支持在页面下载的早期添加事件处理程序，这也就意味着用户能够尽早地与页面进行交互。</p>

  <p class="calibre2">要处理<code class="calibre15">DOMContentLoaded</code>事件，可以为<code class="calibre15">document</code>或<code class="calibre15">window</code>添加相应的事件处理程序（尽管这个事件会冒泡到<code class="calibre15">window</code>，但它的目标实际上是<code class="calibre15">document</code>）。来看下面的例子。</p>
  <pre class="calibre18"><code class="calibre15">EventUtil.addHandler(document, "DOMContentLoaded", function(event){
    alert("Content loaded");
}); 
</code></pre>

  <p class="calibre8"><i class="calibre7">DOMContentLoadedEventExample01.htm</i></p>

  <p class="calibre2"><code class="calibre15">DOMContentLoaded</code>事件对象不会提供任何额外的信息（其<code class="calibre15">target</code>属性是<code class="calibre15">document</code>）。</p>

  <p class="calibre2">IE9+、Firefox、Chrome、Safari 3.1+和Opera 9+都支持<code class="calibre15">DOMContentLoaded</code>事件，通常这个事件既可以添加事件处理程序，也可以执行其他DOM操作。这个事件始终都会在<code class="calibre15">load</code>事件之前触发。</p>

  <p class="calibre2">对于不支持<code class="calibre15">DOMContentLoaded</code>的浏览器，我们建议在页面加载期间设置一个时间为0毫秒的超时调用，如下面的例子所示。</p>
  <pre class="calibre18"><code class="calibre15">setTimeout(function(){
    //在此添加事件处理程序
}, 0);
</code></pre>

  <p class="calibre2">这段代码的实际意思就是：“在当前JavaScript处理完成后立即运行这个函数。”在页面下载和构建期间，只有一个JavaScript处理过程，因此超时调用会在该过程结束时立即触发。至于这个时间与<code class="calibre15">DOMContentLoaded</code>被触发的时间能否同步，主要还是取决于用户使用的浏览器和页面中的其他代码。为了确保这个方法有效，必须将其作为页面中的第一个超时调用；即便如此，也还是无法保证在所有环境中该超时调用一定会早于<code class="calibre15">load</code>事件被触发。</p>

  <p class="calibre2">4. <strong class="calibre3"><code class="calibre15">readystatechange</code>事件</strong></p>

  <p class="calibre2">IE为DOM文档中的某些部分提供了<code class="calibre15">readystatechange</code>事件。这个事件的目的是提供与文档或元素的加载状态有关的信息，但这个事件的行为有时候也很难预料。支持<code class="calibre15">readystatechange</code>事件的每个对象都有一个<code class="calibre15">readyState</code>属性，可能包含下列5个值中的一个。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">uninitialized</code>（未初始化）：对象存在但尚未初始化。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">loading</code>（正在加载）：对象正在加载数据。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">loaded</code>（加载完毕）：对象加载数据完成。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">interactive</code>（交互）：可以操作对象了，但还没有完全加载。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">complete</code>（完成）：对象已经加载完毕。</p>
    </li>
  </ul>

  <p class="calibre2">这些状态看起来很直观，但并非所有对象都会经历<code class="calibre15">readyState</code>的这几个阶段。换句话说，如果某个阶段不适用某个对象，则该对象完全可能跳过该阶段；并没有规定哪个阶段适用于哪个对象。显然，这意味着<code class="calibre15">readystatechange</code>事件经常会少于4次，而<code class="calibre15">readyState</code>属性的值也不总是连续的。</p>

  <p class="calibre2">对于<code class="calibre15">document</code>而言，值为<code class="calibre15">"interactive"</code>的<code class="calibre15">readyState</code>会在与<code class="calibre15">DOMContentLoaded</code>大致相同的时刻触发<code class="calibre15">readystatechange</code>事件。此时，DOM树已经加载完毕，可以安全地操作它了，因此就会进入交互（interactive）阶段。但与此同时，图像及其他外部文件不一定可用。下面来看一段处理<code class="calibre15">readystatechange</code>事件的代码。</p>
  <pre class="calibre18"><code class="calibre15">EventUtil.addHandler(document, "readystatechange", function(event){
    if (document.readyState == "interactive"){
        alert("Content loaded");
    } 
});
</code></pre>

  <p class="calibre2">这个事件的<code class="calibre15">event</code>对象不会提供任何信息，也没有目标对象。</p>

  <p class="calibre2">在与<code class="calibre15">load</code>事件一起使用时，无法预测两个事件触发的先后顺序。在包含较多或较大的外部资源的页面中，会在<code class="calibre15">load</code>事件触发之前先进入交互阶段；而在包含较少或较小的外部资源的页面中，则很难说<code class="calibre15">readystatechange</code>事件会发生在<code class="calibre15">load</code>事件前面。</p>

  <p class="calibre2">让问题变得更复杂的是，交互阶段可能会早于也可能会晚于完成阶段出现，无法确保顺序。在包含较多外部资源的页面中，交互阶段更有可能早于完成阶段出现；而在页面中包含较少外部资源的情况下，完成阶段先于交互阶段出现的可能性更大。因此，为了尽可能抢到先机，有必要同时检测交互和完成阶段，如下面的例子所示。</p>
  <pre class="calibre18"><code class="calibre15">EventUtil.addHandler(document, "readystatechange", function(event){
    if (document.readyState == "interactive" || document.readyState == "complete"){
        EventUtil.removeHandler(document, "readystatechange", arguments.callee);
        alert("Content loaded");
    } 
});
</code></pre>

  <p class="calibre2">对于上面的代码来说，当<code class="calibre15">readystatechange</code>事件触发时，会检测<code class="calibre15">document.readyState</code>的值，看当前是否已经进入交互阶段或完成阶段。如果是，则移除相应的事件处理程序以免在其他阶段再执行。注意，由于事件处理程序使用的是匿名函数，因此这里使用了<code class="calibre15">arguments.callee</code>来引用该函数。然后，会显示一个警告框，说明内容已经加载完毕。这样编写代码可以达到与使用<code class="calibre15">DOMContentLoaded</code>十分相近的效果。</p>

  <p class="calibre2">支持<code class="calibre15">readystatechange</code>事件的浏览器有IE、Firfox 4+和Opera。</p>

  <blockquote class="calibre14">
    <p class="calibre2"><img alt="" class="calibre17" src="../Images/00002.gif" /> 虽然使用<code class="calibre15">readystatechange</code>可以十分近似地模拟<code class="calibre15">DOMContentLoaded</code>事件，但它们本质上还是不同的。在不同页面中，<code class="calibre15">load</code>事件与<code class="calibre15">readystatechange</code>事件并不能保证以相同的顺序触发。</p>
  </blockquote>

  <p class="calibre2">另外，<code class="calibre15">&lt;script&gt;</code>（在IE和Opera中）和<code class="calibre15">&lt;link&gt;</code>（仅IE中）元素也会触发<code class="calibre15">readystatechange</code>事件，可以用来确定外部的JavaScript和CSS文件是否已经加载完成。与在其他浏览器中一样，除非把动态创建的元素添加到页面中，否则浏览器不会开始下载外部资源。基于元素触发的<code class="calibre15">readystatechange</code>事件也存在同样的问题，即<code class="calibre15">readyState</code>属性无论等于<code class="calibre15">"loaded"</code>还是<code class="calibre15">"complete"</code>都可以表示资源已经可用。有时候，<code class="calibre15">readyState</code>会停在<code class="calibre15">"loaded"</code>阶段而永远不会“完成”；有时候，又会跳过<code class="calibre15">"loaded"</code>阶段而直接“完成”。于是，还需要像对待<code class="calibre15">document</code>一样采取相同的编码方式。例如，下面展示了一段加载外部JavaScript文件的代码。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18">EventUtil.addHandler(window, "load", function(){ 
    var script = document.createElement("script");

    <b class="calibre3">EventUtil.addHandler(script, "readystatechange", function(event){</b>
        <b class="calibre3">event = EventUtil.getEvent(event);</b>
        <b class="calibre3">var target = EventUtil.getTarget(event);</b>

        <b class="calibre3">if (target.readyState == "loaded" || target.readyState == "complete"){</b>
            <b class="calibre3">EventUtil.removeHandler(target, "readystatechange", arguments. callee);</b>
            <b class="calibre3">alert("Script Loaded");</b>
        <b class="calibre3">}</b>
    <b class="calibre3">});</b>
    script.src = "example.js";
    document.body.appendChild(script);
});
</pre>

  <p class="calibre8"><i class="calibre7">ReadyStateChangeEventExample01.htm</i></p>

  <p class="calibre2">这个例子为新创建的<code class="calibre15">&lt;script&gt;</code>节点指定了一个事件处理程序。事件的目标是该节点本身，因此当触发<code class="calibre15">readystatechange</code>事件时，要检测目标的<code class="calibre15">readyState</code>属性是不是等于<code class="calibre15">"loaded"</code>或<code class="calibre15">"complete"</code>。如果进入了其中任何一个阶段，则移除事件处理程序（以防止被执行两次），并显示一个警告框。与此同时，就可以执行已经加载完毕的外部文件中的函数了。</p>

  <p class="calibre2">同样的编码方式也适用于通过<code class="calibre15">&lt;link&gt;</code>元素加载CSS文件的情况，如下面的例子所示。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18">EventUtil.addHandler(window, "load", function(){
    var link = document.createElement("link");
    link.type = "text/css";
    link.rel= "stylesheet";

    <b class="calibre3">EventUtil.addHandler(script, "readystatechange", function(event){</b>
        <b class="calibre3">event = EventUtil.getEvent(event);</b>
        <b class="calibre3">var target = EventUtil.getTarget(event);</b>

        <b class="calibre3">if (target.readyState == "loaded" || target.readyState == "complete"){</b>
            <b class="calibre3">EventUtil.removeHandler(target, "readystatechange", arguments. callee);</b>
            <b class="calibre3">alert("CSS Loaded");</b>
        <b class="calibre3">}</b>
    <b class="calibre3">});</b>

    link.href = "example.css";
    document.getElementsByTagName("head")[0].appendChild(link);
});
</pre>

  <p class="calibre8"><i class="calibre7">ReadyStateChangeEventExample02.htm</i></p>

  <p class="calibre2">同样，最重要的是要一并检测<code class="calibre15">readyState</code>的两个状态，并在调用了一次事件处理程序后就将其移除。</p>

  <p class="calibre2">5. <strong class="calibre3"><code class="calibre15">pageshow</code>和<code class="calibre15">pagehide</code>事件</strong></p>

  <p class="calibre2">Firefox和Opera有一个特性，名叫“往返缓存”（back-forward cache，或bfcache），可以在用户使用浏览器的“后退”和“前进”按钮时加快页面的转换速度。这个缓存中不仅保存着页面数据，还保存了DOM和JavaScript的状态；实际上是将整个页面都保存在了内存里。如果页面位于bfcache中，那么再次打开该页面时就不会触发<code class="calibre15">load</code>事件。尽管由于内存中保存了整个页面的状态，不触发<code class="calibre15">load</code>事件也不应该会导致什么问题，但为了更形象地说明bfcache的行为，Firefox还是提供了一些新事件。</p>

  <p class="calibre2">第一个事件就是<code class="calibre15">pageshow</code>，这个事件在页面显示时触发，无论该页面是否来自bfcache。在重新加载的页面中，<code class="calibre15">pageshow</code>会在<code class="calibre15">load</code>事件触发后触发；而对于bfcache中的页面，<code class="calibre15">pageshow</code>会在页面状态完全恢复的那一刻触发。另外要注意的是，虽然这个事件的目标是<code class="calibre15">document</code>，但必须将其事件处理程序添加到<code class="calibre15">window</code>。来看下面的例子。</p>
  <pre class="calibre18"><code class="calibre15">(function(){
    var showCount = 0;

    EventUtil.addHandler(window, "load", function(){
        alert("Load fired");
    }); 

    EventUtil.addHandler(window, "pageshow", function(){
        showCount++;
        alert("Show has been fired " + showCount + " times.");
    });
})();
</code></pre>

  <p class="calibre2">这个例子使用了私有作用域，以防止变量<code class="calibre15">showCount</code>进入全局作用域。当页面首次加载完成时，<code class="calibre15">showCount</code>的值为<code class="calibre15">0</code>。此后，每当触发<code class="calibre15">pageshow</code>事件，<code class="calibre15">showCount</code>的值就会递增并通过警告框显示出来。如果你在离开包含以上代码的页面之后，又单击“后退”按钮返回该页面，就会看到<code class="calibre15">showCount</code>每次递增的值。这是因为该变量的状态，乃至整个页面的状态，都被保存在了内存中，当你返回这个页面时，它们的状态得到了恢复。如果你单击了浏览器的“刷新”按钮，那么<code class="calibre15">showCount</code>的值就会被重置为<code class="calibre15">0</code>，因为页面已经完全重新加载了。</p>

  <p class="calibre2">除了通常的属性之外，<code class="calibre15">pageshow</code>事件的<code class="calibre15">event</code>对象还包含一个名为<code class="calibre15">persisted</code>的布尔值属性。如果页面被保存在了bfcache中，则这个属性的值为<code class="calibre15">true</code>；否则，这个属性的值为<code class="calibre15">false</code>。可以像下面这样在事件处理程序中检测这个属性。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18">(function(){
    var showCount = 0; 

    EventUtil.addHandler(window, "load", function(){
        alert("Load fired");
    });

    EventUtil.addHandler(window, "pageshow", function(event){
        showCount++;
        <b class="calibre3">alert("Show has been fired " + showCount +</b>
              <b class="calibre3">" times. Persisted? " + event.persisted);</b>
    });
})();
</pre>

  <p class="calibre8"><i class="calibre7">PageShowEventExample01.htm</i></p>

  <p class="calibre2">通过检测<code class="calibre15">persisted</code>属性，就可以根据页面在bfcache中的状态来确定是否需要采取其他操作。</p>

  <p class="calibre2">与<code class="calibre15">pageshow</code>事件对应的是<code class="calibre15">pagehide</code>事件，该事件会在浏览器卸载页面的时候触发，而且是在<code class="calibre15">unload</code>事件之前触发。与<code class="calibre15">pageshow</code>事件一样，<code class="calibre15">pagehide</code>在<code class="calibre15">document</code>上面触发，但其事件处理程序必须要添加到<code class="calibre15">window</code>对象。这个事件的<code class="calibre15">event</code>对象也包含<code class="calibre15">persisted</code>属性，不过其用途稍有不同。来看下面的例子。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">EventUtil.addHandler(window, "pagehide", function(event){
    alert("Hiding. Persisted? " + event.persisted);
}); 
</code></pre>

  <p class="calibre8"><i class="calibre7">PageShowEventExample01.htm</i></p>

  <p class="calibre2">有时候，可能需要在<code class="calibre15">pagehide</code>事件触发时根据<code class="calibre15">persisted</code>的值采取不同的操作。对于<code class="calibre15">pageshow</code>事件，如果页面是从bfcache中加载的，那么<code class="calibre15">persisted</code>的值就是<code class="calibre15">true</code>；对于<code class="calibre15">pagehide</code>事件，如果页面在卸载之后会被保存在bfcache中，那么<code class="calibre15">persisted</code>的值也会被设置为<code class="calibre15">true</code>。因此，当第一次触发<code class="calibre15">pageshow</code>时，<code class="calibre15">persisted</code>的值一定是<code class="calibre15">false</code>，而在第一次触发<code class="calibre15">pagehide</code>时，<code class="calibre15">persisted</code>就会变成<code class="calibre15">true</code>（除非页面不会被保存在bfcache中）。</p>

  <p class="calibre2">支持<code class="calibre15">pageshow</code>和<code class="calibre15">pagehide</code>事件的浏览器有Firefox、Safari 5+、Chrome和Opera。IE9及之前版本不支持这两个事件。</p>

  <blockquote class="calibre14">
    <p class="calibre2"><img alt="" class="calibre17" src="../Images/00002.gif" /> 指定了<code class="calibre15">onunload</code>事件处理程序的页面会被自动排除在 bfcache之外，即使事件处理程序是空的。原因在于，<code class="calibre15">onunload</code>最常用于撤销在<strong class="calibre3"><code class="calibre15">onload</code></strong>中所执行的操作，而跳过<strong class="calibre3"><code class="calibre15">onload</code></strong>后再次显示页面很可能就会导致页面不正常。</p>
  </blockquote>

  <p class="calibre2">6. <strong class="calibre3"><code class="calibre15">hashchange</code>事件</strong></p>

  <p class="calibre2">HTML5新增了<code class="calibre15">haschange</code>事件，以便在URL的参数列表（及URL中“#”号后面的所有字符串）发生变化时通知开发人员。之所以新增这个事件，是因为在Ajax应用中，开发人员经常要利用URL参数列来保存状态或导航信息。</p>

  <p class="calibre2">必须要把<code class="calibre15">hashchange</code>事件处理程序添加给<code class="calibre15">window</code>对象，然后URL参数列表只要变化就会调用它。此时的<code class="calibre15">event</code>对象应该额外包含两个属性：<code class="calibre15">oldURL</code>和<code class="calibre15">newURL</code>。这两个属性分别保存着参数列表变化前后的完整URL。例如：</p>
  <pre class="calibre18"><code class="calibre15">EventUtil.addHandler(window, "hashchange", function(event){
    alert("Old URL: " + event.oldURL + "\nNew URL: " + event.newURL);
}); 
</code></pre>

  <p class="calibre8"><i class="calibre7">HashChangeEventExample01.htm</i></p>

  <p class="calibre2">支持<code class="calibre15">haschange</code>事件的浏览器有IE8+、Firefox 3.6+、Safari 5+、Chrome和Opera 10.6+。在这些浏览器中，只有Firefox 6+、Chrome和Opera支持<code class="calibre15">oldURL</code>和<code class="calibre15">newURL</code>属性。为此，最好是使用<code class="calibre15">location</code>对象来确定当前的参数列表。</p>
  <pre class="calibre18">EventUtil.addHandler(window, "hashchange", function(event){
    <b class="calibre3">alert("Current hash: " + location.hash);</b>
});
</pre>

  <p class="calibre2">使用以下代码可以检测浏览器是否支持<code class="calibre15">haschange</code>事件：</p>
  <pre class="calibre18"><code class="calibre15">var isSupported = ("onhashchange" in window); //这里有bug
</code></pre>

  <p class="calibre2">如果IE8是在IE7文档模式下运行，即使功能无效它也会返回<code class="calibre15">true</code>。为解决这个问题，可以使用以下这个更稳妥的检测方式：</p>
  <pre class="calibre18"><code class="calibre15">var isSupported = ("onhashchange" in window) &amp;&amp; (document.documentMode ===
                   undefined || document.documentMode &gt; 7);  
</code></pre>

  <h3 class="calibre22" id="nav_point_103">13.4.8　设备事件</h3>

  <p class="calibre2">智能手机和平板电脑的普及，为用户与浏览器交互引入了一种新的方式，而一类新事件也应运而生。设备事件（device event）可以让开发人员确定用户在怎样使用设备。W3C从2011年开始着手制定一份关于设备事件的新草案（<a class="calibre6" href="http://dev.w3.org/geo/api/spec-source-orientation.html">http://dev.w3.org/geo/api/spec-source-orientation.html</a>），以涵盖不断增长的设备类型并为它们定义相关的事件。本节会同时讨论这份草案中涉及的API和特定于浏览器开发商的事件。</p>

  <p class="calibre2">1. <strong class="calibre3"><code class="calibre15">orientationchange</code>事件</strong></p>

  <p class="calibre2">苹果公司为移动Safari中添加了<code class="calibre15">orientationchange</code>事件，以便开发人员能够确定用户何时将设备由横向查看模式切换为纵向查看模式。移动Safari的<code class="calibre15">window.orientation</code>属性中可能包含3个值：<code class="calibre15">0</code>表示肖像模式，<code class="calibre15">90</code>表示向左旋转的横向模式（“主屏幕”按钮在右侧），-90表示向右旋转的横向模式（“主屏幕”按钮在左侧）。相关文档中还提到一个值，即<code class="calibre15">180</code>表示iPhone头朝下；但这种模式至今尚未得到支持。图13-10展示了<code class="calibre15">window.orientation</code>的每个值的含义。</p>

  <p class="p-img"><img alt="" class="calibre37" src="../Images/00048.gif" /></p>

  <p class="calibre2"><strong class="calibre3">图　13-10</strong></p>

  <p class="calibre2">只要用户改变了设备的查看模式，就会触发<code class="calibre15">orientationchange</code>事件。此时的<code class="calibre15">event</code>对象不包含任何有价值的信息，因为唯一相关的信息可以通过<code class="calibre15">window.orientation</code>访问到。下面是使用这个事件的典型示例。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">EventUtil.addHandler(window, "load", function(event){
    var div = document.getElementById("myDiv");
    div.innerHTML = "Current orientation is " + window.orientation;

    EventUtil.addHandler(window, "orientationchange", function(event){
        div.innerHTML = "Current orientation is " + window.orientation;
    });
});
</code></pre>

  <p class="calibre8"><i class="calibre7">OrientationChangeEventExample01.htm</i></p>

  <p class="calibre2">在这个例子中，当触发<code class="calibre15">load</code>事件时会显示最初的方向信息。然后，添加了处理<code class="calibre15">orientationchange</code>事件的处理程序。只要发生这个事件，就会有表示新方向的信息更新页面中的消息。</p>

  <p class="calibre2">所有iOS设备都支持<code class="calibre15">orientationchange</code>事件和<code class="calibre15">window.orientation</code>属性。</p>

  <blockquote class="calibre14">
    <p class="calibre2"><img alt="" class="calibre17" src="../Images/00002.gif" /> 由于可以将<code class="calibre15">orientationchange</code>看成<code class="calibre15">window</code>事件，所以也可以通过指定<code class="calibre15">&lt;body&gt;</code>元素的<code class="calibre15">onorientationchange</code>特性来指定事件处理程序。</p>
  </blockquote>

  <p class="calibre2">2. <strong class="calibre3"><code class="calibre15">MozOrientation</code>事件</strong></p>

  <p class="calibre2">Firefox 3.6为检测设备的方向引入了一个名为<code class="calibre15">MozOrientation</code>的新事件。（前缀<code class="calibre15">Moz</code>表示这是特定于浏览器开发商的事件，不是标准事件。）当设备的加速计检测到设备方向改变时，就会触发这个事件。但这个事件与iOS中的<code class="calibre15">orientationchange</code>事件不同，该事件只能提供一个平面的方向变化。由于<code class="calibre15">MozOrientation</code>事件是在<code class="calibre15">window</code>对象上触发的，所以可以使用以下代码来处理。</p>
  <pre class="calibre18"><code class="calibre15">EventUtil.addHandler(window, "MozOrientation", function(event){
    //响应事件
}); 
</code></pre>

  <p class="calibre2">此时的<code class="calibre15">event</code>对象包含三个属性：<code class="calibre15">x</code>、<code class="calibre15">y</code>和<code class="calibre15">z</code>。这几个属性的值都介于1到-1之间，表示不同坐标轴上的方向。在静止状态下，<code class="calibre15">x</code>值为0，<code class="calibre15">y</code>值为0，<code class="calibre15">z</code>值为1（表示设备处于竖直状态）。如果设备向右倾斜，<code class="calibre15">x</code>值会减小；反之，向左倾斜，<code class="calibre15">x</code>值会增大。类似地，如果设备向远离用户的方向倾斜，<code class="calibre15">y</code>值会减小，向接近用户的方向倾斜，<code class="calibre15">y</code>值会增大。<code class="calibre15">z</code>轴检测垂直加速度度，1表示静止不动，在设备移动时值会减小。（失重状态下值为0。）以下是输出这三个值的一个简单的例子。</p>
  <pre class="calibre18"><code class="calibre15">EventUtil.addHandler(window, "MozOrientation", function(event){
    var output = document.getElementById("output");
    output.innerHTML = "X=" + event.x + ", Y=" + event.y + ", Z=" + event.z +"&lt;br&gt;";
}); 
</code></pre>

  <p class="calibre8"><i class="calibre7">MozOrientationEventExample01.htm</i></p>

  <p class="calibre2">只有带加速计的设备才支持<code class="calibre15">MozOrientation</code>事件，包括Macbook、Lenovo Thinkpad、Windows Mobile和Android设备。请大家注意，这是一个实验性API，将来可能会变（可能会被其他事件取代）。</p>

  <p class="calibre2">3. <strong class="calibre3"><code class="calibre15">deviceorientation</code>事件</strong></p>

  <p class="calibre2">本质上，DeviceOrientation Event规范定义的<code class="calibre15">deviceorientation</code>事件与<code class="calibre15">MozOrientation</code>事件类似。它也是在加速计检测到设备方向变化时在<code class="calibre15">window</code>对象上触发，而且具有与<code class="calibre15">MozOrientation</code>事件相同的支持限制。不过，<code class="calibre15">deviceorientation</code>事件的意图是告诉开发人员设备在空间中朝向哪儿，而不是如何移动。</p>

  <p class="calibre2">设备在三维空间中是靠<em class="calibre7">x</em>、<em class="calibre7">y</em>和<em class="calibre7">z</em>轴来定位的。当设备静止放在水平表面上时，这三个值都是0。<em class="calibre7">x</em>轴方向是从左往右，<em class="calibre7">y</em>轴方向是从下往上，<em class="calibre7">z</em>轴方向是从后往前（参见图13-11）。</p>

  <p class="p-img"><img alt="" class="calibre42" src="../Images/00049.gif" /></p>

  <p class="calibre2"><strong class="calibre3">图　13-11</strong></p>

  <p class="calibre2">触发<code class="calibre15">deviceorientation</code>事件时，事件对象中包含着每个轴相对于设备静止状态下发生变化的信息。事件对象包含以下5个属性。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">alpha</code>：在围绕<em class="calibre7">z</em>轴旋转时（即左右旋转时），<em class="calibre7">y</em>轴的度数差；是一个介于0到360之间的浮点数。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">beta</code>：在围绕<em class="calibre7">x</em>轴旋转时（即前后旋转时），<em class="calibre7">z</em>轴的度数差；是一个介于?180到180之间的浮点数。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">gamma</code>：在围绕<em class="calibre7">y</em>轴旋转时（即扭转设备时），<em class="calibre7">z</em>轴的度数差；是一个介于?90到90之间的浮点数。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">absolute</code>：布尔值，表示设备是否返回一个绝对值。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">compassCalibrated</code>：布尔值，表示设备的指南针是否校准过。</p>
    </li>
  </ul>

  <p class="calibre2">图13-12是<code class="calibre15">alpha</code>、<code class="calibre15">beta</code>和<code class="calibre15">gamma</code>值含义的示意图。</p>

  <p class="calibre2">下面是一个输出alpha、beta和gamma值的例子。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">EventUtil.addHandler(window, "deviceorientation", function(event){
    var output = document.getElementById("output");
    output.innerHTML = "Alpha=" + event.alpha + ", Beta=" + event.beta +
                       ", Gamma=" + event.gamma + "&lt;br&gt;";
}); 
</code></pre>

  <p class="calibre8"><i class="calibre7">DeviceOrientationEventExample01.htm</i></p>

  <p class="calibre2">通过这些信息，可以响应设备的方向，重新排列或修改屏幕上的元素。要响应设备方向的改变而旋转元素，可以参考如下代码。</p>
  <pre class="calibre18"><code class="calibre15">EventUtil.addHandler(window, "deviceorientation", function(event){
    var arrow = document.getElementById("arrow");
    arrow.style.webkitTransform = "rotate(" + Math.round(event.alpha) + "deg)";
});
</code></pre>

  <p class="calibre8"><i class="calibre7">DeviceOrientationEventExample01.htm</i></p>

  <p class="p-img"><img alt="" class="calibre39" src="../Images/00050.gif" /></p>

  <p class="calibre2"><strong class="calibre3">图　13-12</strong></p>

  <p class="calibre2">这个例子只能在移动WebKit浏览器中运行，因为它使用了专有的<code class="calibre15">webkitTransform</code>属性（即CSS标准属性<code class="calibre15">transform</code>的临时版）。元素“arrow”会随着<code class="calibre15">event.alpha</code>值的变化而旋转，给人一种指南针的感觉。为了保证旋转平滑，这里的CSS3变换使用了舍入之后的值。</p>

  <p class="calibre2">到2011年，支持<code class="calibre15">deviceorientation</code>事件的浏览器有iOS 4.2+中的Safari、Chrome和Android版WebKit。</p>

  <p class="calibre2">4. <strong class="calibre3"><code class="calibre15">devicemotion</code>事件</strong></p>

  <p class="calibre2">DeviceOrientation Event规范还定义了一个<code class="calibre15">devicemotion</code>事件。这个事件是要告诉开发人员设备什么时候移动，而不仅仅是设备方向如何改变。例如，通过<code class="calibre15">devicemotion</code>能够检测到设备是不是正在往下掉，或者是不是被走着的人拿在手里。</p>

  <p class="calibre2">触发<code class="calibre15">devicemotion</code>事件时，事件对象包含以下属性。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">acceleration</code>：一个包含<code class="calibre15">x</code>、<code class="calibre15">y</code>和<code class="calibre15">z</code>属性的对象，在不考虑重力的情况下，告诉你在每个方向上的加速度。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">accelerationIncludingGravity</code>：一个包含<code class="calibre15">x</code>、<code class="calibre15">y</code>和<code class="calibre15">z</code>属性的对象，在考虑<code class="calibre15">z</code>轴自然重力加速度的情况下，告诉你在每个方向上的加速度。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">interval</code>：以毫秒表示的时间值，必须在另一个<code class="calibre15">devicemotion</code>事件触发前传入。这个值在每个事件中应该是一个常量。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">rotationRate</code>：一个包含表示方向的<code class="calibre15">alpha</code>、<code class="calibre15">beta</code>和<code class="calibre15">gamma</code>属性的对象。</p>
    </li>
  </ul>

  <p class="calibre2">如果读取不到<code class="calibre15">acceleration</code>、<code class="calibre15">accelerationIncludingGravity</code>和<code class="calibre15">rotationRate</code>值，则它们的值为<code class="calibre15">null</code>。因此，在使用这三个属性之前，应该先检测确定它们的值不是<code class="calibre15">null</code>。例如：</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">EventUtil.addHandler(window, "devicemotion", function(event){
    var output = document.getElementById("output");
    if (event.rotationRate !== null){
        output.innerHTML += "Alpha=" + event.rotationRate.alpha + ", Beta=" +
                             event.rotationRate.beta + ", Gamma=" +
                             event.rotationRate.gamma;
    }
}); 
</code></pre>

  <p class="calibre8"><i class="calibre7">DeviceMotionEventExample01.htm</i></p>

  <p class="calibre2">与<code class="calibre15">deviceorientation</code>事件类似，只有iOS 4.2+中的Safari、Chrome和Android版WebKit实现了<code class="calibre15">devicemotion</code>事件。</p>

  <h3 class="calibre22" id="nav_point_104">13.4.9　触摸与手势事件</h3>

  <p class="calibre2">iOS版Safari为了向开发人员传达一些特殊信息，新增了一些专有事件。因为iOS设备既没有鼠标也没有键盘，所以在为移动Safari开发交互性网页时，常规的鼠标和键盘事件根本不够用。随着Android中的WebKit的加入，很多这样的专有事件变成了事实标准，导致W3C开始制定Touch Events规范（参见<a class="calibre6" href="https://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html">https://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html</a>）。以下介绍的事件只针对触摸设备。</p>

  <p class="calibre2">1. <strong class="calibre3">触摸事件</strong></p>

  <p class="calibre2">包含iOS 2.0软件的iPhone 3G发布时，也包含了一个新版本的Safari浏览器。这款新的移动Safari提供了一些与触摸（touch）操作相关的新事件。后来，Android上的浏览器也实现了相同的事件。触摸事件会在用户手指放在屏幕上面时、在屏幕上滑动时或从屏幕上移开时触发。具体来说，有以下几个触摸事件。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">touchstart</code>：当手指触摸屏幕时触发；即使已经有一个手指放在了屏幕上也会触发。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">touchmove</code>：当手指在屏幕上滑动时连续地触发。在这个事件发生期间，调用<code class="calibre15">preventDefault()</code>可以阻止滚动。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">touchend</code>：当手指从屏幕上移开时触发。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">touchcancel</code>：当系统停止跟踪触摸时触发。关于此事件的确切触发时间，文档中没有明确说明。</p>
    </li>
  </ul>

  <p class="calibre2">上面这几个事件都会冒泡，也都可以取消。虽然这些触摸事件没有在DOM规范中定义，但它们却是以兼容DOM的方式实现的。因此，每个触摸事件的<code class="calibre15">event</code>对象都提供了在鼠标事件中常见的属性：<code class="calibre15">bubbles</code>、<code class="calibre15">cancelable</code>、<code class="calibre15">view</code>、<code class="calibre15">clientX</code>、<code class="calibre15">clientY</code>、<code class="calibre15">screenX</code>、<code class="calibre15">screenY</code>、<code class="calibre15">detail</code>、<code class="calibre15">altKey</code>、<code class="calibre15">shiftKey</code>、<code class="calibre15">ctrlKey</code>和<code class="calibre15">metaKey</code>。</p>

  <p class="calibre2">除了常见的DOM属性外，触摸事件还包含下列三个用于跟踪触摸的属性。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">touches</code>：表示当前跟踪的触摸操作的<code class="calibre15">Touch</code>对象的数组。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">targetTouchs</code>：特定于事件目标的<code class="calibre15">Touch</code>对象的数组。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">changeTouches</code>：表示自上次触摸以来发生了什么改变的<code class="calibre15">Touch</code>对象的数组。</p>
    </li>
  </ul>

  <p class="calibre2">每个<code class="calibre15">Touch</code>对象包含下列属性。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">clientX</code>：触摸目标在视口中的<em class="calibre7">x</em>坐标。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">clientY</code>：触摸目标在视口中的<em class="calibre7">y</em>坐标。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">identifier</code>：标识触摸的唯一ID。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">pageX</code>：触摸目标在页面中的<em class="calibre7">x</em>坐标。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">pageY</code>：触摸目标在页面中的<em class="calibre7">y</em>坐标。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">screenX</code>：触摸目标在屏幕中的<em class="calibre7">x</em>坐标。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">screenY</code>：触摸目标在屏幕中的<em class="calibre7">y</em>坐标。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">target</code>：触摸的DOM节点目标。</p>
    </li>
  </ul>

  <p class="calibre2">使用这些属性可以跟踪用户对屏幕的触摸操作。来看下面的例子。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">function handleTouchEvent(event){

    //只跟踪一次触摸
    if (event.touches.length == 1){

        var output = document.getElementById("output");
        switch(event.type){
            case "touchstart":
                output.innerHTML = "Touch started (" + event.touches[0].clientX + 
                                   "," + event.touches[0].clientY + ")";
                break;
            case "touchend":
                output.innerHTML += "&lt;br&gt;Touch ended (" + 
                                    event.changedTouches[0].clientX + "," +
                                    event.changedTouches[0].clientY + ")";
                break;
            case "touchmove":
                event.preventDefault();  //阻止滚动
                output.innerHTML += "&lt;br&gt;Touch moved (" +
                                    event.changedTouches[0].clientX + "," + 
                                    event.changedTouches[0].clientY + ")";
                break;
        }
    }
}

EventUtil.addHandler(document, "touchstart", handleTouchEvent);
EventUtil.addHandler(document, "touchend", handleTouchEvent);
EventUtil.addHandler(document, "touchmove", handleTouchEvent);
</code></pre>

  <p class="calibre8"><i class="calibre7">TouchEventsExample01.htm</i></p>

  <p class="calibre2">以上代码会跟踪屏幕上发生的一次触摸操作。为简单起见，只会在有一次活动触摸操作的情况下输出信息。当<code class="calibre15">touchstart</code>事件发生时，会将触摸的位置信息输出到<code class="calibre15">&lt;div&gt;</code>元素中。当<code class="calibre15">touchmove</code>事件发生时，会取消其默认行为，阻止滚动（触摸移动的默认行为是滚动页面），然后输出触摸操作的变化信息。而<code class="calibre15">touchend</code>事件则会输出有关触摸操作的最终信息。注意，在<code class="calibre15">touchend</code>事件发生时，<code class="calibre15">touches</code>集合中就没有任何<code class="calibre15">Touch</code>对象了，因为不存在活动的触摸操作；此时，就必须转而使用<code class="calibre15">changeTouchs</code>集合。</p>

  <p class="calibre2">这些事件会在文档的所有元素上面触发，因而可以分别操作页面的不同部分。在触摸屏幕上的元素时，这些事件（包括鼠标事件）发生的顺序如下：</p>

  <ol class="calibre11">
    <li class="calibre12" value="1">
      <p class="calibre2"><code class="calibre15">touchstart</code></p>
    </li>

    <li class="calibre12" value="2">
      <p class="calibre2"><code class="calibre15">mouseover</code></p>
    </li>

    <li class="calibre12" value="3">
      <p class="calibre2"><code class="calibre15">mousemove</code>（一次）</p>
    </li>

    <li class="calibre12" value="4">
      <p class="calibre2"><code class="calibre15">mousedown</code></p>
    </li>

    <li class="calibre12" value="5">
      <p class="calibre2"><code class="calibre15">mouseup</code></p>
    </li>

    <li class="calibre12" value="6">
      <p class="calibre2"><code class="calibre15">click</code></p>
    </li>

    <li class="calibre12" value="7">
      <p class="calibre2"><code class="calibre15">touchend</code></p>
    </li>
  </ol>

  <p class="calibre2">支持触摸事件的浏览器包括iOS版Safari、Android版WebKit、bada版Dolfin、OS6+中的BlackBerry WebKit、Opera Mobile 10.1+和LG专有OS中的Phantom浏览器。目前只有iOS版Safari支持多点触摸。桌面版Firefox 6+和Chrome也支持触摸事件。</p>

  <p class="calibre2">2. <strong class="calibre3">手势事件</strong></p>

  <p class="calibre2">iOS 2.0中的Safari还引入了一组手势事件。当两个手指触摸屏幕时就会产生手势，手势通常会改变显示项的大小，或者旋转显示项。有三个手势事件，分别介绍如下。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">gesturestart</code>：当一个手指已经按在屏幕上而另一个手指又触摸屏幕时触发。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">gesturechange</code>：当触摸屏幕的任何一个手指的位置发生变化时触发。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">gestureend</code>：当任何一个手指从屏幕上面移开时触发。</p>
    </li>
  </ul>

  <p class="calibre2">只有两个手指都触摸到事件的接收容器时才会触发这些事件。在一个元素上设置事件处理程序，意味着两个手指必须同时位于该元素的范围之内，才能触发手势事件（这个元素就是目标）。由于这些事件冒泡，所以将事件处理程序放在文档上也可以处理所有手势事件。此时，事件的目标就是两个手指都位于其范围内的那个元素。</p>

  <p class="calibre2">触摸事件和手势事件之间存在某种关系。当一个手指放在屏幕上时，会触发<code class="calibre15">touchstart</code>事件。如果另一个手指又放在了屏幕上，则会先触发<code class="calibre15">gesturestart</code>事件，随后触发基于该手指的<code class="calibre15">touchstart</code>事件。如果一个或两个手指在屏幕上滑动，将会触发<code class="calibre15">gesturechange</code>事件。但只要有一个手指移开，就会触发<code class="calibre15">gestureend</code>事件，紧接着又会触发基于该手指的<code class="calibre15">touchend</code>事件。</p>

  <p class="calibre2">与触摸事件一样，每个手势事件的<code class="calibre15">event</code>对象都包含着标准的鼠标事件属性：<code class="calibre15">bubbles</code>、<code class="calibre15">cancelable</code>、<code class="calibre15">view</code>、<code class="calibre15">clientX</code>、<code class="calibre15">clientY</code>、<code class="calibre15">screenX</code>、<code class="calibre15">screenY</code>、<code class="calibre15">detail</code>、<code class="calibre15">altKey</code>、shiftKey、ctrlKey和metaKey。此外，还包含两个额外的属性：<code class="calibre15">rotation</code>和<code class="calibre15">scale</code>。其中，<code class="calibre15">rotation</code>属性表示手指变化引起的旋转角度，负值表示逆时针旋转，正值表示顺时针旋转（该值从0开始）。而<code class="calibre15">scale</code>属性表示两个手指间距离的变化情况（例如向内收缩会缩短距离）；这个值从1开始，并随距离拉大而增长，随距离缩短而减小。</p>

  <p class="calibre2">下面是使用手势事件的一个示例。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">function handleGestureEvent(event){
    var output = document.getElementById("output");
    switch(event.type){
        case "gesturestart":
            output.innerHTML = "Gesture started (rotation=" + event.rotation + 
                               ",scale=" + event.scale + ")";
            break;
        case "gestureend":
            output.innerHTML += "&lt;br&gt;Gesture ended (rotation=" + event.rotation + 
                                ",scale=" + event.scale + ")";
            break;
        case "gesturechange":
            output.innerHTML += "&lt;br&gt;Gesture changed (rotation=" + event.rotation + 
                                ",scale=" + event.scale + ")";
            break;
    }
}

document.addEventListener("gesturestart", handleGestureEvent, false);
document.addEventListener("gestureend", handleGestureEvent, false);
document.addEventListener("gesturechange", handleGestureEvent, false);
</code></pre>

  <p class="calibre8"><i class="calibre7">GestureEventsExample01.htm</i></p>

  <p class="calibre2">与前面演示触摸事件的例子一样，这里的代码只是将每个事件都关联到同一个函数中，然后通过该函数输出每个事件的相关信息。</p>

  <blockquote class="calibre14">
    <p class="calibre2"><img alt="" class="calibre17" src="../Images/00002.gif" /> 触摸事件也会返回<strong class="calibre3"><code class="calibre15">rotation</code></strong>和<strong class="calibre3"><code class="calibre15">scale</code></strong>属性，但这两个属性只会在两个手指与屏幕保持接触时才会发生变化。一般来说，使用基于两个手指的手势事件，要比管理触摸事件中的所有交互要容易得多。</p>
  </blockquote>
</body>
</html>
