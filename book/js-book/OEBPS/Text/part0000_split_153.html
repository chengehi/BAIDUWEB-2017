<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>未知</title>
  <link href="../Styles/Style.css" rel="stylesheet" type="text/css" />
  <link href="../Styles/custom.css" rel="stylesheet" type="text/css" />
</head>

<body class="calibre">
  <h2 class="calibre9" id="nav_point_165">23.3　数据存储</h2>

  <p class="calibre2">随着Web应用程序的出现，也产生了对于能够直接在客户端上存储用户信息能力的要求。想法很合乎逻辑，属于某个特定用户的信息应该存在该用户的机器上。无论是登录信息、偏好设定或其他数据，Web应用提供者发现他们在找各种方式将数据存在客户端上。这个问题的第一个方案是以cookie的形式出现的，cookie是原来的网景公司创造的。一份题为“Persistent Client State: HTTP Cookes”（持久客户端状态：HTTP Cookies）的标准中对cookie机制进行了阐述（该标准还可以在这里看到：<a class="calibre6" href="http://curl.haxx.se/rfc/cookie_spec.html">http://curl.haxx.se/rfc/cookie_spec.html</a>）。今天，cookie只是在客户端存储数据的其中一种选项。</p>

  <h3 class="calibre22" id="nav_point_166">23.3.1　Cookie</h3>

  <p class="calibre2">HTTP Cookie，通常直接叫做cookie，最初是在客户端用于存储会话信息的。该标准要求服务器对任意HTTP请求发送Set-Cookie HTTP头作为响应的一部分，其中包含会话信息。例如，这种服务器响应的头可能如下：</p>
  <pre class="calibre18"><code class="calibre15">HTTP/1.1 200 OK
Content-type: text/html
Set-Cookie: name=value
Other-header: other-header-value
</code></pre>

  <p class="calibre2">这个HTTP响应设置以<code class="calibre15">name</code>为名称、以<code class="calibre15">value</code>为值的一个cookie，名称和值在传送时都必须是URL编码的。浏览器会存储这样的会话信息，并在这之后，通过为每个请求添加Cookie HTTP头将信息发送回服务器，如下所示：</p>
  <pre class="calibre18"><code class="calibre15">GET /index.html HTTP/1.1
Cookie: name=value
Other-header: other-header-value
</code></pre>

  <p class="calibre2">发送回服务器的额外信息可以用于唯一验证客户来自于发送的哪个请求。</p>

  <p class="calibre2">1. <strong class="calibre3">限制</strong></p>

  <p class="calibre2">cookie在性质上是绑定在特定的域名下的。当设定了一个cookie后，再给创建它的域名发送请求时，都会包含这个cookie。这个限制确保了储存在cookie中的信息只能让批准的接受者访问，而无法被其他域访问。</p>

  <p class="calibre2">由于cookie是存在客户端计算机上的，还加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间。每个域的cookie总数是有限的，不过浏览器之间各有不同。如下所示。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2">IE6 以及更低版本限制每个域名最多20个cookie。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2">IE7和之后版本每个域名最多50个。IE7最初是支持每个域名最大20个cookie，之后被微软的一个补丁所更新。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2">Firefox限制每个域最多50个cookie。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2">Opera限制每个域最多30个cookie。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2">Safari和Chrome对于每个域的cookie数量限制没有硬性规定。</p>
    </li>
  </ul>

  <p class="calibre2">当超过单个域名限制之后还要再设置cookie，浏览器就会清除以前设置的cookie。IE和Opera会删除最近最少使用过的（LRU，Least Recently Used）cookie，腾出空间给新设置的cookie。Firefox看上去好像是随机决定要清除哪个cookie，所以考虑cookie限制非常重要，以免出现不可预期的后果。</p>

  <p class="calibre2">浏览器中对于cookie的尺寸也有限制。大多数浏览器都有大约4096B（加减1）的长度限制。为了最佳的浏览器兼容性，最好将整个cookie长度限制在4095B（含4095）以内。尺寸限制影响到一个域下所有的cookie，而并非每个cookie单独限制。</p>

  <p class="calibre2">如果你尝试创建超过最大尺寸限制的cookie，那么该cookie会被悄无声息地丢掉。注意，虽然一个字符通常占用一字节，但是多字节情况则有不同。</p>

  <p class="calibre2">2. <strong class="calibre3">cookie的构成</strong></p>

  <p class="calibre2">cookie由浏览器保存的以下几块信息构成。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2"><strong class="calibre3">名称</strong>：一个唯一确定cookie的名称。cookie名称是不区分大小写的，所以<code class="calibre15">myCookie</code>和<code class="calibre15">MyCookie</code>被认为是同一个cookie。然而，实践中最好将cookie名称看作是区分大小写的，因为某些服务器会这样处理cookie。cookie的名称必须是经过URL编码的。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><strong class="calibre3">值</strong>：储存在cookie中的字符串值。值必须被URL编码。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><strong class="calibre3">域</strong>：cookie对于哪个域是有效的。所有向该域发送的请求中都会包含这个cookie信息。这个值可以包含子域（subdomain，如<code class="calibre15">www.wrox.com</code>），也可以不包含它（如<code class="calibre15">.wrox.com</code>，则对于wrox.com的所有子域都有效）。如果没有明确设定，那么这个域会被认作来自设置cookie的那个域。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><strong class="calibre3">路径</strong>：对于指定域中的那个路径，应该向服务器发送cookie。例如，你可以指定cookie只有从<code class="calibre15">http://www.wrox.com/books/</code>中才能访问，那么<code class="calibre15">http://www.wrox.com</code>的页面就不会发送cookie信息，即使请求都是来自同一个域的。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><strong class="calibre3">失效时间</strong>：表示cookie何时应该被删除的时间戳（也就是，何时应该停止向服务器发送这个cookie）。默认情况下，浏览器会话结束时即将所有cookie删除；不过也可以自己设置删除时间。这个值是个GMT格式的日期（Wdy, DD-Mon-YYYY HH:MM:SS GMT），用于指定应该删除cookie的准确时间。因此，cookie可在浏览器关闭后依然保存在用户的机器上。如果你设置的失效日期是个以前的时间，则cookie会被立刻删除。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><strong class="calibre3">安全标志</strong>：指定后，cookie只有在使用SSL连接的时候才发送到服务器。例如，cookie信息只能发送给<code class="calibre15">https://www.wrox.com</code>，而<code class="calibre15">http://www.wrox.com</code>的请求则不能发送 cookie。</p>
    </li>
  </ul>

  <p class="calibre2">每一段信息都作为<code class="calibre15">Set-Cookie</code>头的一部分，使用分号加空格分隔每一段，如下例所示。</p>
  <pre class="calibre18">HTTP/1.1 200 OK
Content-type: text/html
<b class="calibre3">Set-Cookie: name=value; expires=Mon, 22-Jan-07 07:10:24 GMT; domain=.wrox.com</b>
Other-header: other-header-value
</pre>

  <p class="calibre2">该头信息指定了一个叫做<code class="calibre15">name</code>的cookie，它会在格林威治时间2007年1月22日7:10:24失效，同时对于<code class="calibre15">www.wrox.com</code>和<code class="calibre15">wrox.com</code>的任何子域（如<code class="calibre15">p2p.wrox.com</code>）都有效。</p>

  <p class="calibre2"><code class="calibre15">secure</code>标志是cookie中唯一一个非名值对儿的部分，直接包含一个<code class="calibre15">secure</code>单词。如下：</p>
  <pre class="calibre18">HTTP/1.1 200 OK
Content-type: text/html
<b class="calibre3">Set-Cookie: name=value; domain=.wrox.com; path=/; secure</b>
Other-header: other-header-value
</pre>

  <p class="calibre2">这里，创建了一个对于所有<code class="calibre15">wrox.com</code>的子域和域名下（由<code class="calibre15">path</code>参数指定的）所有页面都有效的cookie。因为设置了<code class="calibre15">secure</code>标志，这个<code class="calibre15">cookie</code>只能通过SSL连接才能传输。</p>

  <p class="calibre2">尤其要注意，域、路径、失效时间和secure标志都是服务器给浏览器的指示，以指定何时应该发送cookie。这些参数并不会作为发送到服务器的cookie信息的一部分，只有名值对儿才会被发送。</p>

  <p class="calibre2">3. <strong class="calibre3">JavaScript中的cookie</strong></p>

  <p class="calibre2">在JavaScript中处理cookie有些复杂，因为其众所周知的蹩脚的接口，即BOM的<code class="calibre15">document. cookie</code>属性。这个属性的独特之处在于它会因为使用它的方式不同而表现出不同的行为。当用来获取属性值时，<code class="calibre15">document.cookie</code>返回当前页面可用的（根据cookie的域、路径、失效时间和安全设置）所有cookie的字符串，一系列由分号隔开的名值对儿，如下例所示。</p>
  <pre class="calibre18"><code class="calibre15">name1=value1;name2=value2;name3=value3
</code></pre>

  <p class="calibre2">所有名字和值都是经过URL编码的，所以必须使用<code class="calibre15">decodeURIComponent()</code>来解码。</p>

  <p class="calibre2">当用于设置值的时候，<code class="calibre15">document.cookie</code>属性可以设置为一个新的cookie字符串。这个cookie字符串会被解释并添加到现有的cookie集合中。设置<code class="calibre15">document.cookie</code>并不会覆盖cookie，除非设置的cookie的名称已经存在。设置cookie的格式如下，和<code class="calibre15">Set-Cookie</code>头中使用的格式一样。</p>
  <pre class="calibre18"><code class="calibre15">name=value; expires=expiration_time; path=domain_path; domain=domain_name; secure
</code></pre>

  <p class="calibre2">这些参数中，只有cookie的名字和值是必需的。下面是一个简单的例子。</p>
  <pre class="calibre18"><code class="calibre15">document.cookie = "name=Nicholas";
</code></pre>

  <p class="calibre2">这段代码创建了一个叫<code class="calibre15">name</code>的cookie，值为<code class="calibre15">Nicholas</code>。当客户端每次向服务器端发送请求的时候，都会发送这个cookie；当浏览器关闭的时候，它就会被删除。虽然这段代码没问题，但因为这里正好名称和值都无需编码，所以最好每次设置cookie时都像下面这个例子中一样使用<code class="calibre15">encodeURIComponent()</code>。</p>
  <pre class="calibre18"><code class="calibre15">document.cookie = encodeURIComponent("name") + "=" +
                  encodeURIComponent("Nicholas"); 
</code></pre>

  <p class="calibre2">要给被创建的cookie指定额外的信息，只要将参数追加到该字符串，和<code class="calibre15">Set-Cookie</code>头中的格式一样，如下所示。</p>
  <pre class="calibre18">document.cookie = encodeURIComponent("name") + "=" +
                   <b class="calibre3">encodeURIComponent("Nicholas") + "; domain=.wrox.com; path=/";</b>
</pre>

  <p class="calibre2">由于JavaScript中读写cookie不是非常直观，常常需要写一些函数来简化cookie的功能。基本的cookie操作有三种：读取、写入和删除。它们在<code class="calibre15">CookieUtil</code>对象中如下表示。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">var CookieUtil = {

    get: function (name){
        var cookieName = encodeURIComponent(name) + "=",
            cookieStart = document.cookie.indexOf(cookieName),
            cookieValue = null;

        if (cookieStart &gt; -1){
            var cookieEnd = document.cookie.indexOf(";", cookieStart);
            if (cookieEnd == -1){
                cookieEnd = document.cookie.length;
            }
            cookieValue = decodeURIComponent(document.cookie.substring(cookieStart
                          + cookieName.length, cookieEnd));
         }

        return cookieValue;
    },

    set: function (name, value, expires, path, domain, secure) {
        var cookieText = encodeURIComponent(name) + "=" +
                         encodeURIComponent(value);

        if (expires instanceof Date) {
            cookieText += "; expires=" + expires.toGMTString();
        }

        if (path) {
            cookieText += "; path=" + path;
        }  

        if (domain) {
            cookieText += "; domain=" + domain;
        }

        if (secure) {
            cookieText += "; secure";
        }

        document.cookie = cookieText;
    },

    unset: function (name, path, domain, secure){
        this.set(name, "", new Date(0), path, domain, secure);
    }

};
</code></pre>

  <p class="calibre8"><i class="calibre7">CookieUtil.js</i></p>

  <p class="calibre2"><code class="calibre15">CookieUtil.get()</code>方法根据cookie的名字获取相应的值。它会在<code class="calibre15">document.cookie</code>字符串中查找cookie名加上等于号的位置。如果找到了，那么使用<code class="calibre15">indexOf()</code>查找该位置之后的第一个分号（表示了该cookie的结束位置）。如果没有找到分号，则表示该cookie是字符串中的最后一个，则余下的字符串都是cookie的值。该值使用<code class="calibre15">decodeURIComponent()</code>进行解码并最后返回。如果没有发现cookie，则返回<code class="calibre15">null</code>。</p>

  <p class="calibre2"><code class="calibre15">CookieUtil.set()</code>方法在页面上设置一个cookie，接收如下几个参数：cookie的名称，cookie的值，可选的用于指定cookie何时应被删除的<code class="calibre15">Date</code>对象，cookie的可选的URL路径，可选的域，以及可选的表示是否要添加<code class="calibre15">secure</code>标志的布尔值。参数是按照它们的使用频率排列的，只有头两个是必需的。在这个方法中，名称和值都使用<code class="calibre15">encodeURIComponent()</code>进行了URL编码，并检查其他选项。如果<code class="calibre15">expires</code>参数是<code class="calibre15">Date</code>对象，那么会使用<code class="calibre15">Date</code>对象的<code class="calibre15">toGMTString()</code>方法正确格式化<code class="calibre15">Date</code>对象，并添加到<code class="calibre15">expires</code>选项上。方法的其他部分就是构造cookie字符串并将其设置到<code class="calibre15">document.cookie</code>中。</p>

  <p class="calibre2">没有删除已有cookie的直接方法。所以，需要使用相同的路径、域和安全选项再次设置cookie，并将失效时间设置为过去的时间。<code class="calibre15">CookieUtil.unset()</code>方法可以处理这种事情。它接收4个参数：要删除的cookie的名称、可选的路径参数、可选的域参数和可选的安全参数。</p>

  <p class="calibre2">这些参数加上空字符串并设置失效时间为1970年1月1日（初始化为0ms的<code class="calibre15">Date</code>对象的值），传给<code class="calibre15">CookieUtil.set()</code>。这样就能确保删除cookie。</p>

  <p class="calibre2">可以像下面这样使用上述方法。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">//设置cookie
CookieUtil.set("name", "Nicholas");
CookieUtil.set("book", "Professional JavaScript");

//读取cookie的值
alert(CookieUtil.get("name")); //"Nicholas"
alert(CookieUtil.get("book")); //"Professional JavaScript"

//删除cookie
CookieUtil.unset("name");
CookieUtil.unset("book");

//设置cookie，包括它的路径、域、失效日期
CookieUtil.set("name", "Nicholas", "/books/projs/", "www.wrox.com", 
               new Date("January 1, 2010"));

//删除刚刚设置的cookie
CookieUtil.unset("name", "/books/projs/", "www.wrox.com");

//设置安全的cookie
CookieUtil.set("name", "Nicholas", null, null, null, true);
</code></pre>

  <p class="calibre8"><i class="calibre7">CookieExample01.htm</i></p>

  <p class="calibre2">这些方法通过处理解析、构造cookie字符串的任务令在客户端利用cookie存储数据更加简单。</p>

  <p class="calibre2">4. <strong class="calibre3">子cookie</strong></p>

  <p class="calibre2">为了绕开浏览器的单域名下的cookie数限制，一些开发人员使用了一种称为<strong class="calibre3">子cookie</strong>（subcookie）的概念。子cookie是存放在单个cookie中的更小段的数据。也就是使用cookie值来存储多个名称值对儿。子cookie最常见的的格式如下所示。</p>
  <pre class="calibre18"><code class="calibre15">name=name1=value1&amp;name2=value2&amp;name3=value3&amp;name4=value4&amp;name5=value5
</code></pre>

  <p class="calibre2">子cookie一般也以查询字符串的格式进行格式化。然后这些值可以使用单个cookie进行存储和访问，而非对每个名称??值对儿使用不同的cookie存储。最后网站或者Web应用程序可以无需达到单域名cookie上限也可以存储更加结构化的数据。</p>

  <p class="calibre2">为了更好地操作子cookie，必须建立一系列新方法。子cookie的解析和序列化会因子cookie的期望用途而略有不同并更加复杂些。例如，要获得一个子cookie，首先要遵循与获得cookie一样的基本步骤，但是在解码cookie值之前，需要按如下方法找出子cookie的信息。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">var SubCookieUtil = {

    get: function (name, subName){
        var subCookies = this.getAll(name);
        if (subCookies){
            return subCookies[subName];
        } else {
            return null;
        }
    },

    getAll: function(name){
        var cookieName = encodeURIComponent(name) + "=",
            cookieStart = document.cookie.indexOf(cookieName),
            cookieValue = null,
            cookieEnd,
            subCookies,
            i,      
            parts,
            result = {};

        if (cookieStart &gt; -1){
            cookieEnd = document.cookie.indexOf(";", cookieStart);
            if (cookieEnd == -1){
                cookieEnd = document.cookie.length;
            }
            cookieValue = document.cookie.substring(cookieStart +
                          cookieName.length, cookieEnd);

            if (cookieValue.length &gt; 0){
                subCookies = cookieValue.split("&amp;");

                for (i=0, len=subCookies.length; i &lt; len; i++){
                    parts = subCookies[i].split("=");
                    result[decodeURIComponent(parts[0])] =
                         decodeURIComponent(parts[1]);
                }

                return result;
            }
        }

        return null;
    },

    //省略了更多代码
};
</code></pre>

  <p class="calibre8"><i class="calibre7">SubCookieUtil.js</i></p>

  <p class="calibre2">获取子cookie的方法有两个：<code class="calibre15">get()</code>和<code class="calibre15">getAll()</code>。其中<code class="calibre15">get()</code>获取单个子cookie的值，<code class="calibre15">getAll()</code>获取所有子cookie并将它们放入一个对象中返回，对象的属性为子cookie的名称，对应值为子cookie对应的值。<code class="calibre15">get()</code>方法接收两个参数：cookie的名字和子cookie的名字。它其实就是调用<code class="calibre15">getAll()</code>获取所有的子cookie，然后只返回所需的那一个（如果cookie不存在则返回<code class="calibre15">null</code>）。</p>

  <p class="calibre2"><code class="calibre15">SubCookieUtil.getAll()</code>方法和<code class="calibre15">CookieUtil.get()</code>在解析cookie值的方式上非常相似。区别在于cookie的值并非立即解码，而是先根据<code class="calibre15">&amp;</code>字符将子cookie分割出来放在一个数组中，每一个子cookie再根据等于号分割，这样在<code class="calibre15">parts</code>数组中的前一部分便是子cookie名，后一部分则是子cookie的值。这两个项目都要使用<code class="calibre15">decodeURIComponent()</code>来解码，然后放入<code class="calibre15">result</code>对象中，最后作为方法的返回值。如果cookie不存在，则返回<code class="calibre15">null</code>。</p>

  <p class="calibre2">可以像下面这样使用上述方法：</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">//假设document.cookie=data=name=Nicholas&amp;book=Professional%20JavaScript

//取得全部子cookie
var data = SubCookieUtil.getAll("data");
alert(data.name);  //"Nicholas"
alert(data.book);  //"Professional JavaScript"

//逐个获取子cookie
alert(SubCookieUtil.get("data", "name")); //"Nicholas"
alert(SubCookieUtil.get("data", "book")); //"Professional JavaScript"
</code></pre>

  <p class="calibre8"><i class="calibre7">SubCookiesExample01.htm</i></p>

  <p class="calibre2">要设置子cookie，也有两种方法：<code class="calibre15">set()</code>和<code class="calibre15">setAll()</code>。以下代码展示了它们的构造。</p>
  <pre class="calibre18">var SubCookieUtil = { 

    <b class="calibre3">set: function (name, subName, value, expires, path, domain, secure) {</b>
        <b class="calibre3">var subcookies = this.getAll(name) || {};</b>
        <b class="calibre3">subcookies[subName] = value;</b>
        <b class="calibre3">this.setAll(name, subcookies, expires, path, domain, secure);</b>
    <b class="calibre3">},</b>

    <b class="calibre3">setAll: function(name, subcookies, expires, path, domain, secure){</b>

        <b class="calibre3">var cookieText = encodeURIComponent(name) + "=",</b>
            <b class="calibre3">subcookieParts = new Array(),</b>
            <b class="calibre3">subName;</b>

        <b class="calibre3">for (subName in subcookies){</b>
            <b class="calibre3">if (subName.length &gt; 0 &amp;&amp; subcookies.hasOwnProperty(subName)){</b>
                <b class="calibre3">subcookieParts.push(encodeURIComponent(subName) + "=" +</b>
                    <b class="calibre3">encodeURIComponent(subcookies[subName]));</b>
            <b class="calibre3">}</b>
        <b class="calibre3">}</b>

        <b class="calibre3">if (cookieParts.length &gt; 0){</b>
            <b class="calibre3">cookieText += subcookieParts.join("&amp;");</b>

            <b class="calibre3">if (expires instanceof Date) {</b>
                <b class="calibre3">cookieText += "; expires=" + expires.toGMTString();</b>
            <b class="calibre3">}</b>

            <b class="calibre3">if (path) {</b>
                <b class="calibre3">cookieText += "; path=" + path;</b>
            <b class="calibre3">}</b>

            <b class="calibre3">if (domain) {</b>
               <b class="calibre3">cookieText += "; domain=" + domain;</b>
            <b class="calibre3">}</b>

            <b class="calibre3">if (secure) {</b>
               <b class="calibre3">cookieText += "; secure";</b>
            <b class="calibre3">}</b>
        <b class="calibre3">} else {</b>
            <b class="calibre3">cookieText += "; expires=" + (new Date(0)).toGMTString();</b>
        <b class="calibre3">}</b>

        <b class="calibre3">document.cookie = cookieText;</b>

    <b class="calibre3">},</b>

    //省略了更多代码
};
</pre>

  <p class="calibre8"><i class="calibre7">SubCookieUtil.js</i></p>

  <p class="calibre2">这里的<code class="calibre15">set()</code>方法接收7个参数：cookie名称、子cookie名称、子cookie值、可选的cookie失效日期或时间的Date对象、可选的cookie路径、可选的cookie域和可选的布尔<code class="calibre15">secure</code>标志。所有的可选参数都是作用于cookie本身而非子cookie。为了在同一个cookie中存储多个子cookie，路径、域和secure标志必须一致；针对整个cookie的失效日期则可以在任何一个单独的子cookie写入的时候同时设置。在这个方法中，第一步是获取指定cookie名称对应的所有子cookie。逻辑或操作符“||”用于当<code class="calibre15">getAll()</code>返回<code class="calibre15">null</code>时将subcookies设置为一个新对象。然后，在subcookies对象上设置好子cookie值并传给<code class="calibre15">setAll()</code>。</p>

  <p class="calibre2">而<code class="calibre15">setAll()</code>方法接收6个参数：cookie名称、包含所有子cookie的对象以及和<code class="calibre15">set()</code>中一样的4个可选参数。这个方法使用<code class="calibre15">for-in</code>循环遍历第二个参数中的属性。为了确保确实是要保存的数据，使用了<code class="calibre15">hasOwnProperty()</code>方法，来确保只有实例属性被序列化到子cookie中。由于可能会存在属性名为空字符串的情况，所以在把属性名加入结果对象之前还要检查一下属性名的长度。将每个子cookie的名值对儿都存入<code class="calibre15">subcookieParts</code>数组中，以便稍后可以使用<code class="calibre15">join()</code>方法以<code class="calibre15">&amp;</code>号组合起来。剩下的方法则和<code class="calibre15">CookieUtil.set()</code>一样。</p>

  <p class="calibre2">可以按如下方式使用这些方法。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">//假设document.cookie=data=name=Nicholas&amp;book=Professional%20JavaScript

//设置两个cookie
SubCookieUtil.set("data", "name", "Nicholas");
SubCookieUtil.set("data", "book", "Professional JavaScript");

//设置全部子cookie和失效日期
SubCookieUtil.setAll("data", { name: "Nicholas", book: "Professional JavaScript" },
    new Date("January 1, 2010"));

//修改名字的值，并修改cookie的失效日期
SubCookieUtil.set("data", "name", "Michael", new Date("February 1, 2010"));
</code></pre>

  <p class="calibre8"><i class="calibre7">SubCookiesExample01.htm</i></p>

  <p class="calibre2">子cookie的最后一组方法是用于删除子cookie的。普通cookie可以通过将失效时间设置为过去的时间的方法来删除，但是子cookie不能这样做。为了删除一个子cookie，首先必须获取包含在某个cookie中的所有子cookie，然后仅删除需要删除的那个子cookie，然后再将余下的子cookie的值保存为cookie的值。请看以下代码。</p>
  <pre class="calibre18">var SubCookieUtil = { 

    //这里省略了更多代码

    <b class="calibre3">unset: function (name, subName, path, domain, secure){</b>
        <b class="calibre3">var subcookies = this.getAll(name);</b>
        <b class="calibre3">if (subcookies){</b>
            <b class="calibre3">delete subcookies[subName];</b>
            <b class="calibre3">this.setAll(name, subcookies, null, path, domain, secure);</b>
        <b class="calibre3">}</b>
    <b class="calibre3">},</b>

    <b class="calibre3">unsetAll: function(name, path, domain, secure){</b>
        <b class="calibre3">this.setAll(name, null, new Date(0), path, domain, secure);</b>
    <b class="calibre3">}</b>

};
</pre>

  <p class="calibre8"><i class="calibre7">SubCookieUtil.js</i></p>

  <p class="calibre2">这里定义的两个方法用于两种不同的目的。<code class="calibre15">unset()</code>方法用于删除某个cookie中的单个子cookie而不影响其他的；而<code class="calibre15">unsetAll()</code>方法则等同于<code class="calibre15">CookieUtil.unset()</code>，用于删除整个cookie。和<code class="calibre15">set()</code>及<code class="calibre15">setAll()</code>一样，路径、域和<code class="calibre15">secure</code>标志必须和之前创建的cookie包含的内容一致。这两个方法可以像下面这样使用。</p>
  <pre class="calibre18"><code class="calibre15">//仅删除名为name的子cookie
SubCookieUtil.unset("data", "name");

//删除整个cookie
SubCookieUtil.unsetAll("data");
</code></pre>

  <p class="calibre2">如果你担心开发中可能会达到单域名的cookie上限，那么子cookie可是一个非常有吸引力的备选方案。不过，你需要更加密切关注cookie的长度，以防超过单个cookie的长度限制。</p>

  <p class="calibre2">5. <strong class="calibre3">关于cookie的思考</strong></p>

  <p class="calibre2">还有一类cookie被称为“HTTP专有cookie”。HTTP专有cookie可以从浏览器或者服务器设置，但是只能从服务器端读取，因为JavaScript无法获取HTTP专有cookie的值。</p>

  <p class="calibre2">由于所有的cookie都会由浏览器作为请求头发送，所以在cookie中存储大量信息会影响到特定域的请求性能。cookie信息越大，完成对服务器请求的时间也就越长。尽管浏览器对cookie进行了大小限制，不过最好还是尽可能在cookie中少存储信息，以避免影响性能。</p>

  <p class="calibre2">cookie的性质和它的局限使得其并不能作为存储大量信息的理想手段，所以又出现了其他方法。</p>

  <blockquote class="calibre14">
    <p class="calibre2"><img alt="" class="calibre17" src="../Images/00002.gif" /> 一定不要在cookie中存储重要和敏感的数据。cookie数据并非存储在一个安全环境中，其中包含的任何数据都可以被他人访问。所以不要在cookie中存储诸如信用卡号或者个人地址之类的数据。</p>
  </blockquote>

  <h3 class="calibre22" id="nav_point_167">23.3.2　IE用户数据</h3>

  <p class="calibre2">在IE5.0中，微软通过一个自定义行为引入了持久化用户数据的概念。用户数据允许每个文档最多128KB数据，每个域名最多1MB数据。要使用持久化用户数据，首先必须如下所示，使用CSS在某个元素上指定<code class="calibre15">userData</code>行为：</p>
  <pre class="calibre18"><code class="calibre15">&lt;div style="behavior:url(#default#userData)" id="dataStore"&gt;&lt;/div&gt;
</code></pre>

  <p class="calibre2">一旦该元素使用了<code class="calibre15">userData</code>行为，那么就可以使用<code class="calibre15">setAttribute()</code>方法在上面保存数据了。为了将数据提交到浏览器缓存中，还必须调用<code class="calibre15">save()</code>方法并告诉它要保存到的数据空间的名字。数据空间名字可以完全任意，仅用于区分不同的数据集。请看以下例子。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">var dataStore = document.getElementById("dataStore");
dataStore.setAttribute("name", "Nicholas");
dataStore.setAttribute("book", "Professional JavaScript");
dataStore.save("BookInfo");
</code></pre>

  <p class="calibre8"><i class="calibre7">UserDataExample01.htm</i></p>

  <p class="calibre2">在这段代码中，<code class="calibre15">&lt;div&gt;</code>元素上存入了两部分信息。在用<code class="calibre15">setAttribute()</code>存储了数据之后，调用了<code class="calibre15">save()</code>方法，指定了数据空间的名称为<code class="calibre15">BookInfo</code>。下一次页面载入之后，可以使用<code class="calibre15">load()</code>方法指定同样的数据空间名称来获取数据，如下所示。</p>
  <pre class="calibre18"><code class="calibre15">dataStore.load("BookInfo");
alert(dataStore.getAttribute("name")); //"Nicholas"
alert(dataStore.getAttribute("book")); //"Professional JavaScript"
</code></pre>

  <p class="calibre8"><i class="calibre7">UserDataExample01.htm</i></p>

  <p class="calibre2">对<code class="calibre15">load()</code>的调用获取了<code class="calibre15">BookInfo</code>数据空间中的所有信息，并且使数据可以通过元素访问；只有到载入确切完成之后数据方能使用。如果<code class="calibre15">getAttribute()</code>调用了不存在的名称或者是尚未载入的名程，则返回<code class="calibre15">null</code>。</p>

  <p class="calibre2">你可以通过<code class="calibre15">removeAttribute()</code>方法明确指定要删除某元素数据，只要指定属性名称。删除之后，必须像下面这样再次调用<code class="calibre15">save()</code>来提交更改。</p>
  <pre class="calibre18"><code class="calibre15">dataStore.removeAttribute("name");
dataStore.removeAttribute("book");
dataStore.save("BookInfo");
</code></pre>

  <p class="calibre8"><i class="calibre7">UserDataExample01.htm</i></p>

  <p class="calibre2">这段代码删除了两个数据属性，然后将更改保存到缓存中。</p>

  <p class="calibre2">对IE用户数据的访问限制和对cookie的限制类似。要访问某个数据空间，脚本运行的页面必须来自同一个域名，在同一个路径下，并使用与进行存储的脚本同样的协议。和cookie不同的是，你无法将用户数据访问限制扩展到更多的客户。还有一点不同，用户数据默认是可以跨越会话持久存在的，同时也不会过期；数据需要通过<code class="calibre15">removeAttribute()</code>方法专门进行删除以释放空间。</p>

  <blockquote class="calibre14">
    <p class="calibre2"><img alt="" class="calibre17" src="../Images/00002.gif" /> 和cookie一样，IE用户数据并非安全的，所以不能存放敏感信息。</p>
  </blockquote>

  <h3 class="calibre22" id="nav_point_168">23.3.3　Web存储机制</h3>

  <p class="calibre2">Web Storage最早是在Web超文本应用技术工作组（WHAT-WG）的Web应用1.0规范中描述的。这个规范的最初的工作最终成为了HTML5的一部分。Web Storage的目的是克服由cookie带来的一些限制，当数据需要被严格控制在客户端上时，无须持续地将数据发回服务器。Web Storage的两个主要目标是：</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2">提供一种在cookie之外存储会话数据的途径；</p>
    </li>

    <li class="calibre12">
      <p class="calibre2">提供一种存储大量可以跨会话存在的数据的机制。</p>
    </li>
  </ul>

  <p class="calibre2">最初的Web Storage规范包含了两种对象的定义：<code class="calibre15">sessionStorage</code>和<code class="calibre15">globalStorage</code>。这两个对象在支持的浏览器中都是以<code class="calibre15">windows</code>对象属性的形式存在的，支持这两个属性的浏览器包括IE8+、Firefox 3.5+、Chrome 4+和Opera 10.5+。</p>

  <blockquote class="calibre14">
    <p class="calibre2"><img alt="" class="calibre17" src="../Images/00002.gif" /> Firefox 2和3基于早期规范的内容部分实现了Web Storage，当时只实现了<code class="calibre15">globalStorage</code>，没有实现<code class="calibre15">localStorage</code>。</p>
  </blockquote>

  <p class="calibre2">1. <strong class="calibre3"><code class="calibre15">Storage</code>类型</strong></p>

  <p class="calibre2"><code class="calibre15">Storage</code>类型提供最大的存储空间（因浏览器而异）来存储名值对儿。<code class="calibre15">Storage</code>的实例与其他对象类似，有如下方法。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">clear()</code>： 删除所有值；Firefox中没有实现 。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">getItem(name)</code>：根据指定的名字<code class="calibre15">name</code>获取对应的值。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">key(index)</code>：获得index位置处的值的名字。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">removeItem(name)</code>：删除由<code class="calibre15">name</code>指定的名值对儿。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">setItem(name, value)</code>：为指定的<code class="calibre15">name</code>设置一个对应的值。</p>
    </li>
  </ul>

  <p class="calibre2">其中，<code class="calibre15">getItem()</code>、<code class="calibre15">removeItem()</code>和<code class="calibre15">setItem()</code>方法可以直接调用，也可通过<code class="calibre15">Storage</code>对象间接调用。因为每个项目都是作为属性存储在该对象上的，所以可以通过点语法或者方括号语法访问属性来读取值，设置也一样，或者通过<code class="calibre15">delete</code>操作符进行删除。不过，我们还建议读者使用方法而不是属性来访问数据，以免某个键会意外重写该对象上已经存在的成员。</p>

  <p class="calibre2">还可以使用<code class="calibre15">length</code>属性来判断有多少名值对儿存放在<code class="calibre15">Storage</code>对象中。但无法判断对象中所有数据的大小，不过IE8提供了一个<code class="calibre15">remainingSpace</code>属性，用于获取还可以使用的存储空间的字节数。</p>

  <blockquote class="calibre14">
    <p class="calibre2"><img alt="" class="calibre17" src="../Images/00002.gif" /> <strong class="calibre3"><code class="calibre15">Storage</code></strong>类型只能存储字符串。非字符串的数据在存储之前会被转换成字符串。</p>
  </blockquote>

  <p class="calibre2">2. <strong class="calibre3"><code class="calibre15">sessionStorage</code>对象</strong></p>

  <p class="calibre2"><code class="calibre15">sessionStorage</code>对象存储特定于某个会话的数据，也就是该数据只保持到浏览器关闭。这个对象就像会话cookie，也会在浏览器关闭后消失。存储在<code class="calibre15">sessionStorage</code>中的数据可以跨越页面刷新而存在，同时如果浏览器支持，浏览器崩溃并重启之后依然可用（Firefox和WebKit都支持，IE则不行）。</p>

  <p class="calibre2">因为<code class="calibre15">seesionStorage</code>对象绑定于某个服务器会话，所以当文件在本地运行的时候是不可用的。存储在<code class="calibre15">sessionStorage</code>中的数据只能由最初给对象存储数据的页面访问到，所以对多页面应用有限制。</p>

  <p class="calibre2">由于<code class="calibre15">sessionStorage</code>对象其实是<code class="calibre15">Storage</code>的一个实例，所以可以使用<code class="calibre15">setItem()</code>或者直接设置新的属性来存储数据。下面是这两种方法的例子。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">//使用方法存储数据
sessionStorage.setItem("name", "Nicholas");

//使用属性存储数据
sessionStorage.book = "Professional JavaScript";
</code></pre>

  <p class="calibre8"><i class="calibre7">SessionStorageExample01.htm</i></p>

  <p class="calibre2">不同浏览器写入数据方面略有不同。Firefox和WebKit实现了同步写入，所以添加到存储空间中的数据是立刻被提交的。而IE的实现则是异步写入数据，所以在设置数据和将数据实际写入磁盘之间可能有一些延迟。对于少量数据而言，这个差异是可以忽略的。对于大量数据，你会发现IE要比其他浏览器更快地恢复执行，因为它会跳过实际的磁盘写入过程。</p>

  <p class="calibre2">在IE8中可以强制把数据写入磁盘：在设置新数据之前使用<code class="calibre15">begin()</code>方法，并且在所有设置完成之后调用<code class="calibre15">commit()</code>方法。看以下例子。</p>
  <pre class="calibre18"><code class="calibre15">//只适用于IE8
sessionStorage.begin();
sessionStorage.name = "Nicholas";
sessionStorage.book = "Professional JavaScript";
sessionStorage.commit();
</code></pre>

  <p class="calibre2">这段代码确保了<code class="calibre15">name</code>和<code class="calibre15">book</code>的值在调用<code class="calibre15">commit()</code>之后立刻被写入磁盘。调用<code class="calibre15">begin()</code>是为了确保在这段代码执行的时候不会发生其他磁盘写入操作。对于少量数据而言，这个过程不是必需的；不过，对于大量数据（如文档之类的）可能就要考虑这种事务形式的方法了。</p>

  <p class="calibre2"><code class="calibre15">sessionStorage</code>中有数据时，可以使用<code class="calibre15">getItem()</code>或者通过直接访问属性名来获取数据。两种方法的例子如下。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">//使用方法读取数据
var name = sessionStorage.getItem("name");

//使用属性读取数据
var book = sessionStorage.book;
</code></pre>

  <p class="calibre8"><i class="calibre7">SessionStorageExample01.htm</i></p>

  <p class="calibre2">还可以通过结合<code class="calibre15">length</code>属性和<code class="calibre15">key()</code>方法来迭代<code class="calibre15">sessionStorage</code>中的值，如下所示。</p>
  <pre class="calibre18"><code class="calibre15">for (var i=0, len = sessionStorage.length; i &lt; len; i++){
    var key = sessionStorage.key(i);
    var value = sessionStorage.getItem(key);
    alert(key + "=" + value);
}
</code></pre>

  <p class="calibre8"><i class="calibre7">SessionStorageExample01.htm</i></p>

  <p class="calibre2">它是这样遍历<code class="calibre15">sessionStorage</code>中的名值对儿的：首先通过<code class="calibre15">key()</code>方法获取指定位置上的名字，然后再通过<code class="calibre15">getItem()</code>找出对应该名字的值。</p>

  <p class="calibre2">还可以使用<code class="calibre15">for-in</code>循环来迭代<code class="calibre15">sessionStorage</code>中的值：</p>
  <pre class="calibre18"><code class="calibre15">for (var key in sessionStorage){
    var value = sessionStorage.getItem(key);
    alert(key + "=" + value);
}
</code></pre>

  <p class="calibre2">每次经过循环的时候，<code class="calibre15">key</code>被设置为<code class="calibre15">sessionStorage</code>中下一个名字，此时不会返回任何内置方法或<code class="calibre15">length</code>属性。</p>

  <p class="calibre2">要从<code class="calibre15">sessionStorage</code>中删除数据，可以使用<code class="calibre15">delete</code>操作符删除对象属性，也可调用<code class="calibre15">removeItem()</code>方法。以下是这些方法的例子。</p>
  <pre class="calibre18"><code class="calibre15">//使用delete删除一个值——在WebKit中无效
delete sessionStorage.name;

//使用方法删除一个值
sessionStorage.removeItem("book");
</code></pre>

  <p class="calibre8"><i class="calibre7">SessionStorageExample01.htm</i></p>

  <p class="calibre2">在撰写本书时，<code class="calibre15">delete</code>操作符在WebKit中无法删除数据，<code class="calibre15">removeItem()</code>则可以在各种支持的浏览器中正确运行。</p>

  <p class="calibre2"><code class="calibre15">sessionStorage</code>对象应该主要用于仅针对会话的小段数据的存储。如果需要跨越会话存储数据，那么<code class="calibre15">globalStorage</code>或者<code class="calibre15">localStorage</code>更为合适。</p>

  <p class="calibre2">3. <strong class="calibre3"><code class="calibre15">globalStorage</code>对象</strong></p>

  <p class="calibre2">Firefox 2中实现了<code class="calibre15">globalStorage</code>对象。作为最初的Web Storage规范的一部分，这个对象的目的是跨越会话存储数据，但有特定的访问限制。要使用<code class="calibre15">globalStorage</code>，首先要指定哪些域可以访问该数据。可以通过方括号标记使用属性来实现，如以下例子所示。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">//保存数据
globalStorage["wrox.com"].name = "Nicholas";

//获取数据
var name = globalStorage["wrox.com"].name;
</code></pre>

  <p class="calibre8"><i class="calibre7">GlobalStorageExample01.htm</i></p>

  <p class="calibre2">在这里，访问的是针对域名<code class="calibre15">wrox.com</code>的存储空间。<code class="calibre15">globalStorage</code>对象不是<code class="calibre15">Storage</code>的实例，而具体的<code class="calibre15">globalStorage["wrox.com"]</code>才是。这个存储空间对于<code class="calibre15">wrox.com</code>及其所有子域都是可以访问的。可以像下面这样指定子域名。</p>
  <pre class="calibre18"><code class="calibre15">//保存数据
globalStorage["www.wrox.com"].name = "Nicholas";

//获取数据
var name = globalStorage["www.wrox.com"].name;
</code></pre>

  <p class="calibre8"><i class="calibre7">GlobalStorageExample01.htm</i></p>

  <p class="calibre2">这里所指定的存储空间只能由来自<code class="calibre15">www.wrox.com</code>的页面访问，其他子域名都不行。</p>

  <p class="calibre2">某些浏览器允许更加宽泛的访问限制，比如只根据顶级域名进行限制或者允许全局访问，如下面例子所示。</p>
  <pre class="calibre18"><code class="calibre15">//存储数据，任何人都可以访问——不要这样做！
globalStorage[""].name = "Nicholas";

//存储数据，可以让任何以.net结尾的域名访问——不要这样做！
globalStorage["net"].name = "Nicholas";
</code></pre>

  <p class="calibre2">虽然这些也支持，但是还是要避免使用这种可宽泛访问的数据存储，以防止出现潜在的安全问题。考虑到安全问题，这些功能在未来可能会被删除或者是被更严格地限制，所以不应依赖于这类功能。当使用<code class="calibre15">globalStorage</code>的时候一定要指定一个域名。</p>

  <p class="calibre2">对<code class="calibre15">globalStorage</code>空间的访问，是依据发起请求的页面的域名、协议和端口来限制的。例如，如果使用HTTPS协议在<code class="calibre15">wrox.com</code>中存储了数据，那么通过HTTP访问的<code class="calibre15">wrox.com</code>的页面就不能访问该数据。同样，通过80端口访问的页面则无法与同一个域同样协议但通过8080端口访问的页面共享数据。这类似于Ajax请求的同源策略。</p>

  <p class="calibre2"><code class="calibre15">globalStorage</code>的每个属性都是<code class="calibre15">Storage</code>的实例。因此，可以像如下代码中这样使用。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">globalStorage["www.wrox.com"].name = "Nicholas";
globalStorage["www.wrox.com"].book = "Professional JavaScript";

globalStorage["www.wrox.com"].removeItem("name");

var book = globalStorage["www.wrox.com"].getItem("book");
</code></pre>

  <p class="calibre8"><i class="calibre7">GlobalStorageExample01.htm</i></p>

  <p class="calibre2">如果你事先不能确定域名，那么使用<code class="calibre15">location.host</code>作为属性名比较安全。例如：</p>
  <pre class="calibre18"><code class="calibre15">globalStorage[location.host].name = "Nicholas";
var book = globalStorage[location.host].getItem("book");
</code></pre>

  <p class="calibre8"><i class="calibre7">GlobalStorageExample01.htm</i></p>

  <p class="calibre2">如果不使用<code class="calibre15">removeItem()</code>或者<code class="calibre15">delete</code>删除，或者用户未清除浏览器缓存，存储在<code class="calibre15">globalStorage</code>属性中的数据会一直保留在磁盘上。这让<code class="calibre15">globalStorage</code>非常适合在客户端存储文档或者长期保存用户偏好设置。</p>

  <p class="calibre2">4. <strong class="calibre3"><code class="calibre15">localStorage</code>对象</strong></p>

  <p class="calibre2"><code class="calibre15">localStorage</code>对象在修订过的HTML 5规范中作为持久保存客户端数据的方案取代了<code class="calibre15">globalStorage</code>。与<code class="calibre15">globalStorage</code>不同，不能给<code class="calibre15">localStorage</code>指定任何访问规则；规则事先就设定好了。要访问同一个<code class="calibre15">localStorage</code>对象，页面必须来自同一个域名（子域名无效），使用同一种协议，在同一个端口上。这相当于<code class="calibre15">globalStorage[location.host]</code>。</p>

  <p class="calibre2">由于<code class="calibre15">localStorage</code>是<code class="calibre15">Storage</code>的实例，所以可以像使用<code class="calibre15">sessionStorage</code>一样来使用它。下面是一些例子。</p>
  <pre class="calibre18"><code class="calibre15">//使用方法存储数据
localStorage.setItem("name", "Nicholas");

//使用属性存储数据
localStorage.book = "Professional JavaScript";

//使用方法读取数据
var name = localStorage.getItem("name");

//使用属性读取数据
var book = localStorage.book;
</code></pre>

  <p class="calibre8"><i class="calibre7">LocalStorageExample01.htm</i></p>

  <p class="calibre2">存储在<code class="calibre15">localStorage</code>中的数据和存储在<code class="calibre15">globalStorage</code>中的数据一样，都遵循相同的规则：数据保留到通过<code class="calibre15">JavaScript</code>删除或者是用户清除浏览器缓存。</p>

  <p class="calibre2">为了兼容只支持<code class="calibre15">globalStorage</code>的浏览器，可以使用以下函数。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">function getLocalStorage(){
    if (typeof localStorage == "object"){
        return localStorage;
    } else if (typeof globalStorage == "object"){
        return globalStorage[location.host];
    } else {
        throw new Error("Local storage not available.");
    }
}
</code></pre>

  <p class="calibre8"><i class="calibre7">GlobalAndLocalStorageExample01.htm</i></p>

  <p class="calibre2">然后，像下面这样调用一次这个函数，就可以正常地读写数据了。</p>
  <pre class="calibre18"><code class="calibre15">var storage = getLocalStorage();
</code></pre>

  <p class="calibre8"><i class="calibre7">GlobalAndLocalStorageExample01.htm</i></p>

  <p class="calibre2">在确定了使用哪个<code class="calibre15">Storage</code>对象之后，就能在所有支持Web Storage的浏览器中使用相同的存取规则操作数据了。</p>

  <p class="calibre2">5. <strong class="calibre3"><code class="calibre15">storage</code>事件</strong></p>

  <p class="calibre2">对<code class="calibre15">Storage</code>对象进行任何修改，都会在文档上触发<code class="calibre15">storage</code>事件。当通过属性或<code class="calibre15">setItem()</code>方法保存数据，使用<code class="calibre15">delete</code>操作符或<code class="calibre15">removeItem()</code>删除数据，或者调用<code class="calibre15">clear()</code>方法时，都会发生该事件。这个事件的<code class="calibre15">event</code>对象有以下属性。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">domain</code>：发生变化的存储空间的域名。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">key</code>：设置或者删除的键名。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">newValue</code>：如果是设置值，则是新值；如果是删除键，则是<code class="calibre15">null</code>。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">oldValue</code>：键被更改之前的值。</p>
    </li>
  </ul>

  <p class="calibre2">在这四个属性中，IE8和Firefox只实现了<code class="calibre15">domain</code>属性。在撰写本书的时候，WebKit尚不支持<code class="calibre15">storage</code>事件：</p>

  <p class="calibre2">以下代码展示了如何侦听<code class="calibre15">storage</code>事件：</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">EventUtil.addHandler(document, "storage", function(event){
    alert("Storage changed for " + event.domain);
});
</code></pre>

  <p class="calibre8"><i class="calibre7">StorageEventExample01.htm</i></p>

  <p class="calibre2">无论对<code class="calibre15">sessionStorage</code>、<code class="calibre15">globalStorage</code>还是<code class="calibre15">localStorage</code>进行操作，都会触发<code class="calibre15">storage</code>事件，但不作区分。</p>

  <p class="calibre2">6. <strong class="calibre3">限制</strong></p>

  <p class="calibre2">与其他客户端数据存储方案类似，Web Storage同样也有限制。这些限制因浏览器而异。一般来说，对存储空间大小的限制都是以每个来源（协议、域和端口）为单位的。换句话说，每个来源都有固定大小的空间用于保存自己的数据。考虑到这个限制，就要注意分析和控制每个来源中有多少页面需要保存数据。</p>

  <p class="calibre2">对于<code class="calibre15">localStorage</code>而言，大多数桌面浏览器会设置每个来源5MB的限制。Chrome和Safari对每个来源的限制是2.5MB。而iOS版Safari和Android版WebKit的限制也是2.5MB。</p>

  <p class="calibre2">对<code class="calibre15">sessionStorage</code>的限制也是因浏览器而异。有的浏览器对<code class="calibre15">sessionStorage</code>的大小没有限制，但Chrome、Safari、iOS版Safari和Android版WebKit都有限制，也都是2.5MB。IE8+和Opera对<code class="calibre15">sessionStorage</code>的限制是5MB。</p>

  <p class="calibre2">有关Web Storage的限制，请参考<a class="calibre6" href="http://dev-test.nemikor.com/web-storage/support-test/">http://dev-test.nemikor.com/web-storage/support-test/</a>。</p>

  <h3 class="calibre22" id="nav_point_169">23.3.4　IndexedDB</h3>

  <p class="calibre2">Indexed Database API，或者简称为IndexedDB，是在浏览器中保存结构化数据的一种数据库。IndexedDB是为了替代目前已被废弃的Web SQL Database API（因为已废弃，所以本书未介绍）而出现的。IndexedDB的思想是创建一套API，方便保存和读取JavaScript对象，同时还支持查询及搜索。</p>

  <p class="calibre2">IndexedDB设计的操作完全是异步进行的。因此，大多数操作会以请求方式进行，但这些操作会在后期执行，然后如果成功则返回结果，如果失败则返回错误。差不多每一次IndexedDB操作，都需要你注册<code class="calibre15">onerror</code>或<code class="calibre15">onsuccess</code>事件处理程序，以确保适当地处理结果。</p>

  <p class="calibre2">在得到完整支持的情况下，<code class="calibre15">IndexedDB</code>将是一个作为API宿主的全局对象。由于API仍然可能有变化，浏览器也都使用提供商前缀，因此这个对象在IE10中叫<code class="calibre15">msIndexedDB</code>，在Firefox 4中叫<code class="calibre15">mozIndexedDB</code>，在Chrome中叫<code class="calibre15">webkitIndexedDB</code>。为了清楚起见，本节示例中将使用<code class="calibre15">IndexedDB</code>，而实际上每个示例前面都应该加上下面这行代码：</p>
  <pre class="calibre18"><code class="calibre15">var indexedDB = window.indexedDB || window.msIndexedDB || window.mozIndexedDB ||
window.webkitIndexedDB;
</code></pre>

  <p class="calibre8"><i class="calibre7">IndexedDBExample01.htm</i></p>

  <p class="calibre2">1. <strong class="calibre3">数据库</strong></p>

  <p class="calibre2">IndexedDB就是一个数据库，与MySQL或Web SQL Database等这些你以前可能用过的数据库类似。IndexedDB最大的特色是使用对象保存数据，而不是使用表来保存数据。一个IndexedDB数据库，就是一组位于相同命名空间下的对象的集合。</p>

  <p class="calibre2">使用IndexedDB的第一步是打开它，即把要打开的数据库名传给<code class="calibre15">indexDB.open()</code>。如果传入的数据库已经存在，就会发送一个打开它的请求；如果传入的数据库还不存在，就会发送一个创建并打开它的请求。总之，调用<code class="calibre15">indexDB.open()</code>会返回一个<code class="calibre15">IDBRequest</code>对象，在这个对象上可以添加<code class="calibre15">onerror</code>和<code class="calibre15">onsuccess</code>事件处理程序。先来看一个例子。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">var request, database;

request = indexedDB.open("admin");
request.onerror = function(event){
    alert("Something bad happened while trying to open: " +
           event.target.errorCode);
};
request.onsuccess = function(event){
    database = event.target.result;
};
</code></pre>

  <p class="calibre8"><i class="calibre7">IndexedDBExample01.htm</i></p>

  <p class="calibre2">在这两个事件处理程序中，<code class="calibre15">event.target</code>都指向<code class="calibre15">request</code>对象，因此它们可以互换使用。如果响应的是<code class="calibre15">onsuccess</code>事件处理程序，那么<code class="calibre15">event.target.result</code>中将有一个数据库实例对象（<code class="calibre15">IDBDatabase</code>），这个对象会保存在<code class="calibre15">database</code>变量中。如果发生了错误，那<code class="calibre15">event.target.errorCode</code>中将保存一个错误码，表示问题的性质。以下就是可能的错误码（这个错误码适合所有操作）。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">IDBDatabaseException.UNKNOWN_ERR</code>(1)：意外错误，无法归类。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">IDBDatabaseException.NON_TRANSIENT_ERR</code>(2)：操作不合法。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">IDBDatabaseException.NOT_FOUND_ERR</code>(3)：未发现要操作的数据库。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">IDBDatabaseException.CONSTRAINT_ERR</code>(4)：违反了数据库约束。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">IDBDatabaseException.DATA_ERR</code>(5)：提供给事务的数据不能满足要求。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">IDBDatabaseException.NOT_ALLOWED_ERR</code>(6)：操作不合法。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">IDBDatabaseException.TRANSACTION_INACTIVE_ERR</code>(7)：试图重用已完成的事务。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">IDBDatabaseException.ABORT_ERR</code>(8)：请求中断，未成功。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">IDBDatabaseException.READ_ONLY_ERR</code>(9)：试图在只读模式下写入或修改数据。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">IDBDatabaseException.TIMEOUT_ERR</code>(10)：在有效时间内未完成操作。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">IDBDatabaseException.QUOTA_ERR</code>(11)：磁盘空间不足。</p>
    </li>
  </ul>

  <p class="calibre2">默认情况下，IndexedDB数据库是没有版本号的，最好一开始就为数据库指定一个版本号。为此，可以调用<code class="calibre15">setVersion()</code>方法，传入以字符串形式表示的版本号。同样，调用这个方法也会返回一个请求对象，需要你再指定事件处理程序。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">if (database.version != "1.0"){
    request = database.setVersion("1.0");
    request.onerror = function(event){
        alert("Something bad happened while trying to set version: " +
              event.target.errorCode);
    };
    request.onsuccess = function(event){
        alert("Database initialization complete. Database name: " + database.name +
              ", Version: " + database.version);
    };
} else {
    alert("Database already initialized. Database name: " + database.name +
          ", Version: " + database.version);
}
</code></pre>

  <p class="calibre8"><i class="calibre7">IndexedDBExample01.htm</i></p>

  <p class="calibre2">这个例子尝试把数据库的版本号设置为1.0。第一行先检测<code class="calibre15">version</code>属性，看是否已经为数据库设置了相应的版本号。如果没有，就调用<code class="calibre15">setVersion()</code>创建修改版本的请求。如果请求成功，显示一条消息，表示版本修改成功。（在真实的项目开发中，你应该在这里建立对象存储空间。详细内容请看下一节。）</p>

  <p class="calibre2">如果数据库的版本号已经被设置为1.0，则显示一条消息，说明数据库已经初始化过了。总之，通过这种模式，就能知道你想使用的数据库是否已经设置了适当的对象存储空间。在整个Web应用中，随着对数据库结构的更新和修改，可能会产生很多个不同版本的数据库。</p>

  <p class="calibre2">2. <strong class="calibre3">对象存储空间</strong></p>

  <p class="calibre2">在建立了与数据库的连接之后，下一步就是使用对象存储空间<sup class="calibre13">1</sup>。如果数据库的版本与你传入的版本不匹配，那可能就需要创建一个新的对象存储空间。在创建对象存储空间之前，必须要想清楚你想要保存什么数据类型。</p>

  <blockquote class="calibre14">
    <p class="calibre2"><sup class="calibre13">1</sup> 有关系数据库经验的读者，可以把这里的对象存储空间（object storge）想象成表，而把其中保存的对象想象成表中的记录。</p>
  </blockquote>

  <p class="calibre2">假设你要保存的用户记录由用户名、密码等组成，那么保存一条记录的对象应该类似如下所示：</p>
  <pre class="calibre18"><code class="calibre15">var user = {
    username: "007",
    firstName: "James",
    lastName: "Bond",
    password: "foo"
};
</code></pre>

  <p class="calibre2">有了这个对象，很容易想到<code class="calibre15">username</code>属性可以作为这个对象存储空间的键。这个<code class="calibre15">username</code>必须全局唯一，而且大多数时候都要通过这个键来访问数据。这一点非常重要，因为在创建对象存储空间时，必须指定这么一个键。以下是就是为保存上述用户记录而创建对象存储空间的示例。</p>
  <pre class="calibre18"><code class="calibre15">var store = db.createObjectStore("users", { keyPath: "username" });
</code></pre>

  <p class="calibre8"><i class="calibre7">IndexedDBExample02.htm</i></p>

  <p class="calibre2">其中第二个参数中的<code class="calibre15">keyPath</code>属性，就是空间中将要保存的对象的一个属性，而这个属性将作为存储空间的键来使用。</p>

  <p class="calibre2">好，现在有了一个对存储空间的引用。接下来可以使用<code class="calibre15">add()</code>或<code class="calibre15">put()</code>方法来向其中添加数据。这两个方法都接收一个参数，即要保存的对象，然后这个对象就会被保存到存储空间中。这两个方法的区别在空间中已经包含键值相同的对象时会体现出来。在这种情况下，<code class="calibre15">add()</code>会返回错误，而<code class="calibre15">put()</code>则会重写原有对象。简单地说，可以把<code class="calibre15">add()</code>想象成插入新值，把<code class="calibre15">put()</code>想象成更新原有的值。在初始化对象存储空间时，可以使用类似下面这样的代码。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">//users中保存着一批用户对象
var i=0,
    len = users.length;

while(i &lt; len){
    store.add(users[i++]);
}
</code></pre>

  <p class="calibre8"><i class="calibre7">IndexedDBExample02.htm</i></p>

  <p class="calibre2">每次调用<code class="calibre15">add()</code>或<code class="calibre15">put()</code>都会创建一个新的针对这个对象存储空间的更新请求。如果想验证请求是否成功完成，可以把返回的请求对象保存在一个变量中，然后再指定<code class="calibre15">onerror</code>或<code class="calibre15">onsuccess</code>事件处理程序。</p>
  <pre class="calibre18">//users中保存着一批用户对象
var i=0,
    <b class="calibre3">request,</b>
    <b class="calibre3">requests = [],</b>
    len = users.length;

while(i &lt; len){
    <b class="calibre3">request = store.add(users[i++]);</b>
    <b class="calibre3">request.onerror = function(){</b>
        <b class="calibre3">//处理错误</b>
    <b class="calibre3">};</b>
    <b class="calibre3">request.onsuccess = function(){</b>
        <b class="calibre3">//处理成功</b>
    <b class="calibre3">};</b>
    <b class="calibre3">requests.push(request);</b>
}
</pre>

  <p class="calibre2">创建了对象存储空间并向其中添加了数据之后，就该查询数据了。</p>

  <p class="calibre2">3. <strong class="calibre3">事务</strong></p>

  <p class="calibre2">跨过创建对象存储空间这一步之后，接下来的所有操作都是通过事务来完成的。在数据库对象上调用<code class="calibre15">transaction()</code>方法可以创建事务。任何时候，只要想读取或修改数据，都要通过事务来组织所有操作。在最简单的情况下，可以像下面这样创建事务<sup class="calibre13">2</sup>。</p>

  <blockquote class="calibre14">
    <p class="calibre2"><sup class="calibre13">2</sup> 以下示例代码中的<code class="calibre15">db</code>即前面示例代码中的<code class="calibre15">database</code>，正文中提到的“数据库对象”也是指它。</p>
  </blockquote>
  <pre class="calibre18"><code class="calibre15">var transaction = db.transaction();
</code></pre>

  <p class="calibre2">如果没有参数，就只能通过事务来读取数据库中保存的对象。最常见的方式是传入要访问的一或多个对象存储空间。</p>
  <pre class="calibre18"><code class="calibre15">var transaction = db.transaction("users");
</code></pre>

  <p class="calibre2">这样就能保证只加载<code class="calibre15">users</code>存储空间中的数据，以便通过事务进行访问。如果要访问多个对象存储空间，也可以在第一个参数的位置上传入字符串数组。</p>
  <pre class="calibre18"><code class="calibre15">var transaction = db.transaction(["users", "anotherStore"]);
</code></pre>

  <p class="calibre2">如前所述，这些事务都是以只读方式访问数据。要修改访问方式，必须在创建事务时传入第二个参数，这个参数表示访问模式，用<code class="calibre15">IDBTransaction</code>接口定义的如下常量表示：<code class="calibre15">READ_ONLY</code>（0）表示只读，<code class="calibre15">READ_WRITE</code>（1）表示读写，<code class="calibre15">VERSION_CHANGE</code>（2）表示改变。IE10+和Firefox 4+实现的是<code class="calibre15">IDBTransaction</code>，但在Chrome中则叫<code class="calibre15">webkitIDBTransaction</code>，所以使用下面的代码可以统一接口：</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">var IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction;
</code></pre>

  <p class="calibre8"><i class="calibre7">IndexedDBExample03.htm</i></p>

  <p class="calibre2">有了这行代码，就可以更方便地为<code class="calibre15">transaction()</code>指定第二个参数了。</p>
  <pre class="calibre18"><code class="calibre15">var transaction = db.transaction("users", IDBTransaction.READ_WRITE);
</code></pre>

  <p class="calibre8"><i class="calibre7">IndexedDBExample03.htm</i></p>

  <p class="calibre2">这个事务能够读写<code class="calibre15">users</code>存储空间。</p>

  <p class="calibre2">取得了事务的索引后，使用<code class="calibre15">objectStore()</code>方法并传入存储空间的名称，就可以访问特定的存储空间。然后，可以像以前一样使用<code class="calibre15">add()</code>和<code class="calibre15">put()</code>方法，使用<code class="calibre15">get()</code>可以取得值，使用<code class="calibre15">delete()</code>可以删除对象，而使用<code class="calibre15">clear()</code>则可以删除所有对象。<code class="calibre15">get()</code>和<code class="calibre15">delete()</code>方法都接收一个对象键作为参数，而所有这5个方法都会返回一个新的请求对象。例如：</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">var request = db.transaction("users").objectStore("users").get("007");
request.onerror = function(event){
    alert("Did not get the object!");
};
request.onsuccess = function(event){
    var result = event.target.result;
    alert(result.firstName);    //"James"
};
</code></pre>

  <p class="calibre8"><i class="calibre7">IndexedDBExample02.htm</i></p>

  <p class="calibre2">因为一个事务可以完成任何多个请求，所以事务对象本身也有事件处理程序：<code class="calibre15">onerror</code>和<code class="calibre15">oncomplete</code>。这两个事件可以提供事务级的状态信息。</p>
  <pre class="calibre18"><code class="calibre15">transaction.onerror = function(event){
    //整个事务都被取消了
};

transaction.oncomplete = function(event){
    //整个事务都成功完成了
};
</code></pre>

  <p class="calibre2">注意，通过<code class="calibre15">oncomplete</code>事件的事件对象（<code class="calibre15">event</code>）访问不到<code class="calibre15">get()</code>请求返回的任何数据。必须在相应请求的<code class="calibre15">onsuccess</code>事件处理程序中才能访问到数据。</p>

  <p class="calibre2">4. <strong class="calibre3">使用游标查询</strong></p>

  <p class="calibre2">使用事务可以直接通过已知的键检索单个对象。而在需要检索多个对象的情况下，则需要在事务内部创建游标。游标就是一指向结果集的指针。与传统数据库查询不同，游标并不提前收集结果。游标指针会先指向结果中的第一项，在接到查找下一项的指令时，才会指向下一项。</p>

  <p class="calibre2">在对象存储空间上调用<code class="calibre15">openCursor()</code>方法可以创建游标。与IndexedDB中的其他操作一样，<code class="calibre15">openCursor()</code>方法返回的是一个请求对象，因此必须为该对象指定<code class="calibre15">onsuccess</code>和<code class="calibre15">onerror</code>事件处理程序。例如：</p>
  <pre class="calibre18"><code class="calibre15">var store = db.transaction("users").objectStore("users"),
    request = store.openCursor();

request.onsuccess = function(event){
    //处理成功
};

request.onerror = function(event){
    //处理失败
};
</code></pre>

  <p class="calibre8"><i class="calibre7">IndexedDBExample04.htm</i></p>

  <p class="calibre2">在<code class="calibre15">onsuccess</code>事件处理程序执行时，可以通过<code class="calibre15">event.target.result</code>取得存储空间中的下一个对象。在结果集中有下一项时，这个属性中保存一个<code class="calibre15">IDBCursor</code>的实例，在没有下一项时，这个属性的值为<code class="calibre15">null</code>。<code class="calibre15">IDBCursor</code>的实例有以下几个属性。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">direction</code>：数值，表示游标移动的方向。默认值为<code class="calibre15">IDBCursor.NEXT</code>（0），表示下一项。<code class="calibre15">IDBCursor.NEXT_NO_DUPLICATE</code>（1）表示下一个不重复的项，<code class="calibre15">DBCursor.PREV</code>（2）表示前一项，而<code class="calibre15">IDBCursor.PREV_NO_DUPLICATE</code>表示前一个不重复的项。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">key</code>：对象的键。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">value</code>：实际的对象。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">primaryKey</code>：游标使用的键。可能是对象键，也可能是索引键（稍后讨论索引键）。</p>
    </li>
  </ul>

  <p class="calibre2">要检索某一个结果的信息，可以像下面这样：</p>
  <pre class="calibre18"><code class="calibre15">request.onsuccess = function(event){
    var cursor = event.target.result;
    if (cursor){ //必须要检查
        console.log("Key: " + cursor.key + ", Value: " +
                    JSON.stringify(cursor.value));
    }
};
</code></pre>

  <p class="calibre2">请记住，这个例子中的<code class="calibre15">cursor.value</code>是一个对象，这也是为什么在显示它之前先将它转换成JSON字符串的原因。</p>

  <p class="calibre2">使用游标可以更新个别的记录。调用<code class="calibre15">update()</code>方法可以用指定的对象更新当前游标的<code class="calibre15">value</code>。与其他操作一样，调用<code class="calibre15">update()</code>方法也会创建一个新请求，因此如果你想知道结果，就要为它指定<code class="calibre15">onsuccess</code>和<code class="calibre15">onerror</code>事件处理程序。</p>
  <pre class="calibre18">request.onsuccess = function(event){
    var cursor = event.target.result,
        <b class="calibre3">value,</b>
        <b class="calibre3">updateRequest;</b>

    if (cursor){ //必须要检查
        <b class="calibre3">if (cursor.key == "foo"){</b>
            <b class="calibre3">value = cursor.value;                   //取得当前的值</b>
            <b class="calibre3">value.password = "magic!";              //更新密码</b>

            <b class="calibre3">updateRequest = cursor.update(value);   //请求保存更新</b>
            <b class="calibre3">updateRequest.onsuccess = function(){</b>
                <b class="calibre3">//处理成功</b>
            <b class="calibre3">};</b>
            <b class="calibre3">updateReqeust.onerror = function(){</b>
                <b class="calibre3">//处理失败</b>
            <b class="calibre3">};</b>
        <b class="calibre3">}</b>
    }
};
</pre>

  <p class="calibre2">此时，如果调用<code class="calibre15">delete()</code>方法，就会删除相应的记录。与<code class="calibre15">update()</code>一样，调用<code class="calibre15">delete()</code>也返回一个请求。</p>
  <pre class="calibre18">request.onsuccess = function(event){
    var cursor = event.target.result,
        <b class="calibre3">value,</b>
        <b class="calibre3">deleteRequest;</b>

    if (cursor){  //必须要检查
        <b class="calibre3">if (cursor.key == "foo"){</b>
            <b class="calibre3">deleteRequest = cursor.delete();     //请求删除当前项</b>
            <b class="calibre3">deleteRequest.onsuccess = function(){</b>
                <b class="calibre3">//处理成功</b>
            <b class="calibre3">};</b>
            <b class="calibre3">deleteRequest.onerror = function(){</b>
                <b class="calibre3">//处理失败</b>
            <b class="calibre3">};</b>
        <b class="calibre3">}</b>
    }
};
</pre>

  <p class="calibre2">如果当前事务没有修改对象存储空间的权限，<code class="calibre15">update()</code>和<code class="calibre15">delete()</code>会抛出错误。</p>

  <p class="calibre2">默认情况下，每个游标只发起一次请求。要想发起另一次请求，必须调用下面的一个方法。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">continue(<em class="calibre7">key</em>)</code>：移动到结果集中的下一项。参数<code class="calibre15"><em class="calibre7">key</em></code>是可选的，不指定这个参数，游标移动到下一项；指定这个参数，游标会移动到指定键的位置。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">advance(<em class="calibre7">count</em>)</code>：向前移动<code class="calibre15"><em class="calibre7">count</em></code>指定的项数。</p>
    </li>
  </ul>

  <p class="calibre2">这两个方法都会导致游标使用相同的请求，因此相同的<code class="calibre15">onsuccess</code>和<code class="calibre15">onerror</code>事件处理程序也会得到重用。例如，下面的例子遍历了对象存储空间中的所有项。</p>
  <pre class="calibre18">request.onsuccess = function(event){
    var cursor = event.target.result;
    if (cursor){ //必须要检查
        console.log("Key: " + cursor.key + ", Value: " +
                    JSON.stringify(cursor.value));
        <b class="calibre3">cursor.continue(); //移动到下一项</b>
    <b class="calibre3">} else {</b>
        <b class="calibre3">console.log("Done!");</b>
    <b class="calibre3">}</b>
};
</pre>

  <p class="calibre2">调用<code class="calibre15">continue()</code>会触发另一次请求，进而再次调用<code class="calibre15">onsuccess</code>事件处理程序。在没有更多项可以迭代时，将最后一次调用<code class="calibre15">onsuccess</code>事件处理程序，此时<code class="calibre15">event.target.result</code>的值为<code class="calibre15">null</code>。</p>

  <p class="calibre2">5. <strong class="calibre3">键范围</strong></p>

  <p class="calibre2">使用游标总让人觉得不那么理想，因为通过游标查找数据的方式太有限了。键范围（key range）为使用游标增添了一些灵活性。键范围由<code class="calibre15">IDBKeyRange</code>的实例表示。支持标准<code class="calibre15">IDBKeyRange</code>类型的浏览器有IE10+和Firefox 4+，Chrome中的名字叫<code class="calibre15">webkitIDBKeyRange</code>。与使用IndexedDB中的其他类型一样，你最好先声明一个本地的类型，同时要考虑到不同浏览器中的差异。</p>
  <pre class="calibre18"><code class="calibre15">var IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange;
</code></pre>

  <p class="calibre2">有四种定义键范围的方式。第一种是使用<code class="calibre15">only()</code>方法，传入你想要取得的对象的键。</p>
  <pre class="calibre18"><code class="calibre15">var onlyRange = IDBKeyRange.only("007");
</code></pre>

  <p class="calibre2">这个范围可以保证只取得键为<code class="calibre15">"007"</code>的对象。使用这个范围创建的游标与直接访问存储空间并调用<code class="calibre15">get("007")</code>差不多。</p>

  <p class="calibre2">第二种定义键范围的方式是指定结果集的下界。下界表示游标开始的位置。例如，以下键范围可以保证游标从键为<code class="calibre15">"007"</code>的对象开始，然后继续向前移动，直至最后一个对象。</p>
  <pre class="calibre18"><code class="calibre15">//从键为"007"的对象开始，然后可以移动到最后
var lowerRange = IDBKeyRange.lowerBound("007");
</code></pre>

  <p class="calibre2">如果你想忽略键为<code class="calibre15">"007"</code>的对象，从它的下一个对象开始，那么可以传入第二个参数<code class="calibre15">true</code>：</p>
  <pre class="calibre18"><code class="calibre15">//从键为"007"的对象的下一个对象开始，然后可以移动到最后
var lowerRange = IDBKeyRange.lowerBound("007", true);
</code></pre>

  <p class="calibre2">第三种定义键范围的方式是指定结果集的上界，也就是指定游标不能超越哪个键。指定上界使用<code class="calibre15">upperRange()</code>方法。下面这个键范围可以保证游标从头开始，到取得键为<code class="calibre15">"ace"</code>的对象终止。</p>
  <pre class="calibre18"><code class="calibre15">//从头开始，到键为"ace"的对象为止
var upperRange = IDBKeyRange.upperBound("ace");
</code></pre>

  <p class="calibre2">如果你不想包含键为指定值的对象，同样，传入第二个参数<code class="calibre15">true</code>：</p>
  <pre class="calibre18"><code class="calibre15">//从头开始，到键为"ace"的对象的上一个对象为止
var upperRange = IDBKeyRange.upperBound("ace", true);
</code></pre>

  <p class="calibre2">第四种定义键范围的方式——没错，就是同时指定上、下界，使用<code class="calibre15">bound()</code>方法。这个方法可以接收4个参数：表示下界的键、表示上界的键、可选的表示是否跳过下界的布尔值和可选的表示是否跳过上界的布尔值。以下是几个例子。</p>
  <pre class="calibre18"><code class="calibre15">//从键为"007"的对象开始，到键为"ace"的对象为止
var boundRange = IDBKeyRange.bound("007", "ace");

//从键为"007"的对象的下一个对象开始，到键为"ace"的对象为止
var boundRange = IDBKeyRange.bound("007", "ace", true);

//从键为"007"的对象的下一个对象开始，到键为"ace"的对象的上一个对象为止
var boundRange = IDBKeyRange.bound("007", "ace", true, true);

//从键为"007"的对象开始，到键为"ace"的对象的上一个对象为止
var boundRange = IDBKeyRange.bound("007", "ace", false, true);
</code></pre>

  <p class="calibre2">无论如何，在定义键范围之后，把它传给<code class="calibre15">openCursor()</code>方法，就能得到一个符合相应约束条件的游标。</p>
  <pre class="calibre18">var store = db.transaction("users").objectStore("users"),
    <b class="calibre3">range = IDBKeyRange.bound("007", "ace");</b>
    <b class="calibre3">request = store.openCursor(range);</b>

request.onsuccess = function(event){
    var cursor = event.target.result;
    if (cursor){ //必须要检查
        console.log("Key: " + cursor.key + ", Value: " +
                    JSON.stringify(cursor.value));
        <b class="calibre3">cursor.continue(); //移动到下一项</b>
    <b class="calibre3">} else {</b>
        <b class="calibre3">console.log("Done!");</b>
    <b class="calibre3">}</b>
};
</pre>

  <p class="calibre2">这个例子输出的对象的键为<code class="calibre15">"007"</code>到<code class="calibre15">"ace"</code>，比上一节最后那个例子输出的值少一些。</p>

  <p class="calibre2">6. <strong class="calibre3">设定游标方向</strong></p>

  <p class="calibre2">实际上，<code class="calibre15">openCursor()</code>可以接收两个参数。第一个参数就是刚刚看到的<code class="calibre15">IDBKeyRange</code>的实例，第二个是表示方向的数值常量。作为第二个参数的常量是前面讲查询时介绍的<code class="calibre15">IDBCursor</code>中的常量。Fire fox4 +和Chrome的实现又有不同，因此第一步还是在本地消除差异：</p>
  <pre class="calibre18"><code class="calibre15">var IDBCursor = window.IDBCursor || window.webkitIDBCursor;
</code></pre>

  <p class="calibre2">正常情况下，游标都是从存储空间的第一项开始，调用<code class="calibre15">continue()</code>或<code class="calibre15">advance()</code>前进到最后一项。游标的默认方向值是<code class="calibre15">IDBCursor.NEXT</code>。如果对象存储空间中有重复的项，而你想让游标跳过那些重复的项，可以为<code class="calibre15">openCursor</code>传入<code class="calibre15">IDBCursor.NEXT_NO_DUPLICATE</code>作为第二个参数：</p>
  <pre class="calibre18">var store = db.transaction("users").objectStore("users"),
    <b class="calibre3">request = store.openCursor(null, IDBCursor.NEXT_NO_DUPLICATE);</b>
</pre>

  <p class="calibre2">注意，<code class="calibre15">openCursor()</code>的第一个参数是<code class="calibre15">null</code>，表示使用默认的键范围，即包含所有对象。这个游标可以从存储空间中的第一个对象开始，逐个迭代到最后一个对象——但会跳过重复的对象。</p>

  <p class="calibre2">当然，也可以创建一个游标，让它在对象存储空间中向后移动，即从最后一个对象开始，逐个迭代，直至第一个对象。此时，要传入的常量是<code class="calibre15">IDBCursor.PREV</code>和<code class="calibre15">IDBCursor.PREV_NO_DUPLICATE</code>。例如：</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18">var store = db.transaction("users").objectStore("users"),
    <b class="calibre3">request = store.openCursor(null, IDBCursor.PREV);</b>
</pre>

  <p class="calibre8"><i class="calibre7">IndexedDBExample05.htm</i></p>

  <p class="calibre2">使用<code class="calibre15">IDBCursor.PREV</code>或<code class="calibre15">IDBCursor.PREV_NO_DUPLICATE</code>打开游标时，每次调用<code class="calibre15">continue()</code>或<code class="calibre15">advance()</code>，都会在存储空间中向后而不是向前移动游标。</p>

  <p class="calibre2">7. <strong class="calibre3">索引</strong></p>

  <p class="calibre2">对于某些数据，可能需要为一个对象存储空间指定多个键。比如，若要通过用户ID和用户名两种方式来保存用户资料，就需要通过这两个键来存取记录。为此，可以考虑将用户ID作为主键，然后为用户名创建索引。</p>

  <p class="calibre2">要创建索引，首先引用对象存储空间，然后调用<code class="calibre15">createIndex()</code>方法，如下所示。</p>
  <pre class="calibre18">var store = db.transaction("users").objectStore("users"),
    <b class="calibre3">index = store.createIndex("username", "username", { unique: false});</b>
</pre>

  <p class="calibre2"><code class="calibre15">createIndex()</code>的第一个参数是索引的名字，第二个参数是索引的属性的名字，第三个参数是一个包含<code class="calibre15">unique</code>属性的选项（<code class="calibre15">options</code>）对象。这个选项通常都必须指定，因为它表示键在所有记录中是否唯一。因为username有可能重复，所以这个索引不是唯一的。</p>

  <p class="calibre2"><code class="calibre15">createIndex()</code>的返回值是<code class="calibre15">IDBIndex</code>的实例。在对象存储空间上调用<code class="calibre15">index()</code>方法也能返回同一个实例。例如，要使用一个已经存在的名为<code class="calibre15">"username"</code>的索引，可以像下面这样取得该索引。</p>
  <pre class="calibre18">var store = db.transaction("users").objectStore("users"),
    <b class="calibre3">index = store.index("username");</b>
</pre>

  <p class="calibre2">索引其实与对象存储空间很相似。在索引上调用<code class="calibre15">openCursor()</code>方法也可以创建新的游标，除了将来会把索引键而非主键保存在<code class="calibre15">event.result.key</code>属性中之外，这个游标与在对象存储空间上调用<code class="calibre15">openCursor()</code>返回的游标完全一样。来看下面的例子。</p>
  <pre class="calibre18">var store = db.transaction("users").objectStore("users"),
    <b class="calibre3">index = store.index("username"),</b>
    <b class="calibre3">request = index.openCursor();</b>

request.onsuccess = function(event){
    //处理成功
};
</pre>

  <p class="calibre2">在索引上也能创建一个特殊的只返回每条记录主键的游标，那就要调用<code class="calibre15">openKeyCursor()</code>方法。这个方法接收的参数与<code class="calibre15">openCursor()</code>相同。而最大的不同在于，这种情况下<code class="calibre15">event.result.key</code>中仍然保存着索引键，而<code class="calibre15">event.result.value</code>中保存的则是主键，而不再是整个对象。</p>
  <pre class="calibre18">var store = db.transaction("users").objectStore("users"),
    <b class="calibre3">index = store.index("username"),</b>
    <b class="calibre3">request = index.openKeyCursor();</b>

request.onsuccess = function(event){
    //处理成功
    // event.result.key中保存索引键，而event.result.value中保存主键
};
</pre>

  <p class="calibre2">同样，使用<code class="calibre15">get()</code>方法能够从索引中取得一个对象，只要传入相应的索引键即可；当然，这个方法也将返回一个请求。</p>
  <pre class="calibre18">var store = db.transaction("users").objectStore("users"),
    <b class="calibre3">index = store.index("username"),</b>
    <b class="calibre3">request = index.get("007");</b>

request.onsuccess = function(event){
    //处理成功
};

request.onerror = function(event){
    //处理失败
};
</pre>

  <p class="calibre2">要根据给定的索引键取得主键，可以使用<code class="calibre15">getKey()</code>方法。这个方法也会创建一个新的请求，但<code class="calibre15">event.result.value</code>等于主键的值，而不是包含整个对象。</p>
  <pre class="calibre18">var store = db.transaction("users").objectStore("users"),
    <b class="calibre3">index = store.index("username"),</b>
    <b class="calibre3">request = index.getKey("007");</b>

request.onsuccess = function(event){
    //处理成功
    //event.result.key中保存索引键，而event.result.value中保存主键
};
</pre>

  <p class="calibre2">在这个例子的<code class="calibre15">onsuccess</code>事件处理程序中，<code class="calibre15">event.result.value</code>中保存的是用户ID。</p>

  <p class="calibre2">任何时候，通过<code class="calibre15">IDBIndex</code>对象的下列属性都可以取得有关索引的相关信息。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">name</code>：索引的名字。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">keyPath</code>：传入<code class="calibre15">createIndex()</code>中的属性路径。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">objectStore</code>：索引的对象存储空间。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">unique</code>：表示索引键是否唯一的布尔值。</p>
    </li>
  </ul>

  <p class="calibre2">另外，通过对象存储对象的<code class="calibre15">indexName</code>属性可以访问到为该空间建立的所有索引。通过以下代码就可以知道根据存储的对象建立了哪些索引。</p>
  <pre class="calibre18">var store = db.transaction("users").objectStore("users"),
    <b class="calibre3">indexNames = store.indexNames,</b>
    <b class="calibre3">index,</b>
    <b class="calibre3">i = 0,</b>
    <b class="calibre3">len = indexNames.length;</b>

<b class="calibre3">while(i &lt; len){</b>
    <b class="calibre3">index = store.index(indexNames[i++]);</b>
    <b class="calibre3">console.log("Index name: " + index.name + ", KeyPath: " + index.keyPath +</b>
        <b class="calibre3">", Unique: " + index.unique);</b>
<b class="calibre3">}</b>
</pre>

  <p class="calibre2">以上代码遍历了每个索引，在控制台中输出了它们的信息。</p>

  <p class="calibre2">在对象存储空间上调用<code class="calibre15">deleteIndex()</code>方法并传入索引的名字可以删除索引。</p>
  <pre class="calibre18">var store = db.transaction("users").objectStore("users");
<b class="calibre3">store.deleteIndex("username");</b>
</pre>

  <p class="calibre2">因为删除索引不会影响对象存储空间中的数据，所以这个操作没有任何回调函数。</p>

  <p class="calibre2">8. <strong class="calibre3">并发问题</strong></p>

  <p class="calibre2">虽然网页中的IndexedDB提供的是异步API，但仍然存在并发操作的问题。如果浏览器的两个不同的标签页打开了同一个页面，那么一个页面试图更新另一个页面尚未准备就绪的数据库的问题就有可能发生。把数据库设置为新版本有可能导致这个问题。因此，只有当浏览器中仅有一个标签页使用数据库的情况下，调用<code class="calibre15">setVersion()</code>才能完成操作。</p>

  <p class="calibre2">刚打开数据库时，要记着指定<code class="calibre15">onversionchange</code>事件处理程序。当同一个来源的另一个标签页调用<code class="calibre15">setVersion()</code>时，就会执行这个回调函数。处理这个事件的最佳方式是立即关闭数据库，从而保证版本更新顺利完成。例如：</p>
  <pre class="calibre18">var request, database;

request = indexedDB.open("admin");
request.onsuccess = function(event){ 
    database = event.target.result;

    <b class="calibre3">database.onversionchange = function(){</b>
        <b class="calibre3">database.close();</b>
    <b class="calibre3">};</b>
};
</pre>

  <p class="calibre2">每次成功打开数据库，都应该指定<code class="calibre15">onversionchange</code>事件处理程序。</p>

  <p class="calibre2">调用<code class="calibre15">setVersion()</code>时，指定请求的<code class="calibre15">onblocked</code>事件处理程序也很重要。在你想要更新数据库的版本但另一个标签页已经打开数据库的情况下，就会触发这个事件处理程序。此时，最好先通知用户关闭其他标签页，然后再重新调用<code class="calibre15">setVersion()</code>。例如：</p>
  <pre class="calibre18"><code class="calibre15">var request = database.setVersion("2.0");
request.onblocked = function(){
    alert("Please close all other tabs and try again.");
};

request.onsuccess = function(){
    //处理成功，继续
};
</code></pre>

  <p class="calibre2">请记住，其他标签页中的<code class="calibre15">onversionchange</code>事件处理程序也会执行。</p>

  <p class="calibre2">通过指定这些事件处理程序，就能确保你的Web应用妥善地处理好IndexedDB的并发问题。</p>

  <p class="calibre2">9. <strong class="calibre3">限制</strong></p>

  <p class="calibre2">对IndexedDB的限制很多都与对Web Storage的类似。首先，IndexedDB数据库只能由同源（相同协议、域名和端口）页面操作，因此不能跨域共享信息。换句话说，<code class="calibre15">www.wrox.com</code>与<code class="calibre15">p2p.wrox.com</code>的数据库是完全独立的。</p>

  <p class="calibre2">其次，每个来源的数据库占用的磁盘空间也有限制。Firefox 4+目前的上限是每个源50MB，而Chrome的限制是5MB。移动设备上的Firefox最多允许保存5MB，如果超过了这个配额，将会请求用户的许可。</p>

  <p class="calibre2">Firefox还有另外一个限制，即不允许本地文件访问IndexedDB。Chrome没有这个限制。如果你在本地运行本书的示例，请使用Chrome。</p>
</body>
</html>
