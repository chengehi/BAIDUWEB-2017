<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>未知</title>
  <link href="../Styles/Style.css" rel="stylesheet" type="text/css" />
  <link href="../Styles/custom.css" rel="stylesheet" type="text/css" />
</head>

<body class="calibre">
  <h2 class="calibre9" id="nav_point_22">3.6　语句</h2>

  <p class="calibre2">ECMA-262规定了一组语句（也称为流控制语句）。从本质上看，语句定义了ECMAScript中的主要语法，语句通常使用一或多个关键字来完成给定任务。语句可以很简单，例如通知函数退出；也可以比较复杂，例如指定重复执行某个命令的次数。</p>

  <h3 class="calibre22" id="sigil_toc_id_31"><strong class="calibre10">3.6.1　<code class="calibre30">if</code>语句</strong></h3>

  <p class="calibre2">大多数编程语言中最为常用的一个语句就是<code class="calibre15">if</code>语句。以下是<code class="calibre15">if</code>语句的语法：</p>
  <pre class="calibre18"><code class="calibre15">if (condition) statement1 else statement2
</code></pre>

  <p class="calibre2">其中的condition（条件）可以是任意表达式；而且对这个表达式求值的结果不一定是布尔值。ECMAScript会自动调用<code class="calibre15">Boolean()</code>转换函数将这个表达式的结果转换为一个布尔值。如果对condition求值的结果是<code class="calibre15">true</code>，则执行statement1（语句1），如果对condition求值的结果是<code class="calibre15">false</code>，则执行statement2（语句2）。而且这两个语句既可以是一行代码，也可以是一个代码块（以一对花括号括起来的多行代码）。请看下面的例子。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">if (i &gt; 25)
    alert("Greater than 25.");                  // 单行语句
else {
    alert("Less than or equal to 25.");         // 代码块中的语句
}
</code></pre>

  <p class="calibre8"><i class="calibre7">IfStatementExample01.htm</i></p>

  <p class="calibre2">不过，业界普遍推崇的最佳实践是始终使用代码块，即使要执行的只有一行代码。因为这样可以消除人们的误解，否则可能让人分不清在不同条件下要执行哪些语句。</p>

  <p class="calibre2">另外，也可以像下面这样把整个<code class="calibre15">if</code>语句写在一行代码中：</p>
  <pre class="calibre18"><code class="calibre15">if (condition1) statement1 else if (condition2) statement2 else statement3
</code></pre>

  <p class="calibre2">但我们推荐的做法则是像下面这样：</p>
  <pre class="calibre18"><code class="calibre15">if (i &gt; 25) {
    alert("Greater than 25.");
} else if (i &lt; 0) {
    alert("Less than 0.");
} else {
    alert("Between 0 and 25, inclusive.");
}
</code></pre>

  <p class="calibre8"><i class="calibre7">IfStatementExample02.htm</i></p>

  <h3 class="calibre22" id="sigil_toc_id_32"><strong class="calibre10">3.6.2　<code class="calibre30">do-while</code>语句</strong></h3>

  <p class="calibre2"><code class="calibre15">do-while</code>语句是一种后测试循环语句，即只有在循环体中的代码执行之后，才会测试出口条件。换句话说，在对条件表达式求值之前，循环体内的代码至少会被执行一次。以下是<code class="calibre15">do-while</code>语句的 语法：</p>
  <pre class="calibre18"><code class="calibre15">do {
    statement
} while (expression);
</code></pre>

  <p class="calibre2">下面是一个示例：</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">var i = 0;
do {
   i += 2;
} while (i &lt; 10);

alert(i);
</code></pre>

  <p class="calibre8"><i class="calibre7">DoWhileStatementExample01.htm</i></p>

  <p class="calibre2">在这个例子中，只要变量<code class="calibre15">i</code>的值小于10，循环就会一直继续下去。而且变量<code class="calibre15">i</code>的值最初为0，每次循环都会递增2。</p>

  <blockquote class="calibre14">
    <p class="calibre2"><img alt="" class="calibre17" src="../Images/00002.gif" /> 像<code class="calibre15">do-while</code>这种后测试循环语句最常用于循环体中的代码至少要被执行一次的情形。</p>
  </blockquote>

  <h3 class="calibre22" id="sigil_toc_id_33"><strong class="calibre10">3.6.3　<code class="calibre30">while</code>语句</strong></h3>

  <p class="calibre2"><code class="calibre15">while</code>语句属于前测试循环语句，也就是说，在循环体内的代码被执行之前，就会对出口条件求值。因引，循环体内的代码有可能永远不会被执行。以下是<code class="calibre15">while</code>语句的语法：</p>
  <pre class="calibre18"><code class="calibre15">while(expression) statement
</code></pre>

  <p class="calibre2">下面是一个示例：</p>
  <pre class="calibre18"><code class="calibre15">var i = 0;
while (i &lt; 10) {
    i += 2;
}
</code></pre>

  <p class="calibre8"><i class="calibre7">WhileStatementExample01.htm</i></p>

  <p class="calibre2">在这个例子中，变量<code class="calibre15">i</code>开始时的值为0，每次循环都会递增2。而只要<code class="calibre15">i</code>的值小于10，循环就会继续下去。</p>

  <h3 class="calibre22" id="sigil_toc_id_34"><strong class="calibre10">3.6.4　<code class="calibre30">for</code>语句</strong></h3>

  <p class="calibre2"><code class="calibre15">for</code>语句也是一种前测试循环语句，但它具有在执行循环之前初始化变量和定义循环后要执行的代码的能力。以下是<code class="calibre15">for</code>语句的语法：</p>
  <pre class="calibre18"><code class="calibre15">for (initialization; expression; post-loop-expression) statement
</code></pre>

  <p class="calibre2">下面是一个示例：</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">var count = 10;
for (var i = 0; i &lt; count; i++){
    alert(i);
}
</code></pre>

  <p class="calibre8"><i class="calibre7">ForStatementExample01.htm</i></p>

  <p class="calibre2">以上代码定义了变量<code class="calibre15">i</code>的初始值为0。只有当条件表达式（<code class="calibre15">i&lt;count</code>）返回<code class="calibre15">true</code>的情况下才会进入<code class="calibre15">for</code>循环，因此也有可能不会执行循环体中的代码。如果执行了循环体中的代码，则一定会对循环后的表达式（<code class="calibre15">i++</code>）求值，即递增<code class="calibre15">i</code>的值。这个<code class="calibre15">for</code>循环语句与下面的<code class="calibre15">while</code>语句的功能相同：</p>
  <pre class="calibre18"><code class="calibre15">var count = 10;
var i = 0;
while (i &lt; count){
    alert(i);
    i++;
}
</code></pre>

  <p class="calibre2">使用<code class="calibre15">while</code>循环做不到的，使用<code class="calibre15">for</code>循环同样也做不到。也就是说，<code class="calibre15">for</code>循环只是把与循环有关的代码集中在了一个位置。</p>

  <p class="calibre2">有必要指出的是，在<code class="calibre15">for</code>循环的变量初始化表达式中，也可以不使用<code class="calibre15">var</code>关键字。该变量的初始化可以在外部执行，例如：</p>
  <pre class="calibre18">var count = 10;
<b class="calibre3">var i;</b>
<b class="calibre3">for (i = 0; i &lt; count; i++){</b>
    alert(i);
}
</pre>

  <p class="calibre8"><i class="calibre7">ForStatementExample02.htm</i></p>

  <p class="calibre2">以上代码与在循环初始化表达式中声明变量的效果是一样的。由于ECMAScript中不存在块级作用域（第4章将进一步讨论这一点），因此在循环内部定义的变量也可以在外部访问到。例如：</p>
  <pre class="calibre18">var count = 10;
for (var i = 0; i &lt; count; i++){
    alert(i);
}
<b class="calibre3">alert(i);    //10</b>
</pre>

  <p class="calibre8"><i class="calibre7">ForStatementExample03.htm</i></p>

  <p class="calibre2">在这个例子中，会有一个警告框显示循环完成后变量<code class="calibre15">i</code>的值，这个值是10。这是因为，即使<code class="calibre15">i</code>是在循环内部定义的一个变量，但在循环外部仍然可以访问到它。</p>

  <p class="calibre2">此外，<code class="calibre15">for</code>语句中的初始化表达式、控制表达式和循环后表达式都是可选的。将这两个表达式全部省略，就会创建一个无限循环，例如：</p>
  <pre class="calibre18"><code class="calibre15">for (;;) {     // 无限循环
    doSomething();
}
</code></pre>

  <p class="calibre2">而只给出控制表达式实际上就把<code class="calibre15">for</code>循环转换成了<code class="calibre15">while</code>循环，例如：</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">var count = 10;
var i = 0;
for (; i &lt; count; ){
    alert(i);
    i++;
}
</code></pre>

  <p class="calibre8"><i class="calibre7">ForStatementExample04.htm</i></p>

  <p class="calibre2">由于<code class="calibre15">for</code>语句存在极大的灵活性，因此它也是ECMAScript中最常用的一个语句。</p>

  <h3 class="calibre22" id="sigil_toc_id_35"><strong class="calibre10">3.6.5　<code class="calibre30">for-in</code>语句</strong></h3>

  <p class="calibre2"><code class="calibre15">for-in</code>语句是一种精准的迭代语句，可以用来枚举对象的属性。以下是<code class="calibre15">for-in</code>语句的语法：</p>
  <pre class="calibre18"><code class="calibre15">for (property in expression) statement
</code></pre>

  <p class="calibre2">下面是一个示例：</p>
  <pre class="calibre18"><code class="calibre15">for (var propName in window) {
     document.write(propName);
}
</code></pre>

  <p class="calibre8"><i class="calibre7">ForInStatementExample01.htm</i></p>

  <p class="calibre2">在这个例子中，我们使用<code class="calibre15">for-in</code>循环来显示了BOM中<code class="calibre15">window</code>对象的所有属性。每次执行循环时，都会将<code class="calibre15">window</code>对象中存在的一个属性名赋值给变量<code class="calibre15">propName</code>。这个过程会一直持续到对象中的所有属性都被枚举一遍为止。与<code class="calibre15">for</code>语句类似，这里控制语句中的<code class="calibre15">var</code>操作符也不是必需的。但是，为了保证使用局部变量，我们推荐上面例子中的这种做法。</p>

  <p class="calibre2">ECMAScript对象的属性没有顺序。因此，通过<code class="calibre15">for-in</code>循环输出的属性名的顺序是不可预测的。具体来讲，所有属性都会被返回一次，但返回的先后次序可能会因浏览器而异。</p>

  <p class="calibre2">但是，如果表示要迭代的对象的变量值为<code class="calibre15">null</code>或<code class="calibre15">undefined</code>，<code class="calibre15">for-in</code>语句会抛出错误。ECMAScript 5更正了这一行为；对这种情况不再抛出错误，而只是不执行循环体。为了保证最大限度的兼容性，建议在使用<code class="calibre15">for-in</code>循环之前，先检测确认该对象的值不是<code class="calibre15">null</code>或<code class="calibre15">undefined</code>。</p>

  <blockquote class="calibre14">
    <p class="calibre2"><img alt="" class="calibre17" src="../Images/00002.gif" /> Safari 3以前版本的<strong class="calibre3"><code class="calibre15">for-in</code></strong>语句中存在一个bug，该bug会导致某些属性被返回两次。</p>
  </blockquote>

  <h3 class="calibre22" id="sigil_toc_id_36"><strong class="calibre10">3.6.6　<code class="calibre30">label</code>语句</strong></h3>

  <p class="calibre2">使用<code class="calibre15">label</code>语句可以在代码中添加标签，以便将来使用。以下是<code class="calibre15">label</code>语句的语法：</p>
  <pre class="calibre18"><code class="calibre15">label: statement
</code></pre>

  <p class="calibre2">下面是一个示例：</p>
  <pre class="calibre18"><code class="calibre15">start: for (var i=0; i &lt; count; i++) {
    alert(i); 
}
</code></pre>

  <p class="calibre2">这个例子中定义的<code class="calibre15">start</code>标签可以在将来由<code class="calibre15">break</code>或<code class="calibre15">continue</code>语句引用。加标签的语句一般都要与<code class="calibre15">for</code>语句等循环语句配合使用。</p>

  <h3 class="calibre22" id="sigil_toc_id_37"><strong class="calibre10">3.6.7　<code class="calibre30">break</code>和<code class="calibre30">continue</code>语句</strong></h3>

  <p class="calibre2"><code class="calibre15">break</code>和<code class="calibre15">continue</code>语句用于在循环中精确地控制代码的执行。其中，<code class="calibre15">break</code>语句会立即退出循环，强制继续执行循环后面的语句。而<code class="calibre15">continue</code>语句虽然也是立即退出循环，但退出循环后会从循环的顶部继续执行。请看下面的例子：</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">var num = 0;

for (var i=1; i &lt; 10; i++) {
    if (i % 5 == 0) {
       break;
    }
    num++;
}

alert(num);    //4
</code></pre>

  <p class="calibre8"><i class="calibre7">BreakStatementExample01.htm</i></p>

  <p class="calibre2">这个例子中的<code class="calibre15">for</code>循环会将变量<code class="calibre15">i</code>由1递增至10。在循环体内，有一个<code class="calibre15">if</code>语句检查<code class="calibre15">i</code>的值是否可以被5整除（使用求模操作符）。如果是，则执行<code class="calibre15">break</code>语句退出循环。另一方面，变量<code class="calibre15">num</code>从0开始，用于记录循环执行的次数。在执行<code class="calibre15">break</code>语句之后，要执行的下一行代码是<code class="calibre15">alert()</code>函数，结果显示4。也就是说，在变量<code class="calibre15">i</code>等于5时，循环总共执行了4次；而<code class="calibre15">break</code>语句的执行，导致了循环在<code class="calibre15">num</code>再次递增之前就退出了。如果在这里把<code class="calibre15">break</code>替换为<code class="calibre15">continue</code>的话，则可以看到另一种结果：</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18">var num = 0;

for (var i=1; i &lt; 10; i++) {
    if (i % 5 == 0) {
        <b class="calibre3">continue;</b>
    }
    num++;
}

alert(num);    //8
</pre>

  <p class="calibre8"><i class="calibre7">ContinueStatementExample01.htm</i></p>

  <p class="calibre2">例子的结果显示8，也就是循环总共执行了8次。当变量<code class="calibre15">i</code>等于5时，循环会在<code class="calibre15">num</code>再次递增之前退出，但接下来执行的是下一次循环，即<code class="calibre15">i</code>的值等于6的循环。于是，循环又继续执行，直到<code class="calibre15">i</code>等于10时自然结束。而<code class="calibre15">num</code>的最终值之所以是8，是因为<code class="calibre15">continue</code>语句导致它少递增了一次。</p>

  <p class="calibre2"><code class="calibre15">break</code>和<code class="calibre15">continue</code>语句都可以与<code class="calibre15">label</code>语句联合使用，从而返回代码中特定的位置。这种联合使用的情况多发生在循环嵌套的情况下，如下面的例子所示：</p>
  <pre class="calibre18"><code class="calibre15">var num = 0;

outermost:
for (var i=0; i &lt; 10; i++) {
     for (var j=0; j &lt; 10; j++) {
        if (i == 5 &amp;&amp; j == 5) {
            break outermost;
        }
        num++;
    }
}

alert(num);    //55
</code></pre>

  <p class="calibre8"><i class="calibre7">BreakStatementExample02.htm</i></p>

  <p class="calibre2">在这个例子中，<code class="calibre15">outermost</code>标签表示外部的<code class="calibre15">for</code>语句。如果每个循环正常执行10次，则<code class="calibre15">num++</code>语句就会正常执行100次。换句话说，如果两个循环都自然结束，<code class="calibre15">num</code>的值应该是100。但内部循环中的<code class="calibre15">break</code>语句带了一个参数：要返回到的标签。添加这个标签的结果将导致<code class="calibre15">break</code>语句不仅会退出内部的for语句（即使用变量<code class="calibre15">j</code>的循环），而且也会退出外部的<code class="calibre15">for</code>语句（即使用变量<code class="calibre15">i</code>的循环）。为此，当变量<code class="calibre15">i</code>和<code class="calibre15">j</code>都等于5时，<code class="calibre15">num</code>的值正好是55。同样，<code class="calibre15">continue</code>语句也可以像这样与<code class="calibre15">label</code>语句联用，如下面的例子所示：</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18">var num = 0;

outermost:
for (var i=0; i &lt; 10; i++) {
    for (var j=0; j &lt; 10; j++) {
        if (i == 5 &amp;&amp; j == 5) {
            <b class="calibre3">continue outermost;</b>
        }
        num++;
    }
}

alert(num);    //95
</pre>

  <p class="calibre8"><i class="calibre7">ContinueStatementExample02.htm</i></p>

  <p class="calibre2">在这种情况下，<code class="calibre15">continue</code>语句会强制继续执行循环——退出内部循环，执行外部循环。当<code class="calibre15">j</code>是5时，<code class="calibre15">continue</code>语句执行，而这也就意味着内部循环少执行了5次，因此<code class="calibre15">num</code>的结果是95。</p>

  <p class="calibre2">虽然联用<code class="calibre15">break</code>、<code class="calibre15">continue</code>和<code class="calibre15">label</code>语句能够执行复杂的操作，但如果使用过度，也会给调试带来麻烦。在此，我们建议如果使用<code class="calibre15">label</code>语句，一定要使用描述性的标签，同时不要嵌套过多的循环。</p>

  <h3 class="calibre22" id="sigil_toc_id_38"><strong class="calibre10">3.6.8　<code class="calibre30">with</code>语句</strong></h3>

  <p class="calibre2"><code class="calibre15">with</code>语句的作用是将代码的作用域设置到一个特定的对象中。<code class="calibre15">with</code>语句的语法如下：</p>
  <pre class="calibre18"><code class="calibre15">with (expression) statement;
</code></pre>

  <p class="calibre2">定义<code class="calibre15">with</code>语句的目的主要是为了简化多次编写同一个对象的工作，如下面的例子所示：</p>
  <pre class="calibre18"><code class="calibre15">var qs = location.search.substring(1);
var hostName = location.hostname;
var url = location.href;
</code></pre>

  <p class="calibre2">上面几行代码都包含<code class="calibre15">location</code>对象。如果使用<code class="calibre15">with</code>语句，可以把上面的代码改写成如下所示：</p>
  <pre class="calibre18"><code class="calibre15">with(location){
    var qs = search.substring(1);
    var hostName = hostname;
    var url = href;
}
</code></pre>

  <p class="calibre8"><i class="calibre7">WithStatementExample01.htm</i></p>

  <p class="calibre2">在这个重写后的例子中，使用<code class="calibre15">with</code>语句关联了<code class="calibre15">location</code>对象。这意味着在<code class="calibre15">with</code>语句的代码块内部，每个变量首先被认为是一个局部变量，而如果在局部环境中找不到该变量的定义，就会查询<code class="calibre15">location</code>对象中是否有同名的属性。如果发现了同名属性，则以<code class="calibre15">location</code>对象属性的值作为变量的值。</p>

  <p class="calibre2">严格模式下不允许使用<code class="calibre15">with</code>语句，否则将视为语法错误。</p>

  <blockquote class="calibre14">
    <p class="calibre2"><img alt="" class="calibre17" src="../Images/00001.gif" /> 由于大量使用<strong class="calibre3"><code class="calibre15">with</code></strong>语句会导致性能下降，同时也会给调试代码造成困难，因此在开发大型应用程序时，不建议使用<strong class="calibre3"><code class="calibre15">with</code></strong>语句。</p>
  </blockquote>

  <h3 class="calibre22" id="sigil_toc_id_39"><strong class="calibre10">3.6.9　<code class="calibre30">switch</code>语句</strong></h3>

  <p class="calibre2"><code class="calibre15">switch</code>语句与<code class="calibre15">if</code>语句的关系最为密切，而且也是在其他语言中普遍使用的一种流控制语句。ECMAScript中<code class="calibre15">switch</code>语句的语法与其他基于C的语言非常接近，如下所示：</p>
  <pre class="calibre18"><code class="calibre15">switch (expression) {
  case value: statement
    break;
  case value: statement
    break;
  case value: statement
    break;
  case value: statement
    break;
  default: statement
}
</code></pre>

  <p class="calibre2"><code class="calibre15">switch</code>语句中的每一种情形（case）的含义是：“如果表达式等于这个值（value），则执行后面的语句（statement）”。而<code class="calibre15">break</code>关键字会导致代码执行流跳出<code class="calibre15">switch</code>语句。如果省略<code class="calibre15">break</code>关键字，就会导致执行完当前case后，继续执行下一个case。最后的<code class="calibre15">default</code>关键字则用于在表达式不匹配前面任何一种情形的时候，执行机动代码（因此，也相当于一个<code class="calibre15">else</code>语句）。</p>

  <p class="calibre2">从根本上讲，<code class="calibre15">switch</code>语句就是为了让开发人员免于编写像下面这样的代码：</p>
  <pre class="calibre18"><code class="calibre15">if (i == 25){
  alert("25");
} else if (i == 35) {
  alert("35");
} else if (i == 45) {
  alert("45");
} else {
  alert("Other");
}
</code></pre>

  <p class="calibre2">而与此等价的<code class="calibre15">switch</code>语句如下所示：</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">switch (i) {
    case 25: 
        alert("25");
        break;
    case 35: 
        alert("35");
        break;
    case 45: 
        alert("45");
        break;
    default: 
        alert("Other");
}
</code></pre>

  <p class="calibre8"><i class="calibre7">SwitchStatementExample01.htm</i></p>

  <p class="calibre2">通过为每个case后面都添加一个<code class="calibre15">break</code>语句，就可以避免同时执行多个case代码的情况。假如确实需要混合几种情形，不要忘了在代码中添加注释，说明你是有意省略了<code class="calibre15">break</code>关键字，如下所示：</p>
  <pre class="calibre18">switch (i) {
    case 25: 
        <b class="calibre3">/* 合并两种情形 */</b>
    case 35: 
        alert("25 or 35");
        break;
    case 45: 
        alert("45");
        break;
    default: 
        alert("Other");
}
</pre>

  <p class="calibre8"><i class="calibre7">SwitchStatementExample02.htm</i></p>

  <p class="calibre2">虽然ECMAScript中的<code class="calibre15">switch</code>语句借鉴自其他语言，但这个语句也有自己的特色。首先，可以在<code class="calibre15">switch</code>语句中使用任何数据类型（在很多其他语言中只能使用数值），无论是字符串，还是对象都没有问题。其次，每个case的值不一定是常量，可以是变量，甚至是表达式。请看下面这个例子：</p>
  <pre class="calibre18"><code class="calibre15">switch ("hello world") {
    case "hello" + " world": 
        alert("Greeting was found.");
        break;
    case "goodbye": 
        alert("Closing was found.");
        break;
    default: 
        alert("Unexpected message was found.");
}
</code></pre>

  <p class="calibre8"><i class="calibre7">SwitchStatementExample03.htm</i></p>

  <p class="calibre2">在这个例子中，<code class="calibre15">switch</code>语句使用的就是字符串。其中，第一种情形实际上是一个对字符串拼接操作求值的表达式。由于这个字符串拼接表达式的结果与<code class="calibre15">switch</code>的参数相等，因此结果就会显示<code class="calibre15">"Greeting was found."</code>。而且，使用表达式作为case值还可以实现下列操作：</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">var num = 25;
switch (true) {
    case num &lt; 0: 
        alert("Less than 0.");
        break;
    case num &gt;= 0 &amp;&amp; num &lt;= 10: 
        alert("Between 0 and 10.");
        break;
    case num &gt; 10 &amp;&amp; num &lt;= 20: 
        alert("Between 10 and 20.");
        break;
    default: 
        alert("More than 20.");
}
</code></pre>

  <p class="calibre8"><i class="calibre7">SwitchStatementExample04.htm</i></p>

  <p class="calibre2">这个例子首先在<code class="calibre15">switch</code>语句外面声明了变量<code class="calibre15">num</code>。而之所以给<code class="calibre15">switch</code>语句传递表达式<code class="calibre15">true</code>，是因为每个case值都可以返回一个布尔值。这样，每个case按照顺序被求值，直到找到匹配的值或者遇到<code class="calibre15">default</code>语句为止（这正是这个例子的最终结果）。</p>

  <blockquote class="calibre14">
    <p class="calibre2"><img alt="" class="calibre17" src="../Images/00002.gif" /> <code class="calibre15">switch</code>语句在比较值时使用的是全等操作符，因此不会发生类型转换（例如，字符串<code class="calibre15">"10"</code>不等于数值10）。</p>
  </blockquote>
</body>
</html>
