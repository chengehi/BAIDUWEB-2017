<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>未知</title>
  <link href="../Styles/Style.css" rel="stylesheet" type="text/css" />
  <link href="../Styles/custom.css" rel="stylesheet" type="text/css" />
</head>

<body class="calibre">
  <h2 class="calibre9" id="nav_point_87">12.2　样式</h2>

  <p class="calibre2">在HTML中定义样式的方式有3种：通过<code class="calibre15">&lt;link/&gt;</code>元素包含外部样式表文件、使用<code class="calibre15">&lt;style/&gt;</code>元素定义嵌入式样式，以及使用<code class="calibre15">style</code>特性定义针对特定元素的样式。“DOM2级样式”模块围绕这3种应用样式的机制提供了一套API。要确定浏览器是否支持DOM2级定义的CSS能力，可以使用下列代码。</p>
  <pre class="calibre18"><code class="calibre15">var supportsDOM2CSS = document.implementation.hasFeature("CSS", "2.0");
var supportsDOM2CSS2 = document.implementation.hasFeature("CSS2", "2.0");
</code></pre>

  <h3 class="calibre22" id="sigil_toc_id_134"><strong class="calibre10">12.2.1　访问元素的样式</strong></h3>

  <p class="calibre2">任何支持<code class="calibre15">style</code>特性的HTML元素在JavaScript中都有一个对应的<code class="calibre15">style</code>属性。这个<code class="calibre15">style</code>对象是<code class="calibre15">CSSStyleDeclaration</code>的实例，包含着通过HTML的<code class="calibre15">style</code>特性指定的所有样式信息，但不包含与外部样式表或嵌入样式表经层叠而来的样式。在<code class="calibre15">style</code>特性中指定的任何CSS属性都将表现为这个<code class="calibre15">style</code>对象的相应属性。对于使用短划线（分隔不同的词汇，例如<code class="calibre15">background-image</code>）的CSS属性名，必须将其转换成驼峰大小写形式，才能通过JavaScript来访问。下表列出了几个常见的CSS属性及其在<code class="calibre15">style</code>对象中对应的属性名。</p>

  <table class="table">
    <tbody class="calibre23">
      <tr class="calibre24">
        <th class="calibre25" width="50%">CSS属性</th>

        <th class="calibre25" width="50%">JavaScript属性</th>
      </tr>

      <tr class="calibre26">
        <td class="calibre27"><code class="calibre31">background-image</code></td>

        <td class="calibre27"><code class="calibre31">style.backgroundImage</code></td>
      </tr>

      <tr class="calibre24">
        <td class="calibre27"><code class="calibre31">color</code></td>

        <td class="calibre27"><code class="calibre31">style.color</code></td>
      </tr>

      <tr class="calibre26">
        <td class="calibre27"><code class="calibre31">display</code></td>

        <td class="calibre27"><code class="calibre31">style.display</code></td>
      </tr>

      <tr class="calibre24">
        <td class="calibre27"><code class="calibre31">font-family</code></td>

        <td class="calibre27"><code class="calibre31">style.fontFamily</code></td>
      </tr>
    </tbody>
  </table>

  <p class="calibre2">多数情况下，都可以通过简单地转换属性名的格式来实现转换。其中一个不能直接转换的CSS属性就是<code class="calibre15">float</code>。由于<code class="calibre15">float</code>是JavaScript中的保留字，因此不能用作属性名。“DOM2级样式”规范规定样式对象上相应的属性名应该是<code class="calibre15">cssFloat</code>；Firefox、Safari、Opera和Chrome都支持这个属性，而IE支持的则是<code class="calibre15">styleFloat</code>。</p>

  <p class="calibre2">只要取得一个有效的DOM元素的引用，就可以随时使用JavaScript为其设置样式。以下是几个例子。</p>
  <pre class="calibre18"><code class="calibre15">var myDiv = document.getElementById("myDiv");

//设置背景颜色
myDiv.style.backgroundColor = "red";

//改变大小
myDiv.style.width = "100px";
myDiv.style.height = "200px";

//指定边框
myDiv.style.border = "1px solid black";
</code></pre>

  <p class="calibre2">在以这种方式改变样式时，元素的外观会自动被更新。</p>

  <blockquote class="calibre14">
    <p class="calibre2"><img alt="" class="calibre17" src="../Images/00002.gif" /> 在标准模式下，所有度量值都必须指定一个度量单位。在混杂模式下，可以将<code class="calibre15">style.width</code>设置为<code class="calibre15">"20"</code>，浏览器会假设它是<code class="calibre15">"20px"</code>；但在标准模式下，将<code class="calibre15">style.width</code>设置为<code class="calibre15">"20"</code>会导致被忽略——因为没有度量单位。在实践中，最好始终都指定度量单位。</p>
  </blockquote>

  <p class="calibre2">通过<code class="calibre15">style</code>对象同样可以取得在<code class="calibre15">style</code>特性中指定的样式。以下面的HTML代码为例。</p>
  <pre class="calibre18"><code class="calibre15">&lt;div id="myDiv" style="background-color:blue; width:10px; height:25px"&gt;&lt;/div&gt;
</code></pre>

  <p class="calibre2">在<code class="calibre15">style</code>特性中指定的样式信息可以通过下列代码取得。</p>
  <pre class="calibre18"><code class="calibre15">alert(myDiv.style.backgroundColor);        //"blue"
alert(myDiv.style.width);                  //"10px"
alert(myDiv.style.height);                 //"25px"
</code></pre>

  <p class="calibre2">如果没有为元素设置<code class="calibre15">style</code>特性，那么<code class="calibre15">style</code>对象中可能会包含一些默认的值，但这些值并不能准确地反映该元素的样式信息。</p>

  <p class="calibre2">1. <strong class="calibre3">DOM样式属性和方法</strong></p>

  <p class="calibre2">“DOM2级样式”规范还为<code class="calibre15">style</code>对象定义了一些属性和方法。这些属性和方法在提供元素的<code class="calibre15">style</code>特性值的同时，也可以修改样式。下面列出了这些属性和方法。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">cssText</code>：如前所述，通过它能够访问到<code class="calibre15">style</code>特性中的CSS代码。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">length</code>：应用给元素的CSS属性的数量。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">parentRule</code>：表示CSS信息的<code class="calibre15">CSSRule</code>对象。本节后面将讨论<code class="calibre15">CSSRule</code>类型。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">getPropertyCSSValue(<em class="calibre7">propertyName</em>)</code>：返回包含给定属性值的<code class="calibre15">CSSValue</code>对象。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">getPropertyPriority(<em class="calibre7">propertyName</em>)</code>：如果给定的属性使用了<code class="calibre15">!important</code>设置，则返回<code class="calibre15">"important"</code>；否则，返回空字符串。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">getPropertyValue(<em class="calibre7">propertyName</em>)</code>：返回给定属性的字符串值。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">item(<em class="calibre7">index</em>)</code>：返回给定位置的CSS属性的名称。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">removeProperty(<em class="calibre7">propertyName</em>)</code>：从样式中删除给定属性。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">setProperty(<em class="calibre7">propertyName,value,priority</em>)</code>：将给定属性设置为相应的值，并加上优先权标志（<code class="calibre15">"important"</code>或者一个空字符串）。</p>
    </li>
  </ul>

  <p class="calibre2">通过<code class="calibre15">cssText</code>属性可以访问style特性中的CSS代码。在读取模式下，<code class="calibre15">cssText</code>返回浏览器对<code class="calibre15">style</code>特性中CSS代码的内部表示。在写入模式下，赋给<code class="calibre15">cssText</code>的值会重写整个<code class="calibre15">style</code>特性的值；也就是说，以前通过<code class="calibre15">style</code>特性指定的样式信息都将丢失。例如，如果通过<code class="calibre15">style</code>特性为元素设置了边框，然后再以不包含边框的规则重写<code class="calibre15">cssText</code>，那么就会抹去元素上的边框。下面是使用<code class="calibre15">cssText</code>属性的一个例子。</p>
  <pre class="calibre18"><code class="calibre15">myDiv.style.cssText = "width: 25px; height: 100px; background-color: green";
alert(myDiv.style.cssText);
</code></pre>

  <p class="calibre2">设置<code class="calibre15">cssText</code>是为元素应用多项变化最快捷的方式，因为可以一次性地应用所有变化。</p>

  <p class="calibre2">设计<code class="calibre15">length</code>属性的目的，就是将其与<code class="calibre15">item()</code>方法配套使用，以便迭代在元素中定义的CSS属性。在使用<code class="calibre15">length</code>和<code class="calibre15">item()</code>时，<code class="calibre15">style</code>对象实际上就相当于一个集合，都可以使用方括号语法来代替<code class="calibre15">item()</code>来取得给定位置的CSS属性，如下面的例子所示。</p>
  <pre class="calibre18"><code class="calibre15">for (var i=0, len=myDiv.style.length; i &lt; len; i++){
    alert(myDiv.style[i]); //或者myDiv.style.item(i)
}
</code></pre>

  <p class="calibre2">无论是使用方括号语法还是使用<code class="calibre15">item()</code>方法，都可以取得CSS属性名（<code class="calibre15">"background-color"</code>，不是<code class="calibre15">"backgroundColor"</code>）。然后，就可以在<code class="calibre15">getPropertyValue()</code>中使用了取得的属性名进一步取得属性的值，如下所示。</p>
  <pre class="calibre18"><b class="calibre3">var prop, value, i, len;</b>
for (i=0, len=myDiv.style.length; i &lt; len; i++){
    <b class="calibre3">prop = myDiv.style[i];    //或者 myDiv.style.item(i)</b>
    <b class="calibre3">value = myDiv.style.getPropertyValue(prop);</b>
    <b class="calibre3">alert(prop + " : " + value);</b>
}
</pre>

  <p class="calibre2"><code class="calibre15">getPropertyValue()</code>方法取得的始终都是CSS属性值的字符串表示。如果你需要更多信息，可以使用<code class="calibre15">getPropertyCSSValue()</code>方法，它返回一个包含两个属性的<code class="calibre15">CSSValue</code>对象，这两个属性分别是：<code class="calibre15">cssText</code>和<code class="calibre15">cssValueType</code>。其中，<code class="calibre15">cssText</code>属性的值与<code class="calibre15">getPropertyValue()</code>返回的值相同，而<code class="calibre15">cssValueType</code>属性则是一个数值常量，表示值的类型：0表示继承的值，1表示基本的值，2表示值列表，3表示自定义的值。以下代码既输出CSS属性值，也输出值的类型。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18">var prop, value, i, len;
for (i=0, len=myDiv.style.length; i &lt; len; i++){
    prop = myDiv.style[i]; //或者myDiv.style.item(i)
    <b class="calibre3">value = myDiv.style.getPropertyCSSValue(prop);</b>
    <b class="calibre3">alert(prop + " : " + value.cssText + " (" + value.cssValueType + ")");</b>
}
</pre>

  <p class="calibre8"><i class="calibre7">DOMStyleObjectExample.htm</i></p>

  <p class="calibre2">在实际开发中，<code class="calibre15">getPropertyCSSValue()</code>使用得比<code class="calibre15">getPropertyValue()</code>少得多。IE9+、Safarie 3+以及Chrome支持这个方法。Firefox 7及之前版本也提供这个访问，但调用总返回<code class="calibre15">null</code>。</p>

  <p class="calibre2">要从元素的样式中移除某个CSS属性，需要使用<code class="calibre15">removeProperty()</code>方法。使用这个方法移除一个属性，意味着将会为该属性应用默认的样式（从其他样式表经层叠而来）。例如，要移除通过<code class="calibre15">style</code>特性设置的<code class="calibre15">border</code>属性，可以使用下面的代码。</p>
  <pre class="calibre18"><code class="calibre15">myDiv.style.removeProperty("border");
</code></pre>

  <p class="calibre2">在不确定某个给定的CSS属性拥有什么默认值的情况下，就可以使用这个方法。只要移除相应的属性，就可以为元素应用默认值。</p>

  <blockquote class="calibre14">
    <p class="calibre2"><img alt="" class="calibre17" src="../Images/00002.gif" /> 除非另有说明，本节讨论的属性和方法都得到了IE9+、Firefox、Safari、Opera 9+以及Chrome的支持。</p>
  </blockquote>

  <p class="calibre2">2. <strong class="calibre3">计算的样式</strong></p>

  <p class="calibre2">虽然<code class="calibre15">style</code>对象能够提供支持<code class="calibre15">style</code>特性的任何元素的样式信息，但它不包含那些从其他样式表层叠而来并影响到当前元素的样式信息。“DOM2级样式”增强了<code class="calibre15">document.defaultView</code>，提供了<code class="calibre15">getComputedStyle()</code>方法。这个方法接受两个参数：要取得计算样式的元素和一个伪元素字符串（例如<code class="calibre15">":after"</code>）。如果不需要伪元素信息，第二个参数可以是<code class="calibre15">null</code>。<code class="calibre15">getComputedStyle()</code>方法返回一个<code class="calibre15">CSSStyleDeclaration</code>对象（与<code class="calibre15">style</code>属性的类型相同），其中包含当前元素的所有计算的样式。以下面这个HTML页面为例。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Computed Styles Example&lt;/title&gt;
    &lt;style type="text/css"&gt;
        #myDiv {
            background-color: blue;
            width: 100px;
            height: 200px;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="myDiv" style="background-color: red; border: 1px solid black"&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

  <p class="calibre8"><i class="calibre7">ComputedStylesExample.htm</i></p>

  <p class="calibre2">应用给这个例子中<code class="calibre15">&lt;div&gt;</code>元素的样式一方面来自嵌入式样式表（<code class="calibre15">&lt;style&gt;</code>元素中的样式），另一方面来自其<code class="calibre15">style</code>特性。但是，<code class="calibre15">style</code>特性中设置了<code class="calibre15">backgroundColor</code>和<code class="calibre15">border</code>，没有设置<code class="calibre15">width</code>和<code class="calibre15">height</code>，后者是通过样式表规则应用的。以下代码可以取得这个元素计算后的样式。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">var myDiv = document.getElementById("myDiv");
var computedStyle = document.defaultView.getComputedStyle(myDiv, null);

alert(computedStyle.backgroundColor);   // "red"
alert(computedStyle.width);             // "100px"
alert(computedStyle.height);            // "200px"
alert(computedStyle.border);            // 在某些浏览器中是"1px solid black"
</code></pre>

  <p class="calibre8"><i class="calibre7">ComputedStylesExample.htm</i></p>

  <p class="calibre2">在这个元素计算后的样式中，背景颜色的值是<code class="calibre15">"red"</code>，宽度值是<code class="calibre15">"100px"</code>，高度值是<code class="calibre15">"200px"</code>。我们注意到，背景颜色不是<code class="calibre15">"blue"</code>，因为这个样式在自身的<code class="calibre15">style</code>特性中已经被覆盖了。边框属性可能会也可能不会返回样式表中实际的<code class="calibre15">border</code>规则（Opera会返回，但其他浏览器不会）。存在这个差别的原因是不同浏览器解释综合（rollup）属性（如<code class="calibre15">border</code>）的方式不同，因为设置这种属性实际上会涉及很多其他属性。在设置<code class="calibre15">border</code>时，实际上是设置了四个边的边框宽度、颜色、样式属性（<code class="calibre15">border-left-width</code>、<code class="calibre15">border-top-color</code>、<code class="calibre15">border-bottom-style</code>，等等）。因此，即使<code class="calibre15">computedStyle.border</code>不会在所有浏览器中都返回值，但<code class="calibre15">computedStyle.borderLeftWidth</code>则会返回值。</p>

  <blockquote class="calibre14">
    <p class="calibre2"><img alt="" class="calibre17" src="../Images/00002.gif" /> 需要注意的是，即使有些浏览器支持这种功能，但表示值的方式可能会有所区别。例如，Firefox和Safari会将所有颜色转换成RGB格式（例如红色是<code class="calibre15">rgb(255,0,0)</code>）。因此，在使用<code class="calibre15">getComputedStyle()</code>方法时，最好多在几种浏览器中测试一下。</p>
  </blockquote>

  <p class="calibre2">IE不支持<code class="calibre15">getComputedStyle()</code>方法，但它有一种类似的概念。在IE中，每个具有<code class="calibre15">style</code>属性的元素还有一个<code class="calibre15">currentStyle</code>属性。这个属性是<code class="calibre15">CSSStyleDeclaration</code>的实例，包含当前元素全部计算后的样式。取得这些样式的方式也差不多，如下面的例子所示。</p>
  <pre class="calibre18">var myDiv = document.getElementById("myDiv");
<b class="calibre3">var computedStyle = myDiv.currentStyle;</b>

alert(computedStyle.backgroundColor);       //"red"
alert(computedStyle.width);                 //"100px"
alert(computedStyle.height);                //"200px"
alert(computedStyle.border);                //undefined
</pre>

  <p class="calibre8"><i class="calibre7">IEComputedStylesExample.htm</i></p>

  <p class="calibre2">与DOM版本的方式一样，IE也没有返回<code class="calibre15">border</code>样式，因为这是一个综合属性。</p>

  <p class="calibre2">无论在哪个浏览器中，最重要的一条是要记住所有计算的样式都是只读的；不能修改计算后样式对象中的CSS属性。此外，计算后的样式也包含属于浏览器内部样式表的样式信息，因此任何具有默认值的CSS属性都会表现在计算后的样式中。例如，所有浏览器中的<code class="calibre15">visibility</code>属性都有一个默认值，但这个值会因实现而异。在默认情况下，有的浏览器将<code class="calibre15">visibility</code>属性设置为<code class="calibre15">"visible"</code>，而有的浏览器则将其设置为<code class="calibre15">"inherit"</code>。换句话说，不能指望某个CSS属性的默认值在不同浏览器中是相同的。如果你需要元素具有某个特定的默认值，应该手工在样式表中指定该值。</p>

  <h3 class="calibre22" id="sigil_toc_id_135"><strong class="calibre10">12.2.2　操作样式表</strong></h3>

  <p class="calibre2"><code class="calibre15">CSSStyleSheet</code>类型表示的是样式表，包括通过<code class="calibre15">&lt;link&gt;</code>元素包含的样式表和在<code class="calibre15">&lt;style&gt;</code>元素中定义的样式表。有读者可能记得，这两个元素本身分别是由<code class="calibre15">HTMLLinkElement</code>和<code class="calibre15">HTMLStyleElement</code>类型表示的。但是，<code class="calibre15">CSSStyleSheet</code>类型相对更加通用一些，它只表示样式表，而不管这些样式表在HTML中是如何定义的。此外，上述两个针对元素的类型允许修改HTML特性，但<code class="calibre15">CSSStyleSheet</code>对象则是一套只读的接口（有一个属性例外）。使用下面的代码可以确定浏览器是否支持DOM2级样式表。</p>
  <pre class="calibre18"><code class="calibre15">var supportsDOM2StyleSheets = 
                   document.implementation.hasFeature("StyleSheets", "2.0");
</code></pre>

  <p class="calibre2"><code class="calibre15">CSSStyleSheet</code>继承自<code class="calibre15">StyleSheet</code>，后者可以作为一个基础接口来定义非CSS样式表。从<code class="calibre15">StyleSheet</code>接口继承而来的属性如下。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">disabled</code>：表示样式表是否被禁用的布尔值。这个属性是可读/写的，将这个值设置为<code class="calibre15">true</code>可以禁用样式表。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">href</code>：如果样式表是通过<code class="calibre15">&lt;link&gt;</code>包含的，则是样式表的URL；否则，是<code class="calibre15">null</code>。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">media</code>：当前样式表支持的所有媒体类型的集合。与所有DOM集合一样，这个集合也有一个<code class="calibre15">length</code>属性和一个<code class="calibre15">item()</code>方法。也可以使用方括号语法取得集合中特定的项。如果集合是空列表，表示样式表适用于所有媒体。在IE中，<code class="calibre15">media</code>是一个反映<code class="calibre15">&lt;link&gt;</code>和<code class="calibre15">&lt;style&gt;</code>元素<code class="calibre15">media</code>特性值的字符串。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">ownerNode</code>：指向拥有当前样式表的节点的指针，样式表可能是在HTML中通过<code class="calibre15">&lt;link&gt;</code>或<code class="calibre15">&lt;style/&gt;</code>引入的（在XML中可能是通过处理指令引入的）。如果当前样式表是其他样式表通过<code class="calibre15">@import</code>导入的，则这个属性值为<code class="calibre15">null</code>。IE不支持这个属性。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">parentStyleSheet</code>：在当前样式表是通过<code class="calibre15">@import</code>导入的情况下，这个属性是一个指向导入它的样式表的指针。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">title</code>：<code class="calibre15">ownerNode</code>中<code class="calibre15">title</code>属性的值。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">type</code>：表示样式表类型的字符串。对CSS样式表而言，这个字符串是<code class="calibre15">"type/css"</code>。</p>
    </li>
  </ul>

  <p class="calibre2">除了<code class="calibre15">disabled</code>属性之外，其他属性都是只读的。在支持以上所有这些属性的基础上，<code class="calibre15">CSSStyleSheet</code>类型还支持下列属性和方法：</p>

  <ul class="calibre16">
    <li class="calibre12"><code class="calibre15">cssRules</code>：样式表中包含的样式规则的集合。IE不支持这个属性，但有一个类似的<code class="calibre15">rules</code>属性。</li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">ownerRule</code>：如果样式表是通过@import导入的，这个属性就是一个指针，指向表示导入的规则；否则，值为<code class="calibre15">null</code>。IE不支持这个属性。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">deleteRule(<em class="calibre7">index</em>)</code>：删除<code class="calibre15">cssRules</code>集合中指定位置的规则。IE不支持这个方法，但支持一个类似的<code class="calibre15">removeRule()</code>方法。</p>
    </li>
  </ul>

  <p class="calibre2">* <code class="calibre15">insertRule(<em class="calibre7">rule,index</em>)</code>：向cssRules集合中指定的位置插入<code class="calibre15"><em class="calibre7">rule</em></code>字符串。IE不支持这个方法，但支持一个类似的<code class="calibre15">addRule()</code>方法。</p>

  <p class="calibre2">应用于文档的所有样式表是通过<code class="calibre15">document.styleSheets</code>集合来表示的。通过这个集合的<code class="calibre15">length</code>属性可以获知文档中样式表的数量，而通过方括号语法或<code class="calibre15">item()</code>方法可以访问每一个样式表。来看一个例子。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">var sheet = null;
for (var i=0, len=document.styleSheets.length; i &lt; len; i++){
    sheet = document.styleSheets[i];
    alert(sheet.href);
}
</code></pre>

  <p class="calibre8"><i class="calibre7">StyleSheetsExample.htm</i></p>

  <p class="calibre2">以上代码可以输出文档中使用的每一个样式表的<code class="calibre15">href</code>属性（<code class="calibre15">&lt;style&gt;</code>元素包含的样式表没有<code class="calibre15">href</code>属性）。</p>

  <p class="calibre2">不同浏览器的<code class="calibre15">document.styleSheets</code>返回的样式表也不同。所有浏览器都会包含<code class="calibre15">&lt;style&gt;</code>元素和<code class="calibre15">rel</code>特性被设置为<code class="calibre15">"stylesheet"</code>的元素引入的样式表。IE和Opera也包含<code class="calibre15">rel</code>特性被设置为<code class="calibre15">"alternate stylesheet"</code>的<code class="calibre15">&lt;link&gt;</code>元素引入的样式表。</p>

  <p class="calibre2">也可以直接通过<code class="calibre15">&lt;link&gt;</code>或<code class="calibre15">&lt;style&gt;</code>元素取得<code class="calibre15">CSSStyleSheet</code>对象。DOM规定了一个包含<code class="calibre15">CSSStyleSheet</code>对象的属性，名叫<code class="calibre15">sheet</code>；除了IE，其他浏览器都支持这个属性。IE支持的是<code class="calibre15">styleSheet</code>属性。要想在不同浏览器中都能取得样式表对象，可以使用下列代码。</p>
  <pre class="calibre18"><code class="calibre15">function getStyleSheet(element){
    return element.sheet || element.styleSheet;
}

//取得第一个&lt;link/&gt;元素引入的样式表
var link = document.getElementsByTagName("link")[0];
var sheet = getStyleSheet(link);
</code></pre>

  <p class="calibre8"><i class="calibre7">StyleSheetsExample2.htm</i></p>

  <p class="calibre2">这里的<code class="calibre15">getStylesheet()</code>返回的样式表对象与<code class="calibre15">document.styleSheets</code>集合中的样式表对象相同。</p>

  <p class="calibre2">1. <strong class="calibre3">CSS规则</strong></p>

  <p class="calibre2"><code class="calibre15">CSSRule</code>对象表示样式表中的每一条规则。实际上，<code class="calibre15">CSSRule</code>是一个供其他多种类型继承的基类型，其中最常见的就是<code class="calibre15">CSSStyleRule</code>类型，表示样式信息（其他规则还有<code class="calibre15">@import</code>、<code class="calibre15">@font-face</code>、<code class="calibre15">@page</code>和<code class="calibre15">@charset</code>，但这些规则很少有必要通过脚本来访问）。<code class="calibre15">CSSStyleRule</code>对象包含下列属性。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">cssText</code>：返回整条规则对应的文本。由于浏览器对样式表的内部处理方式不同，返回的文本可能会与样式表中实际的文本不一样；Safari始终都会将文本转换成全部小写。IE不支持这个属性。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">parentRule</code>：如果当前规则是导入的规则，这个属性引用的就是导入规则；否则，这个值为<code class="calibre15">null</code>。IE不支持这个属性。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">parentStyleSheet</code>：当前规则所属的样式表。IE不支持这个属性。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">selectorText</code>：返回当前规则的选择符文本。由于浏览器对样式表的内部处理方式不同，返回的文本可能会与样式表中实际的文本不一样（例如，Safari 3之前的版本始终会将文本转换成全部小写）。在Firefox、Safari、Chrome和IE中这个属性是只读的。Opera允许修改<code class="calibre15">selectorText</code>。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">style</code>：一个<code class="calibre15">CSSStyleDeclaration</code>对象，可以通过它设置和取得规则中特定的样式值。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">type</code>：表示规则类型的常量值。对于样式规则，这个值是1。IE不支持这个属性。</p>
    </li>
  </ul>

  <p class="calibre2">其中三个最常用的属性是<code class="calibre15">cssText</code>、<code class="calibre15">selectorText</code>和<code class="calibre15">style</code>。<code class="calibre15">cssText</code>属性与<code class="calibre15">style.cssText</code>属性类似，但并不相同。前者包含选择符文本和围绕样式信息的花括号，后者只包含样式信息（类似于元素的<code class="calibre15">style.cssText</code>）。此外，<code class="calibre15">cssText</code>是只读的，而<code class="calibre15">style.cssText</code>也可以被重写。</p>

  <p class="calibre2">大多数情况下，仅使用<code class="calibre15">style</code>属性就可以满足所有操作样式规则的需求了。这个对象就像每个元素上的<code class="calibre15">style</code>属性一样，可以通过它读取和修改规则中的样式信息。以下面的CSS规则为例。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">div.box {
    background-color: blue;
    width: 100px;
    height: 200px;
}
</code></pre>

  <p class="calibre8"><i class="calibre7">CSSRulesExample.htm</i></p>

  <p class="calibre2">假设这条规则位于页面中的第一个样式表中，而且这个样式表中只有这一条样式规则，那么通过下列代码可以取得这条规则的各种信息。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">var sheet = document.styleSheets[0];
var rules = sheet.cssRules || sheet.rules;      //取得规则列表
var rule = rules[0];                            //取得第一条规则
alert(rule.selectorText);                       //"div.box"
alert(rule.style.cssText);                      //完整的CSS代码
alert(rule.style.backgroundColor);              //"blue"
alert(rule.style.width);                        //"100px"
alert(rule.style.height);                       //"200px"
</code></pre>

  <p class="calibre8"><i class="calibre7">CSSRulesExample.htm</i></p>

  <p class="calibre2">使用这种方式，可以像确定元素的行内样式信息一样，确定与规则相关的样式信息。与使用元素的方式一样，在这种方式下也可以修改样式信息，如下面的例子所示。</p>
  <pre class="calibre18">var sheet = document.styleSheets[0];
var rules = sheet.cssRules || sheet.rules;      //取得规则列表
var rule = rules[0];                            //取得第一条规则
<b class="calibre3">rule.style.backgroundColor = "red"</b>
</pre>

  <p class="calibre8"><i class="calibre7">CSSRulesExample.htm</i></p>

  <p class="calibre2">必须要注意的是，以这种方式修改规则会影响页面中适用于该规则的所有元素。换句话说，如果有两个带有<code class="calibre15">box</code>类的<code class="calibre15">&lt;div&gt;</code>元素，那么这两个元素都会应用修改后的样式。</p>

  <p class="calibre2">2. <strong class="calibre3">创建规则</strong></p>

  <p class="calibre2">DOM规定，要向现有样式表中添加新规则，需要使用<code class="calibre15">insertRule()</code>方法。这个方法接受两个参数：规则文本和表示在哪里插入规则的索引。下面是一个例子。</p>
  <pre class="calibre18"><code class="calibre15">sheet.insertRule("body { background-color: silver }", 0); //DOM方法
</code></pre>

  <p class="calibre2">这个例子插入的规则会改变元素的背景颜色。插入的规则将成为样式表中的第一条规则（插入到了位置0）——规则的次序在确定层叠之后应用到文档的规则时至关重要。Firefox、Safari、Opera和Chrome都支持<code class="calibre15">insertRule()</code>方法。</p>

  <p class="calibre2">IE8及更早版本支持一个类似的方法，名叫<code class="calibre15">addRule()</code>，也接收两必选参数：选择符文本和CSS样式信息；一个可选参数：插入规则的位置。在IE中插入与前面例子相同的规则，可使用如下代码。</p>
  <pre class="calibre18"><code class="calibre15">sheet.addRule("body", "background-color: silver", 0); //仅对IE有效
</code></pre>

  <p class="calibre2">有关这个方法的规定中说，最多可以使用<code class="calibre15">addRule()</code>添加4 095条样式规则。超出这个上限的调用将会导致错误。</p>

  <p class="calibre2">要以跨浏览器的方式向样式表中插入规则，可以使用下面的函数。这个函数接受4个参数：要向其中添加规则的样式表以及与<code class="calibre15">addRule()</code>相同的3个参数，如下所示。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">function insertRule(sheet, selectorText, cssText, position){
    if (sheet.insertRule){
        sheet.insertRule(selectorText + "{" + cssText + "}", position);
    } else if (sheet.addRule){
        sheet.addRule(selectorText, cssText, position);
    }
}
</code></pre>

  <p class="calibre8"><i class="calibre7">CSSRulesExample2.htm</i></p>

  <p class="calibre2">下面是调用这个函数的示例代码。</p>
  <pre class="calibre18"><code class="calibre15">insertRule(document.styleSheets[0], "body", "background-color: silver", 0);
</code></pre>

  <p class="calibre2">虽然可以像这样来添加规则，但随着要添加规则的增多，这种方法就会变得非常繁琐。因此，如果要添加的规则非常多，我们建议还是采用第10章介绍过的动态加载样式表的技术。</p>

  <p class="calibre2">3. <strong class="calibre3">删除规则</strong></p>

  <p class="calibre2">从样式表中删除规则的方法是<code class="calibre15">deleteRule()</code>，这个方法接受一个参数：要删除的规则的位置。例如，要删除样式表中的第一条规则，可以使用以下代码。</p>
  <pre class="calibre18"><code class="calibre15">sheet.deleteRule(0);    //DOM方法
</code></pre>

  <p class="calibre2">IE支持的类似方法叫<code class="calibre15">removeRule()</code>，使用方法相同，如下所示：</p>
  <pre class="calibre18"><code class="calibre15">sheet.removeRule(0);    //仅对IE有效
</code></pre>

  <p class="calibre2">下面是一个能够跨浏览器删除规则的函数。第一个参数是要操作的样式表，第二个参数是要删除的规则的索引。</p>
  <pre class="calibre18"><code class="calibre15">function deleteRule(sheet, index){
    if (sheet.deleteRule){
        sheet.deleteRule(index);
    } else if (sheet.removeRule){
        sheet.removeRule(index);
    }
}
</code></pre>

  <p class="calibre8"><i class="calibre7">CSSRulesExample2.htm/I&gt;</i></p>

  <p class="calibre2">调用这个函数的方式如下。</p>
  <pre class="calibre18"><code class="calibre15">deleteRule(document.styleSheets[0], 0);
</code></pre>

  <p class="calibre2">与添加规则相似，删除规则也不是实际Web开发中常见的做法。考虑到删除规则可能会影响CSS层叠的效果，因此请大家慎重使用。</p>

  <h3 class="calibre22" id="sigil_toc_id_136"><strong class="calibre10">12.2.3　元素大小</strong></h3>

  <p class="calibre2">本节介绍的属性和方法并不属于“DOM2级样式”规范，但却与HTML元素的样式息息相关。DOM中没有规定如何确定页面中元素的大小。IE为此率先引入了一些属性，以便开发人员使用。目前，所有主要的浏览器都已经支持这些属性。</p>

  <p class="calibre2">1. <strong class="calibre3">偏移量</strong></p>

  <p class="calibre2">首先要介绍的属性涉及<strong class="calibre3">偏移量</strong>（offset dimension），包括元素在屏幕上占用的所有可见的空间。元素的可见大小由其高度、宽度决定，包括所有内边距、滚动条和边框大小（注意，不包括外边距）。通过下列4个属性可以取得元素的偏移量。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">offsetHeight</code>：元素在垂直方向上占用的空间大小，以像素计。包括元素的高度、（可见的）水平滚动条的高度、上边框高度和下边框高度。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">offsetWidth</code>：元素在水平方向上占用的空间大小，以像素计。包括元素的宽度、（可见的）垂直滚动条的宽度、左边框宽度和右边框宽度。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">offsetLeft</code>：元素的左外边框至包含元素的左内边框之间的像素距离。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">offsetTop</code>：元素的上外边框至包含元素的上内边框之间的像素距离。</p>
    </li>
  </ul>

  <p class="calibre2">其中，<code class="calibre15">offsetLeft</code>和<code class="calibre15">offsetTop</code>属性与包含元素有关，包含元素的引用保存在<code class="calibre15">offsetParent</code>属性中。<code class="calibre15">offsetParent</code>属性不一定与<code class="calibre15">parentNode</code>的值相等。例如，<code class="calibre15">&lt;td&gt;</code>元素的<code class="calibre15">offsetParent</code>是作为其祖先元素的<code class="calibre15">&lt;table&gt;</code>元素，因为<code class="calibre15">&lt;table&gt;</code>是在DOM层次中距<code class="calibre15">&lt;td&gt;</code>最近的一个具有大小的元素。图12-1形象地展示了上面几个属性表示的不同大小。</p>

  <p class="p-img"><img alt="" class="calibre38" src="../Images/00029.gif" /></p>

  <p class="calibre2"><strong class="calibre3">图　12-1</strong></p>

  <p class="calibre2">要想知道某个元素在页面上的偏移量，将这个元素的<code class="calibre15">offsetLeft</code>和<code class="calibre15">offsetTop</code>与其<code class="calibre15">offsetParent</code>的相同属性相加，如此循环直至根元素，就可以得到一个基本准确的值。以下两个函数就可以用于分别取得元素的左和上偏移量。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">function getElementLeft(element){
    var actualLeft = element.offsetLeft;
    var current = element.offsetParent;

    while (current !== null){        
        actualLeft += current.offsetLeft;
        current = current.offsetParent;
    }

    return actualLeft;
}

function getElementTop(element){
    var actualTop = element.offsetTop;
    var current = element.offsetParent;

    while (current !== null){        
        actualTop += current. offsetTop;
        current = current.offsetParent;
    }

    return actualTop;
}
</code></pre>

  <p class="calibre8"><i class="calibre7">OffsetDimensionsExample.htm</i></p>

  <p class="calibre2">这两个函数利用<code class="calibre15">offsetParent</code>属性在DOM层次中逐级向上回溯，将每个层次中的偏移量属性合计到一块。对于简单的CSS布局的页面，这两函数可以得到非常精确的结果。对于使用表格和内嵌框架布局的页面，由于不同浏览器实现这些元素的方式不同，因此得到的值就不太精确了。一般来说，页面中的所有元素都会被包含在几个<code class="calibre15">&lt;div&gt;</code>元素中，而这些<code class="calibre15">&lt;div&gt;</code>元素的<code class="calibre15">offsetParent</code>又是<code class="calibre15">&lt;body&gt;</code>元素，所以<code class="calibre15">getElementLeft()</code>与<code class="calibre15">getElementTop()</code>会返回与<code class="calibre15">offsetLeft</code>和<code class="calibre15">offsetTop</code>相同的值。</p>

  <blockquote class="calibre14">
    <p class="calibre2"><img alt="" class="calibre17" src="../Images/00002.gif" /> 所有这些偏移量属性都是只读的，而且每次访问它们都需要重新计算。因此，应该尽量避免重复访问这些属性；如果需要重复使用其中某些属性的值，可以将它们保存在局部变量中，以提高性能。</p>
  </blockquote>

  <p class="calibre2">2. <strong class="calibre3">客户区大小</strong></p>

  <p class="calibre2">元素的<strong class="calibre3">客户区大小</strong>（client dimension），指的是元素内容及其内边距所占据的空间大小。有关客户区大小的属性有两个：<code class="calibre15">clientWidth</code>和<code class="calibre15">clientHeight</code>。其中，<code class="calibre15">clientWidth</code>属性是元素内容区宽度加上左右内边距宽度；<code class="calibre15">clientHeight</code>属性是元素内容区高度加上上下内边距高度。图12-2形象地说明了这些属性表示的大小。</p>

  <p class="p-img"><img alt="" class="calibre38" src="../Images/00030.gif" /></p>

  <p class="calibre2"><strong class="calibre3">图　12-2</strong></p>

  <p class="calibre2">从字面上看，客户区大小就是元素内部的空间大小，因此滚动条占用的空间不计算在内。最常用到这些属性的情况，就是像第8章讨论的确定浏览器视口大小的时候。如下面的例子所示，要确定浏览器视口大小，可以使用<code class="calibre15">document.documentElement</code>或<code class="calibre15">document.body</code>（在IE7之前的版本中）的<code class="calibre15">clientWidth</code>和<code class="calibre15">clientHeight</code>。</p>
  <pre class="calibre18"><code class="calibre15">function getViewport(){
    if (document.compatMode == "BackCompat"){
        return {
            width: document.body.clientWidth,
            height: document.body.clientHeight
        };
    } else {
        return {
            width: document.documentElement.clientWidth,
            height: document.documentElement.clientHeight
        };
    }
}
</code></pre>

  <p class="calibre2">这个函数首先检查<code class="calibre15">document.compatMode</code>属性，以确定浏览器是否运行在混杂模式。Safari 3.1之前的版本不支持这个属性，因此就会自动执行<code class="calibre15">else</code>语句。Chrome、Opera和Firefox大多数情况下都运行在标准模式下，因此它们也会前进到<code class="calibre15">else</code>语句。这个函数会返回一个对象，包含两个属性：<code class="calibre15">width</code>和<code class="calibre15">height</code>；表示浏览器视口（<code class="calibre15">&lt;html&gt;</code>或<code class="calibre15">&lt;body&gt;</code>元素）的大小。</p>

  <blockquote class="calibre14">
    <p class="calibre2"><img alt="" class="calibre17" src="../Images/00002.gif" /> 与偏移量相似，客户区大小也是只读的，也是每次访问都要重新计算的。</p>
  </blockquote>

  <p class="calibre2">3. <strong class="calibre3">滚动大小</strong></p>

  <p class="calibre2">最后要介绍的是<strong class="calibre3">滚动大小</strong>（scroll dimension），指的是包含滚动内容的元素的大小。有些元素（例如<code class="calibre15">&lt;html&gt;</code>元素），即使没有执行任何代码也能自动地添加滚动条；但另外一些元素，则需要通过CSS的<code class="calibre15">overflow</code>属性进行设置才能滚动。以下是4个与滚动大小相关的属性。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">scrollHeight</code>：在没有滚动条的情况下，元素内容的总高度。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">scrollWidth</code>：在没有滚动条的情况下，元素内容的总宽度。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">scrollLeft</code>：被隐藏在内容区域左侧的像素数。通过设置这个属性可以改变元素的滚动位置。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">scrollTop</code>：被隐藏在内容区域上方的像素数。通过设置这个属性可以改变元素的滚动位置。</p>
    </li>
  </ul>

  <p class="calibre2">图12-3展示了这些属性代表的大小。</p>

  <p class="calibre2"><code class="calibre15">scrollWidth</code>和<code class="calibre15">scrollHeight</code>主要用于确定元素内容的实际大小。例如，通常认为<code class="calibre15">&lt;html&gt;</code>元素是在Web浏览器的视口中滚动的元素（IE6之前版本运行在混杂模式下时是<code class="calibre15">&lt;body&gt;</code>元素）。因此，带有垂直滚动条的页面总高度就是<code class="calibre15">document.documentElement.scrollHeight</code>。</p>

  <p class="calibre2">对于不包含滚动条的页面而言，<code class="calibre15">scrollWidth</code>和<code class="calibre15">scrollHeight</code>与<code class="calibre15">clientWidth</code>和<code class="calibre15">clientHeight</code>之间的关系并不十分清晰。在这种情况下，基于<code class="calibre15">document.documentElement</code>查看这些属性会在不同浏览器间发现一些不一致性问题，如下所述。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2">Firefox中这两组属性始终都是相等的，但大小代表的是文档内容区域的实际尺寸，而非视口的尺寸。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2">Opera、Safari 3.1及更高版本、Chrome中的这两组属性是有差别的，其中<code class="calibre15">scrollWidth</code>和<code class="calibre15">scrollHeight</code>等于视口大小，而<code class="calibre15">clientWidth</code>和<code class="calibre15">clientHeight</code>等于文档内容区域的大小。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2">IE（在标准模式）中的这两组属性不相等，其中<code class="calibre15">scrollWidth</code>和<code class="calibre15">scrollHeight</code>等于文档内容区域的大小，而<code class="calibre15">clientWidth</code>和<code class="calibre15">clientHeight</code>等于视口大小。</p>
    </li>
  </ul>

  <p class="p-img"><img alt="" class="calibre38" src="../Images/00031.gif" /></p>

  <p class="calibre2"><strong class="calibre3">图　12-3</strong></p>

  <p class="calibre2">在确定文档的总高度时（包括基于视口的最小高度时），必须取得<code class="calibre15">scrollWidth/clientWidth</code>和<code class="calibre15">scrollHeight/clientHeight</code>中的最大值，才能保证在跨浏览器的环境下得到精确的结果。下面就是这样一个例子。</p>
  <pre class="calibre18"><code class="calibre15">var docHeight = Math.max(document.documentElement.scrollHeight,
                         document.documentElement.clientHeight);
var docWidth = Math.max(document.documentElement.scrollWidth,
                         document.documentElement.clientWidth);
</code></pre>

  <p class="calibre2">注意，对于运行在混杂模式下的IE，则需要用<code class="calibre15">document.body</code>代替<code class="calibre15">document.documentElement</code>。</p>

  <p class="calibre2">通过<code class="calibre15">scrollLeft</code>和<code class="calibre15">scrollTop</code>属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置。在元素尚未被滚动时，这两个属性的值都等于0。如果元素被垂直滚动了，那么<code class="calibre15">scrollTop</code>的值会大于0，且表示元素上方不可见内容的像素高度。如果元素被水平滚动了，那么<code class="calibre15">scrollLeft</code>的值会大于0，且表示元素左侧不可见内容的像素宽度。这两个属性都是可以设置的，因此将元素的<code class="calibre15">scrollLeft</code>和<code class="calibre15">scrollTop</code>设置为0，就可以重置元素的滚动位置。下面这个函数会检测元素是否位于顶部，如果不是就将其回滚到顶部。</p>
  <pre class="calibre18"><code class="calibre15">function scrollToTop(element){
    if (element.scrollTop != 0){
        element.scrollTop = 0;
    }
}
</code></pre>

  <p class="calibre2">这个函数既取得了<code class="calibre15">scrollTop</code>的值，也设置了它的值。</p>

  <p class="calibre2">4. <strong class="calibre3">确定元素大小</strong></p>

  <p class="calibre2">IE、Firefox 3+、Safari 4+、Opera 9.5及Chrome为每个元素都提供了一个<code class="calibre15">getBoundingClientRect()</code>方法。这个方法返回会一个矩形对象，包含4个属性：<code class="calibre15">left</code>、<code class="calibre15">top</code>、<code class="calibre15">right</code>和<code class="calibre15">bottom</code>。这些属性给出了元素在页面中相对于视口的位置。但是，浏览器的实现稍有不同。IE8及更早版本认为文档的左上角坐标是(2, 2)，而其他浏览器包括IE9则将传统的(0,0)作为起点坐标。因此，就需要在一开始检查一下位于(0,0)处的元素的位置，在IE8及更早版本中，会返回(2,2)，而在其他浏览器中会返回(0,0)。来看下面的函数：</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">function getBoundingClientRect(element){
    if (typeof arguments.callee.offset != "number"){
        var scrollTop = document.documentElement.scrollTop;
        var temp = document.createElement("div");
        temp.style.cssText = "position:absolute;left:0;top:0;";
        document.body.appendChild(temp);
        arguments.callee.offset = -temp.getBoundingClientRect().top - scrollTop;
        document.body.removeChild(temp);
        temp = null;
    }

    var rect = element.getBoundingClientRect();
    var offset = arguments.callee.offset;

    return {
        left: rect.left + offset,
        right: rect.right + offset,
        top: rect.top + offset,
        bottom: rect.bottom + offset
    };
}
</code></pre>

  <p class="calibre8"><i class="calibre7">GetBoundingClientRectExample.htm</i></p>

  <p class="calibre2">这个函数使用了它自身的属性来确定是否要对坐标进行调整。第一步是检测属性是否有定义，如果没有就定义一个。最终的<code class="calibre15">offset</code>会被设置为新元素上坐标的负值，实际上就是在IE中设置为?2，在Firefox和Opera中设置为-0。为此，需要创建一个临时的元素，将其位置设置在(0,0)，然后再调用其<code class="calibre15">getBoundingClientRect()</code>。而之所以要减去视口的<code class="calibre15">scrollTop</code>，是为了防止调用这个函数时窗口被滚动了。这样编写代码，就无需每次调用这个函数都执行两次<code class="calibre15">getBoundingClientRect()</code>了。接下来，再在传入的元素上调用这个方法并基于新的计算公式创建一个对象。</p>

  <p class="calibre2">对于不支持<code class="calibre15">getBoundingClientRect()</code>的浏览器，可以通过其他手段取得相同的信息。一般来说，<code class="calibre15">right</code>和<code class="calibre15">left</code>的差值与<code class="calibre15">offsetWidth</code>的值相等，而<code class="calibre15">bottom</code>和<code class="calibre15">top</code>的差值与<code class="calibre15">offsetHeight</code>相等。而且，<code class="calibre15">left</code>和<code class="calibre15">top</code>属性大致等于使用本章前面定义的<code class="calibre15">getElementLeft()</code>和<code class="calibre15">getElementTop()</code>函数取得的值。综合上述，就可以创建出下面这个跨浏览器的函数：</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18">function getBoundingClientRect(element){

    <b class="calibre3">var scrollTop = document.documentElement.scrollTop;</b>
    <b class="calibre3">var scrollLeft = document.documentElement.scrollLeft;</b>

    <b class="calibre3">if (element.getBoundingClientRect){</b>
        if (typeof arguments.callee.offset != "number"){
            var temp = document.createElement("div");
            temp.style.cssText = "position:absolute;left:0;top:0;";
            document.body.appendChild(temp);
            arguments.callee.offset = -temp.getBoundingClientRect().top - scrollTop;
            document.body.removeChild(temp);
            temp = null;
        }

        var rect = element.getBoundingClientRect();
        var offset = arguments.callee.offset;

        return {
            left: rect.left + offset,
            right: rect.right + offset,
            top: rect.top + offset,
            bottom: rect.bottom + offset

        };
    <b class="calibre3">} else {</b>

        <b class="calibre3">var actualLeft = getElementLeft(element);</b>
        <b class="calibre3">var actualTop = getElementTop(element);</b>

       <b class="calibre3">return {</b>
            <b class="calibre3">left: actualLeft - scrollLeft,</b>
            <b class="calibre3">right: actualLeft + element.offsetWidth - scrollLeft,</b>
            <b class="calibre3">top: actualTop - scrollTop,</b>
            <b class="calibre3">bottom: actualTop + element.offsetHeight - scrollTop</b>
        <b class="calibre3">}</b>
    <b class="calibre3">}</b>
}
</pre>

  <p class="calibre8"><i class="calibre7">GetBoundingClientRectExample.htm</i></p>

  <p class="calibre2">这个函数在<code class="calibre15">getBoundingClientRect()</code>有效时，就使用这个原生方法，而在这个方法无效时则使用默认的计算公式。在某些情况下，这个函数返回的值可能会有所不同，例如使用表格布局或使用滚动元素的情况下。</p>

  <blockquote class="calibre14">
    <p class="calibre2"><img alt="" class="calibre17" src="../Images/00002.gif" /> 由于这里使用了<code class="calibre15">arguments.callee</code>，所以这个方法不能在严格模式下使用。</p>
  </blockquote>
</body>
</html>
