<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>未知</title>
  <link href="../Styles/Style.css" rel="stylesheet" type="text/css" />
  <link href="../Styles/custom.css" rel="stylesheet" type="text/css" />
</head>

<body class="calibre">
  <h2 class="calibre9" id="nav_point_117">15.2　2D上下文</h2>

  <p class="calibre2">使用2D绘图上下文提供的方法，可以绘制简单的2D图形，比如矩形、弧线和路径。2D上下文的坐标开始于<code class="calibre15">&lt;canvas&gt;</code>元素的左上角，原点坐标是(0,0)。所有坐标值都基于这个原点计算，<em class="calibre7">x</em>值越大表示越靠右，<em class="calibre7">y</em>值越大表示越靠下。默认情况下，<code class="calibre15">width</code>和<code class="calibre15">height</code>表示水平和垂直两个方向上可用的像素数目。</p>

  <h3 class="calibre22" id="sigil_toc_id_171"><strong class="calibre10">15.2.1　填充和描边</strong></h3>

  <p class="calibre2">2D上下文的两种基本绘图操作是填充和描边。填充，就是用指定的样式（颜色、渐变或图像）填充图形；描边，就是只在图形的边缘画线。大多数2D上下文操作都会细分为填充和描边两个操作，而操作的结果取决于两个属性：<code class="calibre15">fillStyle</code>和<code class="calibre15">strokeStyle</code>。</p>

  <p class="calibre2">这两个属性的值可以是字符串、渐变对象或模式对象，而且它们的默认值都是<code class="calibre15">"#000000"</code>。如果为它们指定表示颜色的字符串值，可以使用CSS中指定颜色值的任何格式，包括颜色名、十六进制码、<code class="calibre15">rgb</code>、<code class="calibre15">rgba</code>、<code class="calibre15">hsl</code>或<code class="calibre15">hsla</code>。举个例子：</p>
  <pre class="calibre18"><code class="calibre15">var drawing = document.getElementById("drawing"); 

//确定浏览器支持&lt;canvas&gt;元素
if (drawing.getContext){

    var context = drawing.getContext("2d");
    context.strokeStyle = "red";
    context.fillStyle = "#0000ff";
}
</code></pre>

  <p class="calibre2">以上代码将<code class="calibre15">strokeStyle</code>设置为red（CSS中的颜色名），将<code class="calibre15">fillStyle</code>设置为#0000ff（蓝色）。然后，所有涉及描边和填充的操作都将使用这两个样式，直至重新设置这两个值。如前所述，这两个属性的值也可以是渐变对象或模式对象。本章后面会讨论这两种对象。</p>

  <h3 class="calibre22" id="sigil_toc_id_172"><strong class="calibre10">15.2.2　绘制矩形</strong></h3>

  <p class="calibre2">矩形是唯一一种可以直接在2D上下文中绘制的形状。与矩形有关的方法包括<code class="calibre15">fillRect()</code>、<code class="calibre15">strokeRect()</code>和<code class="calibre15">clearRect()</code>。这三个方法都能接收4个参数：矩形的<em class="calibre7">x</em>坐标、矩形的<em class="calibre7">y</em>坐标、矩形宽度和矩形高度。这些参数的单位都是像素。</p>

  <p class="calibre2">首先，<code class="calibre15">fillRect()</code>方法在画布上绘制的矩形会填充指定的颜色。填充的颜色通过<code class="calibre15">fillStyle</code>属性指定，比如：</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18">var drawing = document.getElementById("drawing"); 

//确定浏览器支持&lt;canvas&gt;元素
if (drawing.getContext){

    var context = drawing.getContext("2d");

    /*
     * 根据Mozilla的文档
     * http://developer.mozilla.org/en/docs/Canvas_tutorial:Basic_usage
     */

    <b class="calibre3">//绘制红色矩形</b>
    <b class="calibre3">context.fi llStyle = "#ff0000";</b>
    <b class="calibre3">context.fi llRect(10, 10, 50, 50);</b>

    <b class="calibre3">//绘制半透明的蓝色矩形</b>
    <b class="calibre3">context.fi llStyle = "rgba(0,0,255,0.5)";</b>
    <b class="calibre3">context.fi llRect(30, 30, 50, 50);</b>
}
</pre>

  <p class="calibre8"><i class="calibre7">2DFillRectExample01.htm</i></p>

  <p class="calibre2">以上代码首先将<code class="calibre15">fillStyle</code>设置为红色，然后从(10,10)处开始绘制矩形，矩形的宽和高均为50像素。然后，通过<code class="calibre15">rgba()</code>格式再将<code class="calibre15">fillStyle</code>设置为半透明的蓝色，在第一个矩形上面绘制第二个矩形。结果就是可以透过蓝色的矩形看到红色的矩形（见图15-1）。</p>

  <p class="p-img"><img alt="" class="calibre43" src="../Images/00051.gif" /></p>

  <p class="calibre2"><strong class="calibre3">图　15-1</strong></p>

  <p class="calibre2"><code class="calibre15">strokeRect()</code>方法在画布上绘制的矩形会使用指定的颜色描边。描边颜色通过<code class="calibre15">strokeStyle</code>属性指定。比如：</p>
  <pre class="calibre18">var drawing = document.getElementById("drawing");

//确定浏览器支持&lt;canvas&gt;元素
if (drawing.getContext){

    var context = drawing.getContext("2d");

    /*
     * 根据Mozilla的文档
     * http://developer.mozilla.org/en/docs/Canvas_tutorial:Basic_usage
     */

    <b class="calibre3">//绘制红色描边矩形</b>
    <b class="calibre3">context.strokeStyle = "#ff0000";</b>
    <b class="calibre3">context.strokeRect(10, 10, 50, 50);</b>

    <b class="calibre3">//绘制半透明的蓝色描边矩形</b>
    <b class="calibre3">context.strokeStyle = "rgba(0,0,255,0.5)";</b>
    <b class="calibre3">context.strokeRect(30, 30, 50, 50);</b>
}
</pre>

  <p class="calibre8"><i class="calibre7">2DStrokeRectExample01.htm/I&gt;</i></p>

  <p class="calibre2">以上代码绘制了两个重叠的矩形。不过，这两个矩形都只有框线，内部并没有填充颜色（见图15-2）。</p>

  <p class="p-img"><img alt="" class="calibre43" src="../Images/00052.gif" /></p>

  <p class="calibre2"><strong class="calibre3">图　15-2</strong></p>

  <blockquote class="calibre14">
    <p class="calibre2"><img alt="" class="calibre17" src="../Images/00002.gif" /> 描边线条的宽度由<code class="calibre15">lineWidth</code>属性控制，该属性的值可以是任意整数。另外，通过<code class="calibre15">lineCap</code>属性可以控制线条末端的形状是平头、圆头还是方头（<code class="calibre15">"butt"</code>、<code class="calibre15">"round"</code>或<code class="calibre15">"square"</code>），通过<code class="calibre15">lineJoin</code>属性可以控制线条相交的方式是圆交、斜交还是斜接（<code class="calibre15">"round"</code>、<code class="calibre15">"bevel"</code>或<code class="calibre15">"miter"</code>）。</p>
  </blockquote>

  <p class="calibre2">最后，<code class="calibre15">clearRect()</code>方法用于清除画布上的矩形区域。本质上，这个方法可以把绘制上下文中的某一矩形区域变透明。通过绘制形状然后再清除指定区域，就可以生成有意思的效果，例如把某个形状切掉一块。下面看一个例子。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18">var drawing = document.getElementById("drawing");

//确定浏览器支持&lt;canvas&gt;元素
if (drawing.getContext){

    var context = drawing.getContext("2d");
    /*
     * 根据Mozilla的文档
     * http://developer.mozilla.org/en/docs/Canvas_tutorial:Basic_usage
     */

    //绘制红色矩形
    context.fillStyle = "#ff0000";
    context.fillRect(10, 10, 50, 50);

    //绘制半透明的蓝色矩形
    context.fillStyle = "rgba(0,0,255,0.5)";
    context.fillRect(30, 30, 50, 50);

    <b class="calibre3">//在两个矩形重叠的地方清除一个小矩形</b>
    <b class="calibre3">context.clearRect(40, 40, 10, 10);</b>
}
</pre>

  <p class="calibre8"><i class="calibre7">2DClearRectExample01.htm</i></p>

  <p class="calibre2">如图15-3所示，两个填充矩形重叠在一起，而重叠的地方又被清除了一个小矩形区域。</p>

  <p class="p-img"><img alt="" class="calibre43" src="../Images/00053.gif" /></p>

  <p class="calibre2"><strong class="calibre3">图　15-3</strong></p>

  <h3 class="calibre22" id="sigil_toc_id_173"><strong class="calibre10">15.2.3　绘制路径</strong></h3>

  <p class="calibre2">2D绘制上下文支持很多在画布上绘制路径的方法。通过路径可以创造出复杂的形状和线条。要绘制路径，首先必须调用<code class="calibre15">beginPath()</code>方法，表示要开始绘制新路径。然后，再通过调用下列方法来实际地绘制路径。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">arc(<em class="calibre7">x, y, radius, startAngle, endAngle, counterclockwise</em>)</code>：以<code class="calibre15">(<em class="calibre7">x,y</em>)</code>为圆心绘制一条弧线，弧线半径为<code class="calibre15">radius</code>，起始和结束角度（用弧度表示）分别为<code class="calibre15">startAngle</code>和<code class="calibre15">endAngle</code>。最后一个参数表示<code class="calibre15">startAngle</code>和<code class="calibre15">endAngle</code>是否按逆时针方向计算，值为<code class="calibre15">false</code>表示按顺时针方向计算。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">arcTo(<em class="calibre7">x1, y1, x2, y2, radius</em>)</code>：从上一点开始绘制一条弧线，到<code class="calibre15">(<em class="calibre7">x2,y2</em>)</code>为止，并且以给定的半径<code class="calibre15">radius</code>穿过<code class="calibre15">(<em class="calibre7">x1,y1</em>)</code>。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">bezierCurveTo(<em class="calibre7">c1x, c1y, c2x, c2y, x, y</em>)</code>：从上一点开始绘制一条曲线，到<code class="calibre15">(<em class="calibre7">x,y</em>)</code>为止，并且以<code class="calibre15">(<em class="calibre7">c1x,c1y</em>)</code>和<code class="calibre15">(<em class="calibre7">c2x,c2y</em>)</code>为控制点。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">lineTo(<em class="calibre7">x, y</em>)</code>：从上一点开始绘制一条直线，到<code class="calibre15">(<em class="calibre7">x,y</em>)</code>为止。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">moveTo(<em class="calibre7">x, y</em>)</code>：将绘图游标移动到<code class="calibre15">(<em class="calibre7">x,y</em>)</code>，不画线。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">quadraticCurveTo(<em class="calibre7">cx, cy, x, y</em>)</code>：从上一点开始绘制一条二次曲线，到<code class="calibre15">(<em class="calibre7">x,y</em>)</code>为止，并且以<code class="calibre15">(<em class="calibre7">cx,cy</em>)</code>作为控制点。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">rect(<em class="calibre7">x, y, width, height</em>)</code>：从点<code class="calibre15">(<em class="calibre7">x,y</em>)</code>开始绘制一个矩形，宽度和高度分别由<code class="calibre15">width</code>和<code class="calibre15">height</code>指定。这个方法绘制的是矩形路径，而不是<code class="calibre15">strokeRect()</code>和<code class="calibre15">fillRect()</code>所绘制的独立的形状。</p>
    </li>
  </ul>

  <p class="calibre2">创建了路径后，接下来有几种可能的选择。如果想绘制一条连接到路径起点的线条，可以调用<code class="calibre15">closePath()</code>。如果路径已经完成，你想用<code class="calibre15">fillStyle</code>填充它，可以调用<code class="calibre15">fill()</code>方法。另外，还可以调用<code class="calibre15">stroke()</code>方法对路径描边，描边使用的是<code class="calibre15">strokeStyle</code>。最后还可以调用<code class="calibre15">clip()</code>，这个方法可以在路径上创建一个剪切区域。</p>

  <p class="calibre2">下面看一个例子，即绘制一个不带数字的时钟表盘。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18">var drawing = document.getElementById("drawing"); 

//确定浏览器支持&lt;canvas&gt;元素
if (drawing.getContext){

    var context = drawing.getContext("2d");

    <b class="calibre3">//开始路径</b>
    <b class="calibre3">context.beginPath();</b>

    <b class="calibre3">//绘制外圆</b>
    <b class="calibre3">context.arc(100, 100, 99, 0, 2 * Math.PI, false);</b>

    <b class="calibre3">//绘制内圆</b>
    <b class="calibre3">context.moveTo(194, 100);</b>
    <b class="calibre3">context.arc(100, 100, 94, 0, 2 * Math.PI, false);</b>

    <b class="calibre3">//绘制分针</b>
    <b class="calibre3">context.moveTo(100, 100);</b>
    <b class="calibre3">context.lineTo(100, 15);</b>

    <b class="calibre3">//绘制时针</b>
    <b class="calibre3">context.moveTo(100, 100);</b>
    <b class="calibre3">context.lineTo(35, 100);</b>

    <b class="calibre3">//描边路径</b>
    <b class="calibre3">context.stroke();</b>
}
</pre>

  <p class="calibre8"><i class="calibre7">2DPathExample01.htm</i></p>

  <p class="calibre2">这个例子使用<code class="calibre15">arc()</code>方法绘制了两个圆形：一个外圆和一个内圆，构成了表盘的边框。外圆的半径是99像素，圆心位于点(100,100)，也是画布的中心点。为了绘制一个完整的圆形，我们从0弧度开始，绘制2π弧度（通过<code class="calibre15">Math.PI</code>来计算）。在绘制内圆之前，必须把路径移动到外圆上的某一点，以避免绘制出多余的线条。第二次调用<code class="calibre15">arc()</code>使用了小一点的半径，以便创造边框的效果。然后，组合使用<code class="calibre15">moveTo()</code>和<code class="calibre15">lineTo()</code>方法来绘制时针和分针。最后一步是调用<code class="calibre15">stroke()</code>方法，这样才能把图形绘制到画布上，如图15-4所示。</p>

  <p class="p-img"><img alt="" class="calibre36" src="../Images/00054.gif" /></p>

  <p class="calibre2"><strong class="calibre3">图　15-4</strong></p>

  <p class="calibre2">在2D绘图上下文中，路径是一种主要的绘图方式，因为路径能为要绘制的图形提供更多控制。由于路径的使用很频繁，所以就有了一个名为<code class="calibre15">isPointInPath()</code>的方法。这个方法接收<em class="calibre7">x</em>和<em class="calibre7">y</em>坐标作为参数，用于在路径被关闭之前确定画布上的某一点是否位于路径上，例如：</p>
  <pre class="calibre18"><code class="calibre15">if (context.isPointInPath(100, 100)){
    alert("Point (100, 100) is in the path.");
}
</code></pre>

  <p class="calibre2">2D上下文中的路径API已经非常稳定，可以利用它们结合不同的填充和描边样式，绘制出非常复杂的图形来。</p>

  <h3 class="calibre22" id="sigil_toc_id_174"><strong class="calibre10">15.2.4　绘制文本</strong></h3>

  <p class="calibre2">文本与图形总是如影随形。为此，2D绘图上下文也提供了绘制文本的方法。绘制文本主要有两个方法：<code class="calibre15">fillText()</code>和<code class="calibre15">strokeText()</code>。这两个方法都可以接收4个参数：要绘制的文本字符串、<em class="calibre7">x</em>坐标、<em class="calibre7">y</em>坐标和可选的最大像素宽度。而且，这两个方法都以下列3个属性为基础。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">font</code>：表示文本样式、大小及字体，用CSS中指定字体的格式来指定，例如<code class="calibre15">"10px Arial"</code>。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">textAlign</code>：表示文本对齐方式。可能的值有<code class="calibre15">"start"</code>、<code class="calibre15">"end"</code>、<code class="calibre15">"left"</code>、<code class="calibre15">"right"</code>和<code class="calibre15">"center"</code>。建议使用<code class="calibre15">"start"</code>和<code class="calibre15">"end"</code>，不要使用<code class="calibre15">"left"</code>和<code class="calibre15">"right"</code>，因为前两者的意思更稳妥，能同时适合从左到右和从右到左显示（阅读）的语言。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">textBaseline</code>：表示文本的基线。可能的值有<code class="calibre15">"top"</code>、<code class="calibre15">"hanging"</code>、<code class="calibre15">"middle"</code>、<code class="calibre15">"alphabetic"</code>、<code class="calibre15">"ideographic"</code>和<code class="calibre15">"bottom"</code>。</p>
    </li>
  </ul>

  <p class="calibre2">这几个属性都有默认值，因此没有必要每次使用它们都重新设置一遍值。<code class="calibre15">fillText()</code>方法使用<code class="calibre15">fillStyle</code>属性绘制文本，而<code class="calibre15">strokeText()</code>方法使用<code class="calibre15">strokeStyle</code>属性为文本描边。相对来说，还是使用<code class="calibre15">fillText()</code>的时候更多，因为该方法模仿了在网页中正常显示文本。例如，下面的代码在前一节创建的表盘上方绘制了数字12：</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">context.font = "bold 14px Arial";
context.textAlign = "center";
context.textBaseline = "middle";
context.fillText("12", 100, 20);
</code></pre>

  <p class="calibre8"><i class="calibre7">2D TextExample01.htm</i></p>

  <p class="calibre2">结果如图15-5所示。</p>

  <p class="p-img"><img alt="" class="calibre36" src="../Images/00055.gif" /></p>

  <p class="calibre2"><strong class="calibre3">图　15-5</strong></p>

  <p class="calibre2">因为这里把<code class="calibre15">textAlign</code>设置为<code class="calibre15">"center"</code>，把<code class="calibre15">textBaseline</code>设置为<code class="calibre15">"middle"</code>，所以坐标(100,20)表示的是文本水平和垂直中点的坐标。如果将<code class="calibre15">textAlign</code>设置为<code class="calibre15">"start"</code>，则<em class="calibre7">x</em>坐标表示的是文本左端的位置（从左到右阅读的语言）；设置为<code class="calibre15">"end"</code>，则<em class="calibre7">x</em>坐标表示的是文本右端的位置（从左到右阅读的语言）。例如：</p>
  <pre class="calibre18">//正常
context.font = "bold 14px Arial";
context.textAlign = "center";
context.textBaseline = "middle";
context.fillText("12", 100, 20);

<b class="calibre3">//起点对齐</b>
<b class="calibre3">context.textAlign = "start";</b>
<b class="calibre3">context.fi llText("12", 100, 40);</b>

<b class="calibre3">//终点对齐</b>
<b class="calibre3">context.textAlign = "end";</b>
<b class="calibre3">context.fi llText("12", 100, 60);</b>
</pre>

  <p class="calibre8"><i class="calibre7">2DTextExample02.htm</i></p>

  <p class="calibre2">这一回绘制了三个字符串<code class="calibre15">"12"</code>，每个字符串的<em class="calibre7">x</em>坐标值相同，但<code class="calibre15">textAlign</code>值不同。另外，后两个字符串的<em class="calibre7">y</em>坐标依次增大，以避免相互重叠。结果如图15-6所示。</p>

  <p class="p-img"><img alt="" class="calibre36" src="../Images/00056.gif" /></p>

  <p class="calibre2"><strong class="calibre3">图　15-6</strong></p>

  <p class="calibre2">表盘中的分针恰好位于正中间，因此文本的水平对齐方式如何变化也能够一目了然。类似地，修改<code class="calibre15">textBaseline</code>属性的值可以调整文本的垂直对齐方式：值为<code class="calibre15">"top"</code>，<em class="calibre7">y</em>坐标表示文本顶端；值为<code class="calibre15">"bottom"</code>，<em class="calibre7">y</em>坐标表示文本底端；值为<code class="calibre15">"hanging"</code>、<code class="calibre15">"alphabetic"</code>和<code class="calibre15">"ideographic"</code>，则<em class="calibre7">y</em>坐标分别指向字体的特定基线坐标。</p>

  <p class="calibre2">由于绘制文本比较复杂，特别是需要把文本控制在某一区域中的时候，2D上下文提供了辅助确定文本大小的方法<code class="calibre15">measureText()</code>。这个方法接收一个参数，即要绘制的文本；返回一个<code class="calibre15">TextMetrics</code>对象。返回的对象目前只有一个<code class="calibre15">width</code>属性，但将来还会增加更多度量属性。</p>

  <p class="calibre2"><code class="calibre15">measureText()</code>方法利用<code class="calibre15">font</code>、<code class="calibre15">textAlign</code>和<code class="calibre15">textBaseline</code>的当前值计算指定文本的大小。比如，假设你想在一个140像素宽的矩形区域中绘制文本Hello world!，下面的代码从100像素的字体大小开始递减，最终会找到合适的字体大小。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">var fontSize = 100;
context.font = fontSize + "px Arial"; 

while(context.measureText("Hello world!").width &gt; 140){
    fontSize--;
    context.font = fontSize + "px Arial";
}

context.fillText("Hello world!", 10, 10);
context.fillText("Font size is " + fontSize + "px", 10, 50);
</code></pre>

  <p class="calibre8"><i class="calibre7">2DTextExample03.htm</i></p>

  <p class="calibre2">前面提到过，<code class="calibre15">fillText</code>和<code class="calibre15">strokeText()</code>方法都可以接收第四个参数，也就是文本的最大像素宽度。不过，这个可选的参数尚未得到所有浏览器支持（最早支持它的是Firefox 4）。提供这个参数后，调用<code class="calibre15">fillText()</code>或<code class="calibre15">strokeText()</code>时如果传入的字符串大于最大宽度，则绘制的文本字符的高度正确，但宽度会收缩以适应最大宽度。图15-7展示了这个效果。</p>

  <p class="p-img"><img alt="" class="calibre43" src="../Images/00057.gif" /></p>

  <p class="calibre2"><strong class="calibre3">图　15-7</strong></p>

  <p class="calibre2">绘制文本还是相对比较复杂的操作，因此支持<code class="calibre15">&lt;canvas&gt;</code>元素的浏览器也并未完全实现所有与绘制文本相关的API。</p>

  <h3 class="calibre22" id="sigil_toc_id_175"><strong class="calibre10">15.2.5　变换</strong></h3>

  <p class="calibre2">通过上下文的变换，可以把处理后的图像绘制到画布上。2D绘制上下文支持各种基本的绘制变换。创建绘制上下文时，会以默认值初始化变换矩阵，在默认的变换矩阵下，所有处理都按描述直接绘制。为绘制上下文应用变换，会导致使用不同的变换矩阵应用处理，从而产生不同的结果。</p>

  <p class="calibre2">可以通过如下方法来修改变换矩阵。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2"><code class="calibre15"><em class="calibre7">rotate</em> (<em class="calibre7">angle</em>)</code>：围绕原点旋转图像<code class="calibre15"><em class="calibre7">angle</em></code>弧度。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15"><em class="calibre7">scale</em> (<em class="calibre7">scaleX, scaleY</em>)</code>：缩放图像，在<em class="calibre7">x</em>方向乘以<code class="calibre15"><em class="calibre7">scaleX</em></code>，在<em class="calibre7">y</em>方向乘以<code class="calibre15"><em class="calibre7">scaleY</em></code>。<code class="calibre15"><em class="calibre7">scaleX</em></code>和<code class="calibre15"><em class="calibre7">scaleY</em></code>的默认值都是1.0。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15"><em class="calibre7">translate</em> (<em class="calibre7">x, y</em>)</code>：将坐标原点移动到<code class="calibre15">(<em class="calibre7">x,y</em>)</code>。执行这个变换之后，坐标(0,0)会变成之前由(<em class="calibre7">x,y</em>)表示的点。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15"><em class="calibre7">transform</em> (<em class="calibre7">m1_1, m1_2, m2_1, m2_2, dx, dy</em>)</code>：直接修改变换矩阵，方式是乘以如下 矩阵。</p>
      <pre class="calibre18"><code class="calibre15">m1_1    m1_2    dx
m2_1    m2_2    dy
0       0       1
</code></pre>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">setTransform(<em class="calibre7">m1_1, m1_2, m2_1, m2_2, dx, dy</em>)</code>：将变换矩阵重置为默认状态，然后再调用<code class="calibre15"><em class="calibre7">transform</em>()</code>。</p>
    </li>
  </ul>

  <p class="calibre2">变换有可能很简单，但也可能很复杂，这都要视情况而定。比如，就拿前面例子中绘制表针来说，如果把原点变换到表盘的中心，然后再绘制表针就容易多了。请看下面的例子。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18">var drawing = document.getElementById("drawing");

//确定浏览器支持&lt;canvas&gt;元素
if (drawing.getContext){

    var context = drawing.getContext("2d");

    //开始路径
    context.beginPath();

    //绘制外圆
    context.arc(100, 100, 99, 0, 2 * Math.PI, false);

    //绘制内圆
    context.moveTo(194, 100);
    context.arc(100, 100, 94, 0, 2 * Math.PI, false);

    <b class="calibre3">//变换原点</b>
    <b class="calibre3">context.translate(100, 100);</b>

    <b class="calibre3">//绘制分针</b>
    <b class="calibre3">context.moveTo(0,0);</b>
    <b class="calibre3">context.lineTo(0, -85);</b>

    <b class="calibre3">//绘制时针</b>
    <b class="calibre3">context.moveTo(0, 0);</b>
    <b class="calibre3">context.lineTo(-65, 0);</b>

    //描边路径
    context.stroke();
}
</pre>

  <p class="calibre8"><i class="calibre7">2DTransformExample01.htm</i></p>

  <p class="calibre2">把原点变换到时钟表盘的中心点(100,100)后，在同一方向上绘制线条就变成了简单的数学问题了。所有数学计算都基于(0,0)，而不是(100,100)。还可以更进一步，像下面这样使用<code class="calibre15">rotate()</code>方法旋转时钟的表针。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18">var drawing = document.getElementById("drawing");

//确定浏览器支持&lt;canvas&gt;元素
if (drawing.getContext){

    var context = drawing.getContext("2d");

    //开始路径
    context.beginPath();

    //绘制外圆
    context.arc(100, 100, 99, 0, 2 * Math.PI, false);

    //绘制内圆
    context.moveTo(194, 100);
    context.arc(100, 100, 94, 0, 2 * Math.PI, false);

    //变换原点
    context.translate(100, 100);

    <b class="calibre3">//旋转表针</b>
    <b class="calibre3">context.rotate(1);</b>

    //绘制分针
    context.moveTo(0,0);
    context.lineTo(0, -85);

    //绘制时针
    context.moveTo(0, 0);
    context.lineTo(-65, 0);

    //描边路径
    context.stroke();
}
</pre>

  <p class="calibre8"><i class="calibre7">2DTransformExample01.htm</i></p>

  <p class="calibre2">因为原点已经变换到了时钟表盘的中心点，所以旋转也是以该点为圆心的。结果就像是表针真地被固定在表盘中心一样，然后向右旋转了一定角度。结果如图15-8所示。</p>

  <p class="p-img"><img alt="" class="calibre36" src="../Images/00058.gif" /></p>

  <p class="calibre2"><strong class="calibre3">图　15-8</strong></p>

  <p class="calibre2">无论是刚才执行的变换，还是<code class="calibre15">fillStyle</code>、<code class="calibre15">strokeStyle</code>等属性，都会在当前上下文中一直有效，除非再对上下文进行什么修改。虽然没有什么办法把上下文中的一切都重置回默认值，但有两个方法可以跟踪上下文的状态变化。如果你知道将来还要返回某组属性与变换的组合，可以调用<code class="calibre15">save()</code>方法。调用这个方法后，当时的所有设置都会进入一个栈结构，得以妥善保管。然后可以对上下文进行其他修改。等想要回到之前保存的设置时，可以调用<code class="calibre15">restore()</code>方法，在保存设置的栈结构中向前返回一级，恢复之前的状态。连续调用<code class="calibre15">save()</code>可以把更多设置保存到栈结构中，之后再连续调用<code class="calibre15">restore()</code>则可以一级一级返回。下面来看一个例子。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">context.fillStyle = "#ff0000";
context.save();

context.fillStyle = "#00ff00";
context.translate(100, 100);
context.save();

context.fillStyle = "#0000ff";
context.fillRect(0, 0, 100, 200); //从点(100,100)开始绘制蓝色矩形

context.restore();
context.fillRect(10, 10, 100, 200); //从点(110,110)开始绘制绿色矩形

context.restore();
context.fillRect(0, 0, 100, 200); //从点(0,0)开始绘制红色矩形
</code></pre>

  <p class="calibre8"><i class="calibre7">2DSaveRestoreExample01.htm</i></p>

  <p class="calibre2">首先，将<code class="calibre15">fillStyle</code>设置为红色，并调用<code class="calibre15">save()</code>保存上下文状态。接下来，把<code class="calibre15">fillStyle</code>修改为绿色，把坐标原点变换到(100,100)，再调用<code class="calibre15">save()</code>保存上下文状态。然后，把<code class="calibre15">fillStyle</code>修改为蓝色并绘制蓝色的矩形。因为此时的坐标原点已经变了，所以矩形的左上角坐标实际上是(100,100)。然后调用<code class="calibre15">restore()</code>，之后<code class="calibre15">fillStyle</code>变回了绿色，因而第二个矩形就是绿色。之所以第二个矩形的起点坐标是(110,110)，是因为坐标位置的变换仍然起作用。再调用一次<code class="calibre15">restore()</code>，变换就被取消了，而<code class="calibre15">fillStyle</code>也返回了红色。所以最后一个矩形是红色的，而且绘制的起点是(0,0)。</p>

  <p class="calibre2">需要注意的是，<code class="calibre15">save()</code>方法保存的只是对绘图上下文的设置和变换，不会保存绘图上下文的内容。</p>

  <h3 class="calibre22" id="sigil_toc_id_176"><strong class="calibre10">15.2.6　绘制图像</strong></h3>

  <p class="calibre2">2D绘图上下文内置了对图像的支持。如果你想把一幅图像绘制到画布上，可以使用<code class="calibre15">drawImage()</code>方法。根据期望的最终结果不同，调用这个方法时，可以使用三种不同的参数组合。最简单的调用方式是传入一个HTML <code class="calibre15">&lt;img&gt;</code>元素，以及绘制该图像的起点的<em class="calibre7">x</em>和<em class="calibre7">y</em>坐标。例如：</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">var image = document.images[0];
context.drawImage(image, 10, 10);
</code></pre>

  <p class="calibre8"><i class="calibre7">2DDrawImageExample01.htm</i></p>

  <p class="calibre2">这两行代码取得了文档中的第一幅图像，然后将它绘制到上下文中，起点为(10,10)。绘制到画布上的图像大小与原始大小一样。如果你想改变绘制后图像的大小，可以再多传入两个参数，分别表示目标宽度和目标高度。通过这种方式来缩放图像并不影响上下文的变换矩阵。例如：</p>
  <pre class="calibre18"><code class="calibre15">context.drawImage(image, 50, 10, 20, 30);
</code></pre>

  <p class="calibre8"><i class="calibre7">2DDrawImageExample01.htm</i></p>

  <p class="calibre2">执行代码后，绘制出来的图像大小会变成20×30像素。</p>

  <p class="calibre2">除了上述两种方式，还可以选择把图像中的某个区域绘制到上下文中。<code class="calibre15">drawImage()</code>方法的这种调用方式总共需要传入9个参数：要绘制的图像、源图像的<em class="calibre7">x</em>坐标、源图像的<em class="calibre7">y</em>坐标、源图像的宽度、源图像的高度、目标图像的<em class="calibre7">x</em>坐标、目标图像的<em class="calibre7">y</em>坐标、目标图像的宽度、目标图像的高度。这样调用<code class="calibre15">drawImage()</code>方法可以获得最多的控制。例如：</p>
  <pre class="calibre18"><code class="calibre15">context.drawImage(image, 0, 10, 50, 50, 0, 100, 40, 60);
</code></pre>

  <p class="calibre8"><i class="calibre7">2DDrawImageExample01.htm</i></p>

  <p class="calibre2">这行代码只会把原始图像的一部分绘制到画布上。原始图像的这一部分的起点为(0,10)，宽和高都是50像素。最终绘制到上下文中的图像的起点是(0,100)，而大小变成了40×60像素。</p>

  <p class="calibre2">这种调用方式可以创造出很有意思的效果，如图15-9所示。</p>

  <p class="p-img"><img alt="" class="calibre40" src="../Images/00059.gif" /></p>

  <p class="calibre2"><strong class="calibre3">图　15-9</strong></p>

  <p class="calibre2">除了给<code class="calibre15">drawImage()</code>方法传入HTML <code class="calibre15">&lt;img&gt;</code>元素外，还可以传入另一个<code class="calibre15">&lt;canvas&gt;</code>元素作为其第一个参数。这样，就可以把另一个画布内容绘制到当前画布上。</p>

  <p class="calibre2">结合使用<code class="calibre15">drawImage()</code>和其他方法，可以对图像进行各种基本操作。而操作的结果可以通过<code class="calibre15">toDataURL()</code>方法获得<sup class="calibre13">1</sup>。不过，有一个例外，即图像不能来自其他域。如果图像来自其他域，调用<code class="calibre15">toDataURL()</code>会抛出一个错误。打个比方，假如位于<a class="calibre6" href="http://www.example.com">www.example.com</a>上的页面绘制的图像来自于<a class="calibre6" href="http://www.example.com">www.example.com</a>，那当前上下文就会被认为“不干净”，因而会抛出错误。</p>

  <blockquote class="calibre14">
    <p class="calibre2"><sup class="calibre13">1</sup> 请读者注意，虽然本章至今一直在讨论2D绘图上下文，但<code class="calibre15">toDataURL()</code>是<code class="calibre15">Canvas</code>对象的方法，不是上下文对象的方法。</p>
  </blockquote>

  <h3 class="calibre22" id="sigil_toc_id_177"><strong class="calibre10">15.2.7　阴影</strong></h3>

  <p class="calibre2">2D上下文会根据以下几个属性的值，自动为形状或路径绘制出阴影。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">shadowColor</code>：用CSS颜色格式表示的阴影颜色，默认为黑色。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">shadowOffsetX</code>：形状或路径<em class="calibre7">x</em>轴方向的阴影偏移量，默认为0。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">shadowOffsetY</code>：形状或路径<em class="calibre7">y</em>轴方向的阴影偏移量，默认为0。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">shadowBlur</code>：模糊的像素数，默认0，即不模糊。</p>
    </li>
  </ul>

  <p class="calibre2">这些属性都可以通过<code class="calibre15">context</code>对象来修改。只要在绘制前为它们设置适当的值，就能自动产生阴影。例如：</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18">var context = drawing.getContext("2d");

<b class="calibre3">//设置阴影</b>
<b class="calibre3">context.shadowOffsetX = 5;</b>
<b class="calibre3">context.shadowOffsetY = 5;</b>
<b class="calibre3">context.shadowBlur    = 4;</b>
<b class="calibre3">context.shadowColor   = "rgba(0, 0, 0, 0.5)";</b>

//绘制红色矩形
context.fillStyle = "#ff0000";
context.fillRect(10, 10, 50, 50);

//绘制蓝色矩形
context.fillStyle = "rgba(0,0,255,1)";
context.fillRect(30, 30, 50, 50);
</pre>

  <p class="calibre8"><i class="calibre7">2DFillRectShadowExample01.htm</i></p>

  <p class="calibre2">两个矩形的阴影样式相同，结果如图15-10所示。</p>

  <p class="p-img"><img alt="" class="calibre43" src="../Images/00060.gif" /></p>

  <p class="calibre2"><strong class="calibre3">图　15-10</strong></p>

  <p class="calibre2">不同浏览器对阴影的支持有一些差异。IE9、Firefox 4和Opera 11的行为最为规范，其他浏览器多多少少会有一些奇怪的现象，甚至根本不支持阴影。Chrome（直至第10版）不能正确地为描边的形状应用实心阴影。Chrome和Safari（直至第5版）在为带透明像素的图像应用阴影时也会有问题：不透明部分的下方本来是该有阴影的，但此时则一概不见了。Safari也不能给渐变图形应用阴影，其他浏览器都可以。</p>

  <h3 class="calibre22" id="sigil_toc_id_178"><strong class="calibre10">15.2.8　渐变</strong></h3>

  <p class="calibre2">渐变由<code class="calibre15">CanvasGradient</code>实例表示，很容易通过2D上下文来创建和修改。要创建一个新的线性渐变，可以调用<code class="calibre15">createLinearGradient()</code>方法。这个方法接收4个参数：起点的<em class="calibre7">x</em>坐标、起点的<em class="calibre7">y</em>坐标、终点的<em class="calibre7">x</em>坐标、终点的<em class="calibre7">y</em>坐标。调用这个方法后，它就会创建一个指定大小的渐变，并返回<code class="calibre15">CanvasGradient</code>对象的实例。</p>

  <p class="calibre2">创建了渐变对象后，下一步就是使用<code class="calibre15">addColorStop()</code>方法来指定色标。这个方法接收两个参数：色标位置和CSS颜色值。色标位置是一个0（开始的颜色）到1（结束的颜色）之间的数字。例如：</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">var gradient = context.createLinearGradient(30, 30, 70, 70);

gradient.addColorStop(0, "white");
gradient.addColorStop(1, "black");
</code></pre>

  <p class="calibre8"><i class="calibre7">2DFillRectGradientExample01.htm</i></p>

  <p class="calibre2">此时，<code class="calibre15">gradient</code>对象表示的是一个从画布上点(30,30)到点(70,70)的渐变。起点的色标是白色，终点的色标是黑色。然后就可以把<code class="calibre15">fillStyle</code>或<code class="calibre15">strokeStyle</code>设置为这个对象，从而使用渐变来绘制形状或描边：</p>
  <pre class="calibre18">//绘制红色矩形
context.fillStyle = "#ff0000";
context.fillRect(10, 10, 50, 50);

//绘制渐变矩形
<b class="calibre3">context.fillStyle = gradient;</b>
context.fillRect(30, 30, 50, 50);
</pre>

  <p class="calibre8"><i class="calibre7">2DFillRectGradientExample01.htm</i></p>

  <p class="calibre2">为了让渐变覆盖整个矩形，而不是仅应用到矩形的一部分，矩形和渐变对象的坐标必须匹配才行。以上代码会得到如图15-11所示的结果。</p>

  <p class="p-img"><img alt="" class="calibre43" src="../Images/00061.gif" /></p>

  <p class="calibre2"><strong class="calibre3">图　15-11</strong></p>

  <p class="calibre2">如果没有把矩形绘制到恰当的位置，那可能就只会显示部分渐变效果。例如：</p>
  <pre class="calibre18">context.fillStyle = gradient;
<b class="calibre3">context.fillRect(50, 50, 50, 50);</b>
</pre>

  <p class="calibre8"><i class="calibre7">2DFillRectGradientExample02.htm</i></p>

  <p class="calibre2">这两行代码执行后得到的矩形只有左上角稍微有一点白色。这主要是因为矩形的起点位于渐变的中间位置，而此时渐变差不多已经结束了。由于渐变不重复，所以矩形的大部分区域都是黑色。确保渐变与形状对齐非常重要，有时候可以考虑使用函数来确保坐标合适。例如：</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">function createRectLinearGradient(context, x, y, width, height){ 
    return context.createLinearGradient(x, y, x+width, y+height);
}
</code></pre>

  <p class="calibre8"><i class="calibre7">2DFillRectGradientExample03.htm</i></p>

  <p class="calibre2">这个函数基于起点的<em class="calibre7">x</em>和<em class="calibre7">y</em>坐标以及宽度和高度值来创建渐变对象，从而让我们可以在<code class="calibre15">fillRect()</code>中使用相同的值。</p>
  <pre class="calibre18">var gradient = createRectLinearGradient(context, 30, 30, 50, 50); 

gradient.addColorStop(0, "white");
gradient.addColorStop(1, "black");

//绘制渐变矩形
<b class="calibre3">context.fi llStyle = gradient;</b>
context.fillRect(30, 30, 50, 50);
</pre>

  <p class="calibre8"><i class="calibre7">2DFillRectGradientExample03.htm</i></p>

  <p class="calibre2">使用画布的时候，确保坐标匹配很重要，也需要一些技巧。类似<code class="calibre15">createRectLinearGradient()</code>这样的辅助方法可以让控制坐标更容易一些。</p>

  <p class="calibre2">要创建径向渐变（或放射渐变），可以使用<code class="calibre15">createRadialGradient()</code>方法。这个方法接收6个参数，对应着两个圆的圆心和半径。前三个参数指定的是起点圆的原心（<em class="calibre7">x</em>和 <em class="calibre7">y</em>）及半径，后三个参数指定的是终点圆的原心（<em class="calibre7">x</em>和 <em class="calibre7">y</em>）及半径。可以把径向渐变想象成一个长圆桶，而这6个参数定义的正是这个桶的两个圆形开口的位置。如果把一个圆形开口定义得比另一个小一些，那这个圆桶就变成了圆锥体，而通过移动每个圆形开口的位置，就可达到像旋转这个圆锥体一样的效果。</p>

  <p class="calibre2">如果想从某个形状的中心点开始创建一个向外扩散的径向渐变效果，就要将两个圆定义为同心圆。比如，就拿前面创建的矩形来说，径向渐变的两个圆的圆心都应该在(55,55)，因为矩形的区域是从(30,30)到(80,80)。请看代码：</p>
  <pre class="calibre18"><b class="calibre3">var gradient = context.createRadialGradient(55, 55, 10, 55, 55, 30);</b>

gradient.addColorStop(0, "white");
gradient.addColorStop(1, "black");

//绘制红色矩形
context.fillStyle = "#ff0000";
context.fillRect(10, 10, 50, 50);

//绘制渐变矩形
context.fillStyle = gradient;
context.fillRect(30, 30, 50, 50);
</pre>

  <p class="calibre8"><i class="calibre7">2DFillRectGradientExample04.htm</i></p>

  <p class="calibre2">运行代码，会得到如图15-12所示的结果。</p>

  <p class="p-img"><img alt="" class="calibre43" src="../Images/00062.gif" /></p>

  <p class="calibre2"><strong class="calibre3">图　15-12</strong></p>

  <p class="calibre2">因为创建比较麻烦，所以径向渐变并不那么容易控制。不过，一般来说，让起点圆和终点圆保持为同心圆的情况比较多，这时候只要考虑给两个圆设置不同的半径就好了。</p>

  <h3 class="calibre22" id="sigil_toc_id_179"><strong class="calibre10">15.2.9　模式</strong></h3>

  <p class="calibre2">模式其实就是重复的图像，可以用来填充或描边图形。要创建一个新模式，可以调用<code class="calibre15">createPattern()</code>方法并传入两个参数：一个HTML <code class="calibre15">&lt;img&gt;</code>元素和一个表示如何重复图像的字符串。其中，第二个参数的值与CSS的<code class="calibre15">background-repeat</code>属性值相同，包括<code class="calibre15">"repeat"</code>、<code class="calibre15">"repeat-x"</code>、<code class="calibre15">"repeat-y"</code>和<code class="calibre15">"no-repeat"</code>。看一个例子。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18">var image = document.images[0], 
    <b class="calibre3">pattern = context.createPattern(image, "repeat");</b>

//绘制矩形
context.fillStyle = pattern;
context.fillRect(10, 10, 150, 150);
</pre>

  <p class="calibre8"><i class="calibre7">2DFillRectPatternExample01.htm</i></p>

  <p class="calibre2">需要注意的是，模式与渐变一样，都是从画布的原点(0,0)开始的。将填充样式（<code class="calibre15">fillStyle</code>）设置为模式对象，只表示在某个特定的区域内显示重复的图像，而不是要从某个位置开始绘制重复的图像。上面的代码会得到如图15-13所示的结果。</p>

  <p class="p-img"><img alt="" class="calibre34" src="../Images/00063.gif" /></p>

  <p class="calibre2"><strong class="calibre3">图　15-13</strong></p>

  <p class="calibre2"><code class="calibre15">createPattern()</code>方法的第一个参数也可以是一个<code class="calibre15">&lt;video&gt;</code>元素，或者另一个<code class="calibre15">&lt;canvas&gt;</code>元素。</p>

  <h3 class="calibre22" id="sigil_toc_id_180"><strong class="calibre10">15.2.10　使用图像数据</strong></h3>

  <p class="calibre2">2D上下文的一个明显的长处就是，可以通过<code class="calibre15">getImageData()</code>取得原始图像数据。这个方法接收4个参数：要取得其数据的画面区域的<em class="calibre7">x</em>和<em class="calibre7">y</em>坐标以及该区域的像素宽度和高度。例如，要取得左上角坐标为(10,5)、大小为50×50像素的区域的图像数据，可以使用以下代码：</p>
  <pre class="calibre18"><code class="calibre15">var imageData = context.getImageData(10, 5, 50, 50);
</code></pre>

  <p class="calibre2">这里返回的对象是<code class="calibre15">ImageData</code>的实例。每个<code class="calibre15">ImageData</code>对象都有三个属性：<code class="calibre15">width</code>、<code class="calibre15">height</code>和<code class="calibre15">data</code>。其中<code class="calibre15">data</code>属性是一个数组，保存着图像中每一个像素的数据。在<code class="calibre15">data</code>数组中，每一个像素用4个元素来保存，分别表示红、绿、蓝和透明度值。因此，第一个像素的数据就保存在数组的第0到第3个元素中，例如：</p>
  <pre class="calibre18"><code class="calibre15">var data = imageData.data,
    red = data[0],
    green = data[1],
    blue = data[2],
    alpha = data[3];
</code></pre>

  <p class="calibre2">数组中每个元素的值都介于0到255之间（包括0和255）。能够直接访问到原始图像数据，就能够以各种方式来操作这些数据。例如，通过修改图像数据，可以像下面这样创建一个简单的灰阶过滤器。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">var drawing = document.getElementById("drawing");

//确定浏览器支持&lt;canvas&gt;元素
if (drawing.getContext){

    var context = drawing.getContext("2d"),
        image = document.images[0],
        imageData, data,
        i, len, average,
        red, green, blue, alpha;

    //绘制原始图像
    context.drawImage(image, 0, 0);

    //取得图像数据
    imageData = context.getImageData(0, 0, image.width, image.height);
    data = imageData.data;

    for (i=0, len=data.length; i &lt; len; i+=4){

        red = data[i];
        green = data[i+1];
        blue = data[i+2];
        alpha = data[i+3];

        //求得rgb平均值
        average = Math.floor((red + green + blue) / 3);

        //设置颜色值，透明度不变
        data[i] = average;
        data[i+1] = average;
        data[i+2] = average;

    }

    //回写图像数据并显示结果
    imageData.data = data;
    context.putImageData(imageData, 0, 0);
}
</code></pre>

  <p class="calibre8"><i class="calibre7">2DImageDataExample01.htm</i></p>

  <p class="calibre2">这个例子首先在画面上绘制了一幅图像，然后取得了原始图像数据。其中的<code class="calibre15">for</code>循环遍历了图像数据中的每一个像素。这里要注意的是，每次循环控制变量<code class="calibre15">i</code>都递增4。在取得每个像素的红、绿、蓝颜色值后，计算出它们的平均值。再把这个平均值设置为每个颜色的值，结果就是去掉了每个像素的颜色，只保留了亮度接近的灰度值（即彩色变黑白）。在把<code class="calibre15">data</code>数组回写到<code class="calibre15">imageData</code>对象后，调用<code class="calibre15">putImageData()</code>方法把图像数据绘制到画布上。最终得到了图像的黑白版。</p>

  <p class="calibre2">当然，通过操作原始像素值不仅能实现灰阶过滤，还能实现其他功能。要了解通过操作原始图像数据实现过滤器的更多信息，请参考Ilmari Heikkinen 的文章“Making Image Filters with Canvas”（基于Canvas的图像过滤器）：<a class="calibre6" href="http://www.html5rocks.com/en/tutorials/canvas/imagefilters/">http://www.html5rocks.com/en/tutorials/canvas/imagefilters/</a>。</p>

  <blockquote class="calibre14">
    <p class="calibre2"><img alt="" class="calibre17" src="../Images/00002.gif" /> 只有在画布“干净”的情况下（即图像并非来自其他域），才可以取得图像数据。如果画布“不干净”，那么访问图像数据时会导致JavaScript错误。</p>
  </blockquote>

  <h3 class="calibre22" id="sigil_toc_id_181"><strong class="calibre10">15.2.11　合成</strong></h3>

  <p class="calibre2">还有两个会应用到2D上下文中所有绘制操作的属性：<code class="calibre15">globalAlpha</code>和<code class="calibre15">globalCompositionOperation</code>。其中，<code class="calibre15">globalAlpha</code>是一个介于0和1之间的值（包括0和1），用于指定所有绘制的透明度。默认值为0。如果所有后续操作都要基于相同的透明度，就可以先把<code class="calibre15">globalAlpha</code>设置为适当值，然后绘制，最后再把它设置回默认值0。下面来看一个例子。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18">//绘制红色矩形
context.fillStyle = "#ff0000";
context.fillRect(10, 10, 50, 50);

//修改全局透明度
<b class="calibre3">context.globalAlpha = 0.5;</b>

//绘制蓝色矩形
context.fillStyle = "rgba(0,0,255,1)";
context.fillRect(30, 30, 50, 50);

//重置全局透明度
context.globalAlpha = 0;
</pre>

  <p class="calibre8"><i class="calibre7">2DGlobalAlphaExample01.htm</i></p>

  <p class="calibre2">在这个例子中，我们把蓝色矩形绘制到了红色矩形上面。因为在绘制蓝色矩形前，<code class="calibre15">globalAlpha</code>已经被设置为0.5，所以蓝色矩形会呈现半透明效果，透过它可以看到下面的红色矩形。</p>

  <p class="calibre2">第二个属性<code class="calibre15">globalCompositionOperation</code>表示后绘制的图形怎样与先绘制的图形结合。这个属性的值是字符串，可能的值如下。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">source-over</code>（默认值）：后绘制的图形位于先绘制的图形上方。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">source-in</code>：后绘制的图形与先绘制的图形重叠的部分可见，两者其他部分完全透明。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">source-out</code>：后绘制的图形与先绘制的图形不重叠的部分可见，先绘制的图形完全透明。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">source-atop</code>：后绘制的图形与先绘制的图形重叠的部分可见，先绘制图形不受影响。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">destination-over</code>：后绘制的图形位于先绘制的图形下方，只有之前透明像素下的部分才可见。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">destination-in</code>：后绘制的图形位于先绘制的图形下方，两者不重叠的部分完全透明。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">destination-out</code>：后绘制的图形擦除与先绘制的图形重叠的部分。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">destination-atop</code>：后绘制的图形位于先绘制的图形下方，在两者不重叠的地方，先绘制的图形会变透明。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">lighter</code>：后绘制的图形与先绘制的图形重叠部分的值相加，使该部分变亮。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">copy</code>：后绘制的图形完全替代与之重叠的先绘制图形。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><code class="calibre15">xor</code>：后绘制的图形与先绘制的图形重叠的部分执行“异或”操作。</p>
    </li>
  </ul>

  <p class="calibre2">这个合成操作实际上用语言或者黑白图像是很难说清楚的。要了解每个操作的具体效果，请参见<a class="calibre6" href="https://developer.mozilla.org/samples/canvas-tutorial/6_1_canvas_composite.html">https://developer.mozilla.org/samples/canvas-tutorial/6_1_canvas_composite.html</a>。推荐使用IE9+或Firefox 4+访问前面的网页，因为这两款浏览器对Canvas的实现最完善。下面来看一个例子。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18">//绘制红色矩形
context.fillStyle = "#ff0000";
context.fillRect(10, 10, 50, 50);

//设置合成操作
<b class="calibre3">context.globalCompositeOperation = "destination-over";</b>

//绘制蓝色矩形
context.fillStyle = "rgba(0,0,255,1)";
context.fillRect(30, 30, 50, 50);
</pre>

  <p class="calibre8"><i class="calibre7">2DGlobalCompositeOperationExample01.htm</i></p>

  <p class="calibre2">如果不修改<code class="calibre15">globalCompositionOperation</code>，那么蓝色矩形应该位于红色矩形之上。但把<code class="calibre15">globalCompositionOperation</code>设置为<code class="calibre15">"destination-over"</code>之后，红色矩形跑到了蓝色矩形上面。</p>

  <p class="calibre2">在使用<code class="calibre15">globalCompositionOperation</code>的情况下，一定要多测试一些浏览器。因为不同浏览器对这个属性的实现仍然存在较大的差别。Safari和Chrome在这方面还有问题，至于有什么问题，大家可以比较在打开上述页面的情况下，IE9+和Firefox 4+与它们有什么差异。</p>
</body>
</html>
