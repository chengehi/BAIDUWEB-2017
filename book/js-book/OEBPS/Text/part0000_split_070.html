<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>未知</title>
  <link href="../Styles/Style.css" rel="stylesheet" type="text/css" />
  <link href="../Styles/custom.css" rel="stylesheet" type="text/css" />
</head>

<body class="calibre">
  <h2 class="calibre9" id="nav_point_60">9.3　用户代理检测</h2>

  <p class="calibre2">第三种，也是争议最大的一种客户端检测技术叫做<strong class="calibre3">用户代理检测</strong>。用户代理检测通过检测用户代理字符串来确定实际使用的浏览器。在每一次HTTP请求过程中，用户代理字符串是作为响应首部发送的，而且该字符串可以通过JavaScript的<code class="calibre15">navigator.userAgent</code>属性访问。在服务器端，通过检测用户代理字符串来确定用户使用的浏览器是一种常用而且广为接受的做法。而在客户端，用户代理检测一般被当作一种万不得已才用的做法，其优先级排在能力检测和（或）怪癖检测之后。</p>

  <p class="calibre2">提到与用户代理字符串有关的争议，就不得不提到<strong class="calibre3">电子欺骗</strong>（spoofing）。所谓电子欺骗，就是指浏览器通过在自己的用户代理字符串加入一些错误或误导性信息，来达到欺骗服务器的目的。要弄清楚这个问题的来龙去脉，必须从Web问世初期用户代理字符串的发展讲起。</p>

  <h3 class="calibre22" id="nav_point_61">9.3.1　用户代理字符串的历史</h3>

  <p class="calibre2">HTTP规范（包括1.0和1.1版）明确规定，浏览器应该发送简短的用户代理字符串，指明浏览器的名称和版本号。RFC 2616（即HTTP 1.1协议规范）是这样描述用户代理字符串的：</p>

  <blockquote class="calibre14">
    <p class="calibre2">“产品标识符常用于通信应用程序标识自身，由软件名和版本组成。使用产品标识符的大多数领域也允许列出作为应用程序主要部分的子产品，由空格分隔。按照惯例，产品要按照相应的重要程度依次列出，以便标识应用程序。”</p>
  </blockquote>

  <p class="calibre2">上述规范进一步规定，用户代理字符串应该以一组产品的形式给出，字符串格式为：标识符/产品版本号。但是，现实中的用户代理字符串则绝没有如此简单。</p>

  <p class="calibre2">1. <strong class="calibre3">早期的浏览器</strong></p>

  <p class="calibre2">1993年，美国NCSA（National Center for Supercomputing Applications，国家超级计算机中心）发布了世界上第一款Web浏览器Mosaic。这款浏览器的用户代理字符串非常简单，类似如下所示。</p>
  <pre class="calibre18"><code class="calibre15">Mosaic/0.9
</code></pre>

  <p class="calibre2">尽管这个字符串在不同操作系统和不同平台下会有所变化，但其基本格式还是简单明了的。正斜杠前面的文本表示产品名称（有时候会出现NCSA Mosaic或其他类似字样），而斜杠后面的文本是产品的版本号。</p>

  <p class="calibre2">Netscape Communications公司介入浏览器开发领域后，遂将自己产品的代号定名为Mozilla（Mosaic Killer的简写，意即Mosaic杀手）。该公司第一个公开发行版，Netscape Navigator 2的用户代理字符串具有如下格式。</p>
  <pre class="calibre18"><code class="calibre15">Mozilla/版本号 [语言] (平台; 加密类型)
</code></pre>

  <p class="calibre2">Netscape在坚持将产品名和版本号作为用户代理字符串开头的基础上，又在后面依次添加了下列信息。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2"><strong class="calibre3">语言</strong>：即语言代码，表示应用程序针对哪种语言设计。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><strong class="calibre3">平台</strong>：即操作系统和（或）平台，表示应用程序的运行环境。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2"><strong class="calibre3">加密类型</strong>：即安全加密的类型。可能的值有U（128位加密）、I（40位加密）和N（未加密）。</p>
    </li>
  </ul>

  <p class="calibre2">典型的Netscape Navigator 2的用户代理字符串如下所示。</p>
  <pre class="calibre18"><code class="calibre15">Mozilla/2.02 [fr] (WinNT; I)
</code></pre>

  <p class="calibre2">这个字符串表示浏览器是Netscape Navigator 2.02，为法语国家编译，运行在Windows NT平台下，加密类型为40位。那个时候，通过用户代理字符串中的产品名称，至少还能够轻易地确定用户使用的是什么浏览器。</p>

  <p class="calibre2">2. <strong class="calibre3">Netscape Navigator 3和Internet Explorer 3</strong></p>

  <p class="calibre2">1996年，Netscape Navigator 3发布，随即超越Mosaic成为当时最流行的Web浏览器。而用户代理字符串只作了一些小的改变，删除了语言标记，同时允许添加操作系统或系统使用的CPU等可选信息。于是，格式变成如下所示。</p>
  <pre class="calibre18"><code class="calibre15">Mozilla/版本号 (平台; 加密类型 [; 操作系统或CPU说明])
</code></pre>

  <p class="calibre2">运行在Windows系统下的Netscape Navigator 3的用户代理字符串大致如下。</p>
  <pre class="calibre18"><code class="calibre15">Mozilla/3.0 (Win95; U)
</code></pre>

  <p class="calibre2">这个字符串表示Netscape Navigator 3运行在Windows 95中，采用了128位加密技术。可见，在Windows系统中，字符串中的操作系统或CPU说明被省略了。</p>

  <p class="calibre2">Netscape Navigator 3发布后不久，微软也发布了其第一款赢得用户广泛认可的Web浏览器，即Internet Explorer 3。由于Netscape浏览器在当时占绝对市场份额，许多服务器在提供网页之前都要专门检测该浏览器。如果用户通过IE打不开相关网页，那么这个新生的浏览器很可能就会夭折。于是，微软决定将IE的用户代理字符串修改成兼容Netscape的形式，结果如下：</p>
  <pre class="calibre18"><code class="calibre15">Mozilla/2.0 (compatible; MSIE 版本号; 操作系统)
</code></pre>

  <p class="calibre2">例如，Windows 95平台下的Internet Explorer 3.02带有如下用户代理字符串：</p>
  <pre class="calibre18"><code class="calibre15">Mozilla/2.0 (compatible; MSIE 3.02; Windows 95)
</code></pre>

  <p class="calibre2">由于当时的大多数浏览器嗅探程序只检测用户代理字符串中的产品名称部分，结果IE就成功地将自己标识为Mozilla，从而伪装成Netscape Navigator。微软的这一做法招致了很多批评，因为它违反了浏览器标识的惯例。更不规范的是，IE将真正的浏览器版本号插入到了字符串的中间。</p>

  <p class="calibre2">字符串中另外一个有趣的地方是标识符Mozilla 2.0（而不是3.0）。毕竟，当时的主流版本是3.0，改成3.0应该对微软更有利才对。但真正的谜底到现在还没有揭开——但很可能只是人为疏忽所致。</p>

  <p class="calibre2">3. <strong class="calibre3">Netscape Communicator 4和IE4～IE8</strong></p>

  <p class="calibre2">1997年8月，Netscapte Communicator 4发布（这一版将浏览器名字中的Navigator换成了Commu- nicator）。Netscape继续遵循了第3版时的用户代理字符串格式：</p>
  <pre class="calibre18"><code class="calibre15">Mozilla/版本号 (平台; 加密类型 [; 操作系统或CPU说明])
</code></pre>

  <p class="calibre2">因此，Windows 98平台中第4版的用户代理字符串如下所示：</p>
  <pre class="calibre18"><code class="calibre15">Mozilla/4.0 (Win98; I)
</code></pre>

  <p class="calibre2">Netscape在发布补丁时，子版本号也会相应提高，用户代理字符串如下面的4.79版所示：</p>
  <pre class="calibre18"><code class="calibre15">Mozilla/4.79 (Win98; I)
</code></pre>

  <p class="calibre2">但是，微软在发布Internet Explorer 4时，顺便将用户代理字符串修改成了如下格式：</p>
  <pre class="calibre18"><code class="calibre15">Mozilla/4.0 (compatible; MSIE 版本号; 操作系统)
</code></pre>

  <p class="calibre2">换句话说，对于Windows 98中运行的IE4而言，其用户代理字符串为：</p>
  <pre class="calibre18"><code class="calibre15">Mozilla/4.0 (compatible; MSIE 4.0; Windows 98)
</code></pre>

  <p class="calibre2">经过此番修改，Mozilla版本号就与实际的IE版本号一致了，为识别它们的第四代浏览器提供了方便。但令人遗憾的是，两者的一致性仅限于这一个版本。在Internet Explorer 4.5发布时（只针对Macs），虽然Mozilla版本号还是4，但IE版本号则改成了如下所示：</p>
  <pre class="calibre18"><code class="calibre15">Mozilla/4.0 (compatible; MSIE 4.5; Mac_PowerPC)
</code></pre>

  <p class="calibre2">此后，IE的版本一直到7都沿袭了这个模式：</p>
  <pre class="calibre18"><code class="calibre15">Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)
</code></pre>

  <p class="calibre2">而IE8的用户代理字符串中添加了呈现引擎（Trident）的版本号：</p>
  <pre class="calibre18"><code class="calibre15">Mozilla/4.0 (compatible; MSIE 版本号; 操作系统; Trident/Trident版本号)
</code></pre>

  <p class="calibre2">例如：</p>
  <pre class="calibre18"><code class="calibre15">Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)
</code></pre>

  <p class="calibre2">这个新增的Trident记号是为了让开发人员知道IE8是不是在兼容模式下运行。如果是，则MSIE的版本号会变成7，但Trident及版本号还会留在用户代码字符串中：</p>
  <pre class="calibre18"><code class="calibre15">Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0) 
</code></pre>

  <p class="calibre2">增加这个记号有助于分辨浏览器到底是IE7（没有Trident记号），还是运行在兼容模式下的IE8。</p>

  <p class="calibre2">IE9对字符串格式做了一点调整。Mozilla版本号增加到了5.0，而Trident的版本号也升到了5.0。IE9默认的用户代理字符串如下：</p>
  <pre class="calibre18"><code class="calibre15">Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)
</code></pre>

  <p class="calibre2">如果IE9运行在兼容模式下，字符串中的Mozilla版本号和MSIE版本号会恢复旧的值，但Trident的版本号仍然是5.0。例如，下面就是IE9运行在IE7兼容模式下的用户代理字符串：</p>
  <pre class="calibre18">Mozilla/<b class="calibre3">4.0</b> (compatible; MSIE <b class="calibre3">7.0</b>; Windows NT 6.1; Trident/5.0)
</pre>

  <p class="calibre2">所有这些变化都是为了确保过去的用户代理检测脚本能够继续发挥作用，同时还能给新脚本提供更丰富的信息。</p>

  <p class="calibre2">4. <strong class="calibre3">Gecko</strong></p>

  <p class="calibre2">Gecko是Firefox的呈现引擎。当初的Gecko是作为通用Mozilla浏览器的一部分开发的，而第一个采用Gecko引擎的浏览器是Netscape 6。为Netscape 6编写的一份规范中规定了未来版本中用户代理字符串的构成。这个新格式与4.x版本中相对简单的字符串相比，有着非常大的区别，如下所示：</p>
  <pre class="calibre18"><code class="calibre15">Mozilla/Mozilla版本号 (平台; 加密类型; 操作系统或CPU; 语言; 预先发行版本) 
     Gecko/Gecko版本号 应用程序或产品/应用程序或产品版本号
</code></pre>

  <p class="calibre2">这个明显复杂了很多的用户代理字符串中蕴含很多新想法。下表列出了字符串中各项的用意。</p>

  <table class="table">
    <tbody class="calibre23">
      <tr class="calibre24">
        <th class="calibre25" width="25%">字符串项</th>

        <th class="calibre25" width="12%">必需吗</th>

        <th class="calibre25" width="63%">说　　明</th>
      </tr>

      <tr class="calibre26">
        <td class="calibre27">Mozilla版本号</td>

        <td class="calibre28">是</td>

        <td class="calibre27">Mozilla的版本号</td>
      </tr>

      <tr class="calibre24">
        <td class="calibre27">平台</td>

        <td class="calibre28">是</td>

        <td class="calibre27">浏览器运行的平台。可能的值包括Windows、Mac和X11（指Unix的X窗口系统）</td>
      </tr>

      <tr class="calibre26">
        <td class="calibre27">加密类型</td>

        <td class="calibre28">是</td>

        <td class="calibre27">加密技术的类型：U表示128位、I表示40位、N表示未加密</td>
      </tr>

      <tr class="calibre24">
        <td class="calibre27">操作系统或CPU</td>

        <td class="calibre28">是</td>

        <td class="calibre27">浏览器运行的操作系统或计算机系统使用的CPU。在Windows平台中，这一项指Windows的版本（如WinNT、Win95，等等）。如果平台是Macintosh，这一项指CPU（针对PowerPC的68K、PPC，或MacIntel）。如果平台是X11，这一项是Unix操作系统的名称，与使用Unix命令<code class="calibre31">uname–sm</code>得到的名称相同</td>
      </tr>

      <tr class="calibre26">
        <td class="calibre27">语言</td>

        <td class="calibre28">是</td>

        <td class="calibre27">浏览器设计时所针对的目标用户语言</td>
      </tr>

      <tr class="calibre24">
        <td class="calibre27">预先发行版本</td>

        <td class="calibre28">否</td>

        <td class="calibre27">最初用于表示Mozilla的预先发行版本，现在则用来表示Gecko呈现引擎的版本号</td>
      </tr>

      <tr class="calibre26">
        <td class="calibre27">Gecko版本号</td>

        <td class="calibre28">是</td>

        <td class="calibre27">Gecko呈现引擎的版本号，但由yyyymmdd格式的日期表示</td>
      </tr>

      <tr class="calibre24">
        <td class="calibre27">应用程序或产品</td>

        <td class="calibre28">否</td>

        <td class="calibre27">使用Gecko的产品名。可能是Netscape、Firefox等</td>
      </tr>

      <tr class="calibre26">
        <td class="calibre27">应用程序或产品版本号</td>

        <td class="calibre28">否</td>

        <td class="calibre27">应用程序或产品的版本号；用于区分Mozilla版本号和Gecko版本号</td>
      </tr>
    </tbody>
  </table>

  <p class="calibre2">为了帮助读者更好地理解Gecko的用户代理字符串，下面我们来看几个从基于Gecko的浏览器中取得的字符串。</p>

  <p class="calibre2">Windows XP下的Netscape 6.21：</p>
  <pre class="calibre18"><code class="calibre15">Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:0.9.4) Gecko/20011128 Netscape6/6.2.1
</code></pre>

  <p class="calibre2">Linux下的SeaMonkey 1.1a：</p>
  <pre class="calibre18"><code class="calibre15">Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1b2) Gecko/20060823 SeaMonkey/1.1a
</code></pre>

  <p class="calibre2">Windows XP下的Firefox 2.0.0.11：</p>
  <pre class="calibre18"><code class="calibre15">Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.11) Gecko/20071127 Firefox/2.0.0.11
</code></pre>

  <p class="calibre2">Mac OS X下的Camino 1.5.1：</p>
  <pre class="calibre18"><code class="calibre15">Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en; rv:1.8.1.6) Gecko/20070809 Camino/1.5.1
</code></pre>

  <p class="calibre2">以上这些用户代理字符串都取自基于Gecko的浏览器（只是版本有所不同）。很多时候，检测特定的浏览器还不如搞清楚它是否基于Gecko更重要。每个字符串中的Mozilla版本都是5.0，自从第一个基于Gecko的浏览器发布时修改成这个样子，至今就没有改变过；而且，看起来以后似乎也不会有什么变化。</p>

  <p class="calibre2">随着Firefox 4发布，Mozilla简化了这个用户代理字符串。主要改变包括以下几方面。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2">删除了“语言”记号（例如，前面例子中的“en-US”）。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2">在浏览器使用强加密（默认设置）时，不显示“加密类型”。也就是说，Mozilla用户代理字符串中不会再出现“U”，而“I”和“N”还会照常出现。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2">“平台”记号从Windows用户代理字符串中删除了，“操作系统或CPU”中始终都包含“Windows”字符串。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2">“Gecko版本号”固定为“Gecko/20100101”。</p>
    </li>
  </ul>

  <p class="calibre2">最后，Firefox 4用户代理字符串变成了下面这个样子：</p>
  <pre class="calibre18"><code class="calibre15">Mozilla/5.0 (Windows NT 6.1; rv:2.0.1) Gecko/20100101 Firefox 4.0.1
</code></pre>

  <p class="calibre2">5. <strong class="calibre3">WebKit</strong></p>

  <p class="calibre2">2003年，Apple公司宣布要发布自己的Web浏览器，名字定为Safari。Safari的呈现引擎叫WebKit，是Linux平台中Konqueror浏览器的呈现引擎KHTML的一个分支。几年后，WebKit独立出来成为了一个开源项目，专注于呈现引擎的开发。</p>

  <p class="calibre2">这款新浏览器和呈现引擎的开发人员也遇到了与Internet Explorer 3.0类似的问题：如何确保这款浏览器不被流行的站点拒之门外？答案就是向用户代理字符串中放入足够多的信息，以便站点能够信任它与其他流行的浏览器是兼容的。于是，WebKit的用户代理字符串就具备了如下格式：</p>
  <pre class="calibre18">Mozilla/5.0 (平台; 加密类型; 操作系统或CPU; 语言) AppleWebKit/AppleWebKit版本号 
     (KHTML, like Gecko) <i class="calibre7">Safari/Safari</i>版本号
</pre>

  <p class="calibre2">以下就是一个示例：</p>
  <pre class="calibre18"><code class="calibre15">Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en) AppleWebKit/124 (KHTML, like Gecko) 
     Safari/125.1
</code></pre>

  <p class="calibre2">显然，这又是一个很长的用户代理字符串。其中不仅包含了Apple WebKit的版本号，也包含了Safari的版本号。出于兼容性的考虑，有关人员很快就决定了将Safari标识为Mozilla。至今，基于WebKit的所有浏览器都将自己标识为Mozilla 5.0，与基于Gecko的浏览器完全一样。但Safari的版本号则通常是浏览器的编译版本号，不一定与发布时的版本号对应。换句话说，虽然Safari 1.25的用户代理字符串中包含数字125.1，但两者却不一一对应。</p>

  <p class="calibre2">Safari预发行1.0版用户代理字符串中最耐人寻味，也是最饱受诟病的部分就是字符串<code class="calibre15">"(KHTML,like Gecko)"</code>。Apple因此收到许多开发人员的反馈，他们认为这个字符串明显是在欺骗客户端和服务器，实际上是想让它们把Safari当成Gecko（好像光添加<code class="calibre15">Mozilla/5.0</code>还嫌不够）。Apple的回应与微软在IE的用户代理字符串遭到责难时如出一辙：Safari与Mozilla兼容，因此网站不应该将Safari用户拒之门外，否则用户就会认为自己的浏览器不受支持。</p>

  <p class="calibre2">到了Safari 3.0发布时，其用户代理字符串又稍微变长了一点。下面这个新增的Version记号一直到现在都被用来标识Safari实际的版本号：</p>
  <pre class="calibre18">Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en) AppleWebKit/522.15.5 (KHTML, like 
     Gecko) <b class="calibre3">Version/3.0.3</b> Safari/522.15.5
</pre>

  <p class="calibre2">需要注意的是，这个变化只在Safari中有，在WebKit中没有。换句话说，其他基于WebKit的浏览器可能没有这个变化。一般来说，确定浏览器是否基于WebKit要比确定它是不是Safari更有价值，就像针对Gecko一样。</p>

  <p class="calibre2">6. <strong class="calibre3">Konqueror</strong></p>

  <p class="calibre2">与KDE Linux集成的Konqueror，是一款基于KHTML开源呈现引擎的浏览器。尽管Konqueror只能在Linux中使用，但它也有数量可观的用户。为确保最大限度的兼容性，Konqueror效仿IE选择了如下用户代理字符串格式：</p>
  <pre class="calibre18"><code class="calibre15">Mozilla/5.0 (compatible; Konqueror/ 版本号; 操作系统或CPU )
</code></pre>

  <p class="calibre2">不过，为了与WebKit的用户代理字符串的变化保持一致，Konqueror 3.2又有了变化，以如下格式将自己标识为KHTML：</p>
  <pre class="calibre18"><code class="calibre15">Mozilla/5.0 (compatible; Konqueror/ 版本号; 操作系统或CPU) KHTML/ KHTML版本号 (like Gecko)
</code></pre>

  <p class="calibre2">下面是一个例子：</p>
  <pre class="calibre18"><code class="calibre15">Mozilla/5.0 (compatible; Konqueror/3.5; SunOS) KHTML/3.5.0 (like Gecko)
</code></pre>

  <p class="calibre2">其中，Konqueror与KHTML的版本号比较一致，即使有差别也很小，例如Konqueror 3.5使用KHTML 3.5.1。</p>

  <p class="calibre2">7. <strong class="calibre3">Chrome</strong></p>

  <p class="calibre2">谷歌公司的Chrome浏览器以WebKit作为呈现引擎，但使用了不同的JavaScript引擎。在Chrome 0.2这个最初的 beta版中，用户代理字符串完全取自WebKit，只添加了一段表示Chrome版本号的信息，格式如下：</p>
  <pre class="calibre18"><code class="calibre15">Mozilla/5.0 ( 平台; 加密类型; 操作系统或CPU; 语言) AppleWebKit/AppleWebKit版本号 (KHTML, 
     like Gecko) Chrome/ Chrome版本号 Safari/ Safari版本
</code></pre>

  <p class="calibre2">Chrome 7的完整的用户代理字符串如下：</p>
  <pre class="calibre18"><code class="calibre15">Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.7 (KHTML, 
     like Gecko) Chrome/7.0.517.44 Safari/534.7
</code></pre>

  <p class="calibre2">其中，WebKit版本与Safari版本看起来似乎始终会保持一致，尽管没有十分的把握。</p>

  <p class="calibre2">8. <strong class="calibre3">Opera</strong></p>

  <p class="calibre2">仅就用户代理字符串而言，Opera应该是最有争议的一款浏览器了。Opera默认的用户代理字符串是所有现代浏览器中最合理的——正确地标识了自身及其版本号。在Opera 8.0之前，其用户代理字符串采用如下格式：</p>
  <pre class="calibre18"><code class="calibre15">Opera/ 版本号 (操作系统或CPU; 加密类型) [语言]
</code></pre>

  <p class="calibre2">Windows XP中的Opera 7.54会显示下面的用户代理字符串：</p>
  <pre class="calibre18"><code class="calibre15">Opera/7.54 (Windows NT 5.1; U) [en]
</code></pre>

  <p class="calibre2">Opera 8发布后，用户代理字符串的“语言”部分被移到圆括号内，以便更好地与其他浏览器匹配，如下所示：</p>
  <pre class="calibre18"><code class="calibre15">Opera/ 版本号 (操作系统或CPU; 加密类型; 语言)
</code></pre>

  <p class="calibre2">Windows XP中的Opera 8会显示下面的用户代理字符串：</p>
  <pre class="calibre18"><code class="calibre15">Opera/8.0 (Windows NT 5.1; U; en)
</code></pre>

  <p class="calibre2">默认情况下，Opera会以上面这种简单的格式返回一个用户代理字符串。目前来看，Opera也是主要浏览器中唯一一个使用产品名和版本号来完全彻底地标识自身的浏览器。可是，与其他浏览器一样，Opera在使用自己的用户代理字符串时也遇到了问题。即使技术上正确，但因特网上仍然有不少浏览器嗅探代码，只钟情于报告Mozilla产品名的那些用户代理字符串。另外还有相当数量的代码则只对IE或Gecko感兴趣。Opera没有选择通过修改自身的用户代理字符串来迷惑嗅探代码，而是干脆选择通过修改自身的用户代理字符串将自身标识为一个完全不同的浏览器。</p>

  <p class="calibre2">Opera 9以后，出现了两种修改用户代理字符串的方式。一种方式是将自身标识为另外一个浏览器，如Firefox或者IE。在这种方式下，用户代理字符串就如同Firefox或IE的用户代理字符串一样，只不过末尾追加了字符串<code class="calibre15">Opera</code>及Opera的版本号。下面是一个例子：</p>
  <pre class="calibre18"><code class="calibre15">Mozilla/5.0 (Windows NT 5.1; U; en; rv:1.8.1) Gecko/20061208 Firefox/2.0.0 Opera 9.50

Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; en) Opera 9.50
</code></pre>

  <p class="calibre2">第一个字符串将Opera 9.5标识为Firefox 2，同时带有Opera版本信息。第二个字符串将Opera 9.5标识为IE6，也包含了Opera版本信息。这两个用户代理字符串可以通过针对Firefox或IE的大多数测试，不过还是为识别Opera留下了余地。</p>

  <p class="calibre2">Opera标识自身的另一种方式，就是把自己装扮成Firefox或IE。在这种隐瞒真实身份的情况下，用户代理字符串实际上与其他浏览器返回的相同——既没有<code class="calibre15">Opera</code>字样，也不包含Opera版本信息。换句话说，在启用了身份隐瞒功能的情况下，无法将Opera和其他浏览器区别开来。另外，由于Opera喜欢在不告知用户的情况下针对站点来设置用户代理字符串，因此问题就更复杂化了。例如，打开My Yahoo!站点（<a class="calibre6" href="http://my.yahoo.com">http://my.yahoo.com</a>）会自动导致Opera将自己装扮成Firefox。如此一来，要想识别Opera就难上加难了。</p>

  <blockquote class="calibre14">
    <p class="calibre2"><img alt="" class="calibre17" src="../Images/00002.gif" /> 在Opera 7以前的版本中，Opera会解析Windows操作系统字符串的含义。例如，Windows NT 5.1实际上就是Windows XP，因此Opera会在用户代理字符串中包含Windows XP而非Windows NT 5.1。为了与其他浏览器更兼容，Opera 7开始包含正式的操作系统版本，而非解析后的版本。</p>
  </blockquote>

  <p class="calibre2">Opera 10对代理字符串进行了修改。现在的格式是：</p>
  <pre class="calibre18"><code class="calibre15">Opera/9.80 (操作系统或CPU; 加密类型; 语言) Presto/Presto版本号 Version/版本号
</code></pre>

  <p class="calibre2">注意，初始的版本号Opera/9.80是固定不变的。实际并没有Opera 9.8，但工程师们担心写得不好的浏览器嗅探脚本会将Opera/10.0错误的解释为Opera 1，而不是Opera 10。因此，Opera 10又增加了Presto记号（Presto是Opera的呈现引擎）和Version记号，后者用以保存实际的版本号。以下是Windows7中Opera 10.63的用户代理字符串：</p>
  <pre class="calibre18"><code class="calibre15">Opera/9.80 (Windows NT 6.1; U; en) Presto/2.6.30 Version/10.63
</code></pre>

  <p class="calibre2">9. <strong class="calibre3">iOS和Android</strong></p>

  <p class="calibre2">移动操作系统iOS和Android默认的浏览器都基于WebKit，而且都像它们的桌面版一样，共享相同的基本用户代理字符串格式。iOS设备的基本格式如下：</p>
  <pre class="calibre18"><code class="calibre15">Mozilla/5.0 (平台; 加密类型; 操作系统或CPU like Mac OS X; 语言)
     AppleWebKit/AppleWebKit版本号 (KHTML, like Gecko) Version/浏览器版本号
     Mobile/移动版本号 Safari/Safari版本号
</code></pre>

  <p class="calibre2">注意用于辅助确定Mac操作系统的<code class="calibre15">"like Mac OS X"</code>和额外的Mobile记号。一般来说，Mobile记号的版本号（移动版本号）没什么用，主要是用来确定WebKit是移动版，而非桌面版。而平台则可能是<code class="calibre15">"iPhone"</code>、<code class="calibre15">"iPod"</code>或<code class="calibre15">"iPad"</code>。例如：</p>
  <pre class="calibre18"><code class="calibre15">Mozilla/5.0 (iPhone; U; CPU iPhone OS 3_0 like Mac OS X; en-us)
    AppleWebKit/528.18 (KHTML, like Gecko) Version/4.0 Mobile/7A341 Safari/528.16
</code></pre>

  <p class="calibre2">在iOS 3之前，用户代理字符串中不会出现操作系统版本号。</p>

  <p class="calibre2">Android浏览器中的默认格式与iOS的格式相似，没有移动版本号（但有Mobile记号）。例如：</p>
  <pre class="calibre18"><code class="calibre15">Mozilla/5.0 (Linux; U; Android 2.2; en-us; Nexus One Build/FRF91)
    AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1
</code></pre>

  <p class="calibre2">这是Google Nexus One手机的用户代理字符串。不过，其他Android设备的模式也一样。</p>

  <h3 class="calibre22" id="nav_point_62">9.3.2　用户代理字符串检测技术</h3>

  <p class="calibre2">考虑到历史原因以及现代浏览器中用户代理字符串的使用方式，通过用户代理字符串来检测特定的浏览器并不是一件轻松的事。因此，首先要确定的往往是你需要多么具体的浏览器信息。一般情况下，知道呈现引擎和最低限度的版本就足以决定正确的操作方法了。例如，我们不推荐使用下列代码：</p>
  <pre class="calibre18"><code class="calibre15">if (isIE6 || isIE7) { //不推荐!!!
    //代码
}
</code></pre>

  <p class="calibre2">这个例子是想要在浏览器为IE6或IE7时执行相应代码。这种代码其实是很脆弱的，因为它要依据特定的版本来决定做什么。如果是IE8怎么办呢？只要IE有新版本出来，就必须更新这些代码。不过，像下面这样使用相对版本号则可以避免此问题：</p>
  <pre class="calibre18"><code class="calibre15">if (ieVer &gt;=6){
    //代码
}
</code></pre>

  <p class="calibre2">这个例子首先检测IE的版本号是否至少等于6，如果是则执行相应操作。这样就可以确保相应的代码将来照样能够起作用。我们下面的浏览器检测脚本就将本着这种思路来编写。</p>

  <p class="calibre2">1. <strong class="calibre3">识别呈现引擎</strong></p>

  <p class="calibre2">如前所述，确切知道浏览器的名字和版本号不如确切知道它使用的是什么呈现引擎。如果Firefox、Camino和Netscape都使用相同版本的Gecko，那它们一定支持相同的特性。类似地，不管是什么浏览器，只要它跟Safari 3使用的是同一个版本的WebKit，那么该浏览器也就跟Safari 3具备同样的功能。因此，我们要编写的脚本将主要检测五大呈现引擎：IE、Gecko、WebKit、KHTML和Opera。</p>

  <p class="calibre2">为了不在全局作用域中添加多余的变量，我们将使用模块增强模式来封装检测脚本。检测脚本的基本代码结构如下所示：</p>
  <pre class="calibre18"><code class="calibre15">var client = function(){

    var engine = {            

    //呈现引擎
        ie: 0,
        gecko: 0,
        webkit: 0,
        khtml: 0,
        opera: 0,

        //具体的版本号
        ver: null  
    };

    //在此检测呈现引擎、平台和设备

    return {
        engine : engine
    };
}();
</code></pre>

  <p class="calibre2">这里声明了一个名为<code class="calibre15">client</code>的全局变量，用于保存相关信息。匿名函数内部定义了一个局部变量<code class="calibre15">engine</code>，它是一个包含默认设置的对象字面量。在这个对象字面量中，每个呈现引擎都对应着一个属性，属性的值默认为0。如果检测到了哪个呈现引擎，那么就以浮点数值形式将该引擎的版本号写入相应的属性。而呈现引擎的完整版本（是一个字符串），则被写入<code class="calibre15">ver</code>属性。作这样的区分可以支持像下面这样编写代码：</p>
  <pre class="calibre18"><code class="calibre15">if (client.engine.ie) { //如果是IE，client.ie的值应该大于0
    //针对IE的代码
} else if (client.engine.gecko &gt; 1.5){
    if (client.engine.ver == "1.8.1"){
        //针对这个版本执行某些操作
    }
}
</code></pre>

  <p class="calibre2">在检测到一个呈现引擎之后，其<code class="calibre15">client.engine</code>中对应的属性将被设置为一个大于0的值，该值可以转换成布尔值<code class="calibre15">true</code>。这样，就可以在<code class="calibre15">if</code>语句中检测相应的属性，以确定当前使用的呈现引擎，连具体的版本号都不必考虑。鉴于每个属性都包含一个浮点数值，因此有可能丢失某些版本信息。例如，将字符串<code class="calibre15">"1.8.1"</code>传入<code class="calibre15">parseFloat()</code>后会得到数值1.8。不过，在必要的时候可以检测<code class="calibre15">ver</code>属性，该属性中会保存完整的版本信息。</p>

  <p class="calibre2">要正确地识别呈现引擎，关键是检测顺序要正确。由于用户代理字符串存在诸多不一致的地方，如果检测顺序不对，很可能会导致检测结果不正确。为此，第一步就是识别Opera，因为它的用户代理字符串有可能完全模仿其他浏览器。我们不相信Opera，是因为（任何情况下）其用户代理字符串（都）不会将自己标识为Opera。</p>

  <p class="calibre2">要识别Opera，必须得检测<code class="calibre15">window.opera</code>对象。Opera 5及更高版本中都有这个对象，用以保存与浏览器相关的标识信息以及与浏览器直接交互。在Opera 7.6及更高版本中，调用<code class="calibre15">version()</code>方法可以返回一个表示浏览器版本的字符串，而这也是确定Opera版本号的最佳方式。要检测更早版本的Opera，可以直接检查用户代理字符串，因为那些版本还不支持隐瞒身份。不过，2007底Opera的最高版本已经是9.5了，所以不太可能有人还在使用7.6之前的版本。那么，检测呈现引擎代码的第一步，就是编写如下代码：</p>
  <pre class="calibre18"><code class="calibre15">if (window.opera){
    engine.ver = window.opera.version();
    engine.opera = parseFloat(engine.ver);
}
</code></pre>

  <p class="calibre2">这里，将版本的字符串表示保存在了<code class="calibre15">engine.ver</code>中，将浮点数值表示的版本保存在了<code class="calibre15">engine.opera</code>中。如果浏览器是Opera，测试<code class="calibre15">window.opera</code>就会返回<code class="calibre15">true</code>；否则，就要看看是其他的什么浏览器了。</p>

  <p class="calibre2">应该放在第二位检测的呈现引擎是WebKit。因为WebKit的用户代理字符串中包含<code class="calibre15">"Gecko"</code>和<code class="calibre15">"KHTML"</code>这两个子字符串，所以如果首先检测它们，很可能会得出错误的结论。</p>

  <p class="calibre2">不过，WebKit的用户代理字符串中的<code class="calibre15">"AppleWebKit"</code>是独一无二的，因此检测这个字符串最合适。下面就是检测该字符串的示例代码：</p>
  <pre class="calibre18"><b class="calibre3">var ua = navigator.userAgent;</b>

if (window.opera){
    engine.ver = window.opera.version();
    engine.opera = parseFloat(engine.ver); 
<b class="calibre3">} else if (/AppleWebKit\/(\S+)/.test(ua)){</b>
    <b class="calibre3">engine.ver = RegExp["$1"];</b>
    <b class="calibre3">engine.webkit = parseFloat(engine.ver);</b>
<b class="calibre3">}</b>
</pre>

  <p class="calibre2">代码首先将用户代理字符串保存在变量<code class="calibre15">ua</code>中。然后通过正则表达式来测试其中是否包含字符串<code class="calibre15">"AppleWebKit"</code>，并使用捕获组来取得版本号。由于实际的版本号中可能会包含数字、小数点和字母，所以捕获组中使用了表示非空格的特殊字符（<code class="calibre15">\S</code>）。用户代理字符串中的版本号与下一部分的分隔符是一个空格，因此这个模式可以保证捕获所有版本信息。<code class="calibre15">test()</code>方法基于用户代理字符串运行正则表达式。如果返回<code class="calibre15">true</code>，就将捕获的版本号保存在<code class="calibre15">engine.ver</code>中，而将版本号的浮点表示保存在<code class="calibre15">engine.webkit</code>中。WebKit版本与Safari版本的详细对应情况如下表所示。</p>

  <table class="table">
    <tbody class="calibre23">
      <tr class="calibre24">
        <th class="calibre25" width="25%">Safari版本号</th>

        <th class="calibre25" width="25%">最低限度的WebKit版本号</th>

        <th class="calibre25" width="25%">Safari版本号</th>

        <th class="calibre25" width="25%">最低限度的WebKit版本号</th>
      </tr>

      <tr class="calibre26">
        <td class="calibre28">1.0至1.0.2</td>

        <td class="calibre28">85.7</td>

        <td class="calibre28">1.3</td>

        <td class="calibre28">312.1</td>
      </tr>

      <tr class="calibre24">
        <td class="calibre28">1.0.3</td>

        <td class="calibre28">85.8.2</td>

        <td class="calibre28">1.3.1</td>

        <td class="calibre28">312.5</td>
      </tr>

      <tr class="calibre26">
        <td class="calibre28">1.1至1.1.1</td>

        <td class="calibre28">100</td>

        <td class="calibre28">1.3.2</td>

        <td class="calibre28">312.8</td>
      </tr>

      <tr class="calibre24">
        <td class="calibre28">1.2.2</td>

        <td class="calibre28">125.2</td>

        <td class="calibre28">2.0</td>

        <td class="calibre28">412</td>
      </tr>

      <tr class="calibre26">
        <td class="calibre28">1.2.3</td>

        <td class="calibre28">125.4</td>

        <td class="calibre28">2.0.1</td>

        <td class="calibre28">412.7</td>
      </tr>

      <tr class="calibre24">
        <td class="calibre28">1.2.4</td>

        <td class="calibre28">125.5.5</td>

        <td class="calibre28">2.0.2</td>

        <td class="calibre28">416.11</td>
      </tr>

      <tr class="calibre26">
        <td class="calibre28">2.0.3</td>

        <td class="calibre28">417.9</td>

        <td class="calibre28">3.0.4</td>

        <td class="calibre28">523.10</td>
      </tr>

      <tr class="calibre24">
        <td class="calibre28">2.0.4</td>

        <td class="calibre28">418.8</td>

        <td class="calibre28">3.1</td>

        <td class="calibre28">525</td>
      </tr>
    </tbody>
  </table>

  <blockquote class="calibre14">
    <p class="calibre2"><img alt="" class="calibre17" src="../Images/00002.gif" /> 有时候，Safari版本并不会与WebKit版本严格地一一对应，也可能会存在某些小版本上的差异。这个表中只是列出了最可能的WebKit版本，但不保证精确。</p>
  </blockquote>

  <p class="calibre2">接下来要测试的呈现引擎是KHTML。同样，KHTML的用户代理字符串中也包含<code class="calibre15">"Gecko"</code>，因此在排除KHTML之前，我们无法准确检测基于Gecko的浏览器。KHTML的版本号与WebKit的版本号在用户代理字符串中的格式差不多，因此可以使用类似的正则表达式。此外，由于Konqueror 3.1及更早版本中不包含KHTML的版本，故而就要使用Konqueror的版本来代替。下面就是相应的检测代码。</p>
  <pre class="calibre18">var ua = navigator.userAgent;

if (window.opera){
    engine.ver = window.opera.version();
    engine.opera = parseFloat(engine.ver); 
} else if (/AppleWebKit\/(\S+)/.test(ua)){
    engine.ver = RegExp["$1"];
    engine.webkit = parseFloat(engine.ver);
<b class="calibre3">} else if (/KHTML\/(\S+)/.test(ua) || /Konqueror\/([^;]+)/.test(ua)){</b>
    <b class="calibre3">engine.ver = RegExp["$1"];</b>
    <b class="calibre3">engine.khtml = parseFloat(engine.ver);</b>
<b class="calibre3">}</b>
</pre>

  <p class="calibre2">与前面一样，由于KHTML的版本号与后继的标记之间有一个空格，因此仍然要使用特殊的非空格字符来取得与版本有关的所有字符。然后，将字符串形式的版本信息保存在<code class="calibre15">engine.ver</code>中，将浮点数值形式的版本保存在<code class="calibre15">engin.khtml</code>中。如果KHTML不在用户代理字符串中，那么就要匹配Konqueror后跟一个斜杠，再后跟不包含分号的所有字符。</p>

  <p class="calibre2">在排除了WebKit和KHTML之后，就可以准确地检测Gecko了。但是，在用户代理字符串中，Gecko的版本号不会出现在字符串<code class="calibre15">"Gecko"</code>的后面，而是会出现在字符串<code class="calibre15">"rv:"</code>的后面。这样，我们就必须使用一个比前面复杂一些的正则表达式，如下所示。</p>
  <pre class="calibre18">var ua = navigator.userAgent;

if (window.opera){
    engine.ver = window.opera.version();
    engine.opera = parseFloat(engine.ver); 
} else if (/AppleWebKit\/(\S+)/.test(ua)){
    engine.ver = RegExp["$1"];
    engine.webkit = parseFloat(engine.ver);
} else if (/KHTML\/(\S+)/.test(ua)) {
    engine.ver = RegExp["$1"];
    engine.khtml = parseFloat(engine.ver); 
<b class="calibre3">} else if (/rv:([^\)]+)\) Gecko\/\d{8}/.test(ua)){</b>
    <b class="calibre3">engine.ver = RegExp["$1"];</b>
    <b class="calibre3">engine.gecko = parseFloat(engine.ver);</b>
<b class="calibre3">}</b>
</pre>

  <p class="calibre2">Gecko的版本号位于字符串<code class="calibre15">"rv:"</code>与一个闭括号之间，因此为了提取出这个版本号，正则表达式要查找所有不是闭括号的字符，还要查找字符串<code class="calibre15">"Gecko/"</code>后跟8个数字。如果上述模式匹配，就提取出版本号并将其保存在相应的属性中。Gecko版本号与Firefox版本号的对应关系如下表所示。</p>

  <table class="table">
    <tbody class="calibre23">
      <tr class="calibre24">
        <th class="calibre25" width="25%">Firefox版本号</th>

        <th class="calibre25" width="25%">最低限度的Gecko版本号</th>

        <th class="calibre25" width="25%">Firefox版本号</th>

        <th class="calibre25" width="25%">最低限度的Gecko版本号</th>
      </tr>

      <tr class="calibre26">
        <td class="calibre28">1.0</td>

        <td class="calibre28">1.7.5</td>

        <td class="calibre28">3.5</td>

        <td class="calibre28">1.9.1</td>
      </tr>

      <tr class="calibre24">
        <td class="calibre28">1.5</td>

        <td class="calibre28">1.8.0</td>

        <td class="calibre28">3.6</td>

        <td class="calibre28">1.9.2</td>
      </tr>

      <tr class="calibre26">
        <td class="calibre28">2.0</td>

        <td class="calibre28">1.8.1</td>

        <td class="calibre28">4.0</td>

        <td class="calibre28">2.0.0</td>
      </tr>

      <tr class="calibre24">
        <td class="calibre28">3.0</td>

        <td class="calibre28">1.9.0</td>

        <td class="calibre28"></td>

        <td class="calibre28"></td>
      </tr>
    </tbody>
  </table>

  <blockquote class="calibre14">
    <p class="calibre2"><img alt="" class="calibre17" src="../Images/00002.gif" /> 与Safari跟WebKit一样，Firefox与Gecko的版本号也不一定严格对应。</p>
  </blockquote>

  <p class="calibre2">最后一个要检测的呈现引擎就是IE了。IE的版本号位于字符串<code class="calibre15">"MSIE"</code>的后面、一个分号的前面，因此相应的正则表达式非常简单，如下所示：</p>
  <pre class="calibre18">var ua = navigator.userAgent;

if (window.opera){
    engine.ver = window.opera.version();
    engine.opera = parseFloat(engine.ver);
} else if (/AppleWebKit\/(\S+)/.test(ua)){
    engine.ver = RegExp["$1"];
    engine.webkit = parseFloat(engine.ver);
} else if (/KHTML\/(\S+)/.test(ua)) {
    engine.ver = RegExp["$1"];
    engine.khtml = parseFloat(engine.ver);
} else if (/rv:([^\)]+)\) Gecko\/\d{8}/.test(ua)){    
    engine.ver = RegExp["$1"];
    engine.gecko = parseFloat(engine.ver);
<b class="calibre3">} else if (/MSIE ([^;]+)/.test(ua)){</b>
     <b class="calibre3">engine.ver = RegExp["$1"];</b>
     <b class="calibre3">engine.ie = parseFloat(engine.ver);</b>
<b class="calibre3">}</b>
</pre>

  <p class="calibre2">以上呈现引擎检测脚本的最后一部分，就是在正则表达式中使用取反的字符类来取得不是分号的所有字符。IE通常会保证以标准浮点数值形式给出其版本号，但有时候也不一定。因此，取反的字符类<code class="calibre15">[^;]</code>可以确保取得多个小数点以及任何可能的字符。</p>

  <p class="calibre2">2. <strong class="calibre3">识别浏览器</strong></p>

  <p class="calibre2">大多数情况下，识别了浏览器的呈现引擎就足以为我们采取正确的操作提供依据了。可是，只有呈现引擎还不能说明存在所需的JavaScript功能。苹果公司的Safari浏览器和谷歌公司的Chrome浏览器都使用WebKit作为呈现引擎，但它们的JavaScript引擎却不一样。在这两款浏览器中，<code class="calibre15">client.webkit</code>都会返回非0值，但仅知道这一点恐怕还不够。对于它们，有必要像下面这样为<code class="calibre15">client</code>对象再添加一些新的属性。</p>
  <pre class="calibre18">var client = function(){

    var engine = {

        //呈现引擎
        ie: 0,
        gecko: 0,
        webkit: 0,
        khtml: 0,
        opera: 0,

        //具体的版本
        ver: null
    };

    <b class="calibre3">var browser = {</b>

        <b class="calibre3">//浏览器</b>
        <b class="calibre3">ie: 0,</b>
        <b class="calibre3">firefox: 0,</b>
        <b class="calibre3">safari: 0,</b>
        <b class="calibre3">konq: 0,</b>
        <b class="calibre3">opera: 0,</b>
        <b class="calibre3">chrome: 0,</b>

        <b class="calibre3">//具体的版本</b>
        <b class="calibre3">ver: null</b>
    <b class="calibre3">};</b>

    //在此检测呈现引擎、平台和设备

    return {
        engine: engine,
        <b class="calibre3">browser: browser</b>
    };

}();
</pre>

  <p class="calibre2">代码中又添加了私有变量<code class="calibre15">browser</code>，用于保存每个主要浏览器的属性。与<code class="calibre15">engine</code>变量一样，除了当前使用的浏览器，其他属性的值将保持为0；如果是当前使用的浏览器，则这个属性中保存的是浮点数值形式的版本号。同样，<code class="calibre15">ver</code>属性中在必要时将会包含字符串形式的浏览器完整版本号。由于大多数浏览器与其呈现引擎密切相关，所以下面示例中检测浏览器的代码与检测呈现引擎的代码是混合在一起的。</p>
  <pre class="calibre18">//检测呈现引擎及浏览器
var ua = navigator.userAgent;    
if (window.opera){
    <b class="calibre3">engine.ver = browser.ver = window.opera.version();</b>
    <b class="calibre3">engine.opera = browser.opera = parseFloat(engine.ver);</b>
} else if (/AppleWebKit\/(\S+)/.test(ua)){
    engine.ver = RegExp["$1"];
    engine.webkit = parseFloat(engine.ver);

    <b class="calibre3">//确定是Chrome还是Safari</b>
    <b class="calibre3">if (/Chrome\/(\S+)/.test(ua)){</b>
        <b class="calibre3">browser.ver = RegExp["$1"];</b>
        <b class="calibre3">browser.chrome = parseFloat(browser.ver);</b>
    <b class="calibre3">} else if (/Version\/(\S+)/.test(ua)){</b>
        <b class="calibre3">browser.ver = RegExp["$1"];</b>
        <b class="calibre3">browser.safari = parseFloat(browser.ver);</b>
    <b class="calibre3">} else {</b>
        <b class="calibre3">//近似地确定版本号</b>
        <b class="calibre3">var safariVersion = 1;</b>
        <b class="calibre3">if (engine.webkit </b>
            <b class="calibre3">safariVersion = 1;</b>
        <b class="calibre3">} else if (engine.webkit </b>
            <b class="calibre3">safariVersion = 1.2;</b>
        <b class="calibre3">} else if (engine.webkit </b>
            <b class="calibre3">safariVersion = 1.3;</b>
        <b class="calibre3">} else {</b>
            <b class="calibre3">safariVersion = 2;</b>
        <b class="calibre3">}</b>

        <b class="calibre3">browser.safari = browser.ver = safariVersion;</b>
    }
} else if (/KHTML\/(\S+)/.test(ua) || /Konqueror\/([^;]+)/.test(ua)){
    <b class="calibre3">engine.ver = browser.ver = RegExp["$1"];</b>
    <b class="calibre3">engine.khtml = browser.konq = parseFloat(engine.ver);</b>
} else if (/rv:([^\)]+)\) Gecko\/\d{8}/.test(ua)){
    engine.ver = RegExp["$1"];
    engine.gecko = parseFloat(engine.ver);

    <b class="calibre3">//确定是不是Firefox</b>
    <b class="calibre3">if (/Firefox\/(\S+)/.test(ua)){</b>
        <b class="calibre3">browser.ver = RegExp["$1"];</b>
        <b class="calibre3">browser.firefox = parseFloat(browser.ver);</b>
    <b class="calibre3">}</b>
} else if (/MSIE ([^;]+)/.test(ua)){
    <b class="calibre3">engine.ver = browser.ver = RegExp["$1"];</b>
    <b class="calibre3">engine.ie = browser.ie = parseFloat(engine.ver);</b>
}
</pre>

  <p class="calibre2">对Opera和IE而言，<code class="calibre15">browser</code>对象中的值等于<code class="calibre15">engine</code>对象中的值。对Konqueror而言，<code class="calibre15">browser.konq</code>和<code class="calibre15">browser.ver</code>属性分别等于<code class="calibre15">engine.khtml</code>和<code class="calibre15">engine.ver</code>属性。</p>

  <p class="calibre2">为了检测Chrome和Safari，我们在检测引擎的代码中添加了if语句。提取Chrome的版本号时，需要查找字符串<code class="calibre15">"Chrome/"</code>并取得该字符串后面的数值。而提取Safari的版本号时，则需要查找字符串<code class="calibre15">"Version/"</code>并取得其后的数值。由于这种方式仅适用于Safari 3及更高版本，因此需要一些备用的代码，将WebKit的版本号近似地映射为Safari的版本号（参见上一小节中的表格）。</p>

  <p class="calibre2">在检测Firefox的版本时，首先要找到字符串<code class="calibre15">"Firefox/"</code>，然后提取出该字符串后面的数值（即版本号）。当然，只有呈现引擎被判别为Gecko时才会这样做。</p>

  <p class="calibre2">有了上面这些代码之后，我们就可以编写下面的逻辑。</p>
  <pre class="calibre18"><code class="calibre15">if (client.engine.webkit) { //if it’s WebKit
    if (client.browser.chrome){
        //执行针对Chrome的代码
    } else if (client.browser.safari){
        //执行针对Safari的代码
    }
} else if (client.engine.gecko){
    if (client.browser.firefox){
        //执行针对Firefox的代码
    } else {
        //执行针对其他Gecko浏览器的代码
    }
}
</code></pre>

  <p class="calibre2">3. <strong class="calibre3">识别平台</strong></p>

  <p class="calibre2">很多时候，只要知道呈现引擎就足以编写出适当的代码了。但在某些条件下，平台可能是必须关注的问题。那些具有各种平台版本的浏览器（如Safari、Firefox和Opera）在不同的平台下可能会有不同的问题。目前的三大主流平台是Windows、Mac和Unix（包括各种Linux）。为了检测这些平台，还需要像下面这样再添加一个新对象。</p>
  <pre class="calibre18">var client = function(){

    var engine = {

        //呈现引擎
        ie: 0,
        gecko: 0,
        webkit: 0,
        khtml: 0,
        opera: 0,

        //具体的版本号
        ver: null
    };

    var browser = {

        //浏览器
        ie: 0,
        firefox: 0,
        safari: 0,
        konq: 0,
        opera: 0,
        chrome: 0,

        //具体的版本号
        ver: null
    };

    <b class="calibre3">var system = {</b>
        <b class="calibre3">win: false,</b>
        <b class="calibre3">mac: false,</b>
        <b class="calibre3">x11: false</b>
    <b class="calibre3">};</b>

    //在此检测呈现引擎、平台和设备

    return {
        engine: engine,
        browser: browser,
        <b class="calibre3">system: system</b>
    };

}();
</pre>

  <p class="calibre2">显然，上面的代码中又添加了一个包含3个属性的新变量<code class="calibre15">system</code>。其中，<code class="calibre15">win</code>属性表示是否为Windows平台，<code class="calibre15">mac</code>表示Mac，而<code class="calibre15">x11</code>表示Unix。与呈现引擎不同，在不能访问操作系统或版本的情况下，平台信息通常是很有限的。对这三个平台而言，浏览器一般只报告Windows版本。为此，新变量<code class="calibre15">system</code>的每个属性最初都保存着布尔值<code class="calibre15">false</code>，而不是像呈现引擎属性那样保存着数字值。</p>

  <p class="calibre2">在确定平台时，检测<code class="calibre15">navigator.platform</code>要比检测用户代理字符串更简单，后者在不同浏览器中会给出不同的平台信息。而<code class="calibre15">navigator.platform</code>属性可能的值包括<code class="calibre15">"Win32"</code>、<code class="calibre15">"Win64"</code>、<code class="calibre15">"MacPPC"</code>、<code class="calibre15">"MacIntel"</code>、<code class="calibre15">"X11"</code>和<code class="calibre15">"Linux i686"</code>，这些值在不同的浏览器中都是一致的。检测平台的代码非常直观，如下所示：</p>
  <pre class="calibre18"><code class="calibre15">var p = navigator.platform;
system.win = p.indexOf("Win") == 0;
system.mac = p.indexOf("Mac") == 0;
system.x11 = (p.indexOf("X11") == 0)    || (p.indexOf("Linux") == 0);
</code></pre>

  <p class="calibre2">以上代码使用<code class="calibre15">indexOf()</code>方法来查找平台字符串的开始位置。虽然<code class="calibre15">"Win32"</code>是当前浏览器唯一支持的Windows字符串，但随着向64位Windows架构的迁移，将来很可能会出现<code class="calibre15">"Win64"</code>平台信息值。为了对此有所准备，检测平台的代码中查找的只是字符串<code class="calibre15">"Win"</code>的开始位置。而检测Mac平台的方式也类似，同样是考虑到了<code class="calibre15">MacPPC</code>和<code class="calibre15">MacIntel</code>。在检测Unix时，则同时检查了字符串<code class="calibre15">"X11"</code>和<code class="calibre15">"Linux"</code>在平台字符串中的开始位置，从而确保了代码能够向前兼容其他变体。</p>

  <blockquote class="calibre14">
    <p class="calibre2"><img alt="" class="calibre17" src="../Images/00002.gif" /> Gecko的早期版本在所有Windows平台中都返回字符串<code class="calibre15">"Windows"</code>，在所有Mac平台中则都返回字符串<code class="calibre15">"Macintosh"</code>。不过，这都是Firefox 1发布以前的事了，Firefox 1确定了<code class="calibre15">navigator.platform</code>的值。</p>
  </blockquote>

  <p class="calibre2">4. <strong class="calibre3">识别Windows操作系统</strong></p>

  <p class="calibre2">在Windows平台下，还可以从用户代理字符串中进一步取得具体的操作系统信息。在Windows XP之前，Windows有两种版本，分别针对家庭用户和商业用户。针对家庭用户的版本分别是Windows 95、98和Windows ME。而针对商业用户的版本则一直叫做Window NT，最后由于市场原因改名为Windows 2000。这两个产品线后来又合并成一个由Windows NT发展而来的公共的代码基，代表产品就是Windows XP。随后，微软在Windows XP基础上又构建了Windows Vista。</p>

  <p class="calibre2">只有了解这些信息，才能搞清楚用户代理字符串中Windows操作系统的具体版本。下表列出了不同浏览器在表示不同的Windows操作系统时给出的不同字符串。</p>

  <table class="table">
    <tbody class="calibre23">
      <tr class="calibre24">
        <th class="calibre25" width="16%">Windows版本</th>

        <th class="calibre25" width="17%">IE 4+</th>

        <th class="calibre25" width="17%">Gecko</th>

        <th class="calibre25" width="16%">Opera &lt; 7</th>

        <th class="calibre25" width="17%">Opera 7+</th>

        <th class="calibre25" width="17%">WebKit</th>
      </tr>

      <tr class="calibre26">
        <td class="calibre27">95</td>

        <td class="calibre27"><code class="calibre31">"Windows 95"</code></td>

        <td class="calibre27"><code class="calibre31">"Win95"</code></td>

        <td class="calibre27"><code class="calibre31">"Windows 95"</code></td>

        <td class="calibre27"><code class="calibre31">"Windows 95"</code></td>

        <td class="calibre27"><code class="calibre31">n/a</code></td>
      </tr>

      <tr class="calibre24">
        <td class="calibre27">98</td>

        <td class="calibre27"><code class="calibre31">"Windows 98"</code></td>

        <td class="calibre27"><code class="calibre31">"Win98"</code></td>

        <td class="calibre27"><code class="calibre31">"Windows 98"</code></td>

        <td class="calibre27"><code class="calibre31">"Windows 98"</code></td>

        <td class="calibre27"><code class="calibre31">n/a</code></td>
      </tr>

      <tr class="calibre26">
        <td class="calibre27">NT 4.0</td>

        <td class="calibre27"><code class="calibre31">"Windows NT"</code></td>

        <td class="calibre27"><code class="calibre31">"WinNT4.0"</code></td>

        <td class="calibre27"><code class="calibre31">"Windows NT 4.0"</code></td>

        <td class="calibre27"><code class="calibre31">"Windows NT 4.0"</code></td>

        <td class="calibre27"><code class="calibre31">n/a</code></td>
      </tr>

      <tr class="calibre24">
        <td class="calibre27">2000</td>

        <td class="calibre27"><code class="calibre31">"Windows NT 5.0"</code></td>

        <td class="calibre27"><code class="calibre31">"Windows NT 5.0"</code></td>

        <td class="calibre27"><code class="calibre31">"Windows 2000"</code></td>

        <td class="calibre27"><code class="calibre31">"Windows NT 5.0"</code></td>

        <td class="calibre27"><code class="calibre31">n/a</code></td>
      </tr>

      <tr class="calibre26">
        <td class="calibre27">ME</td>

        <td class="calibre27"><code class="calibre31">"Win 9x 4.90"</code></td>

        <td class="calibre27"><code class="calibre31">"Win 9x 4.90"</code></td>

        <td class="calibre27"><code class="calibre31">"Windows ME"</code></td>

        <td class="calibre27"><code class="calibre31">"Win 9x 4.90"</code></td>

        <td class="calibre27"><code class="calibre31">n/a</code></td>
      </tr>

      <tr class="calibre24">
        <td class="calibre27">XP</td>

        <td class="calibre27"><code class="calibre31">"Windows NT 5.1"</code></td>

        <td class="calibre27"><code class="calibre31">"Windows NT 5.1"</code></td>

        <td class="calibre27"><code class="calibre31">"Windows XP"</code></td>

        <td class="calibre27"><code class="calibre31">"Windows NT 5.1"</code></td>

        <td class="calibre27"><code class="calibre31">"Windows NT 5.1"</code></td>
      </tr>

      <tr class="calibre26">
        <td class="calibre27">Vista</td>

        <td class="calibre27"><code class="calibre31">"Windows NT 6.0"</code></td>

        <td class="calibre27"><code class="calibre31">"Windows NT 6.0"</code></td>

        <td class="calibre27"><code class="calibre31">n/a</code></td>

        <td class="calibre27"><code class="calibre31">"Windows NT 6.0"</code></td>

        <td class="calibre27"><code class="calibre31">"Windows NT 6.0"</code></td>
      </tr>

      <tr class="calibre24">
        <td class="calibre27">7</td>

        <td class="calibre27"><code class="calibre31">"Windows NT 6.1"</code></td>

        <td class="calibre27"><code class="calibre31">"Windows NT 6.1"</code></td>

        <td class="calibre27"><code class="calibre31">n/a</code></td>

        <td class="calibre27"><code class="calibre31">"Windows NT 6.1"</code></td>

        <td class="calibre27"><code class="calibre31">"Windows NT 6.1"</code></td>
      </tr>
    </tbody>
  </table>

  <p class="calibre2">由于用户代理字符串中的Windows操作系统版本表示方法各异，因此检测代码并不十分直观。好在，从Windows 2000开始，表示操作系统的字符串大部分都还相同，只有版本号有变化。为了检测不同的Windows操作系统，必须要使用正则表达式。由于使用Opera 7之前版本的用户已经不多了，因此我们可以忽略这部分浏览器。</p>

  <p class="calibre2">第一步就是匹配Windows 95和Windows 98这两个字符串。对这两个字符串，只有Gecko与其他浏览器不同，即没有<code class="calibre15">"dows"</code>，而且<code class="calibre15">"Win"</code>与版本号之间没有空格。要匹配这个模式，可以使用下面这个简单的正则表达式。</p>
  <pre class="calibre18"><code class="calibre15">/Win(?:dows )?([^do]{2})/
</code></pre>

  <p class="calibre2">这个正则表达式中的捕获组会返回操作系统的版本。由于版本可能是任何两个字符编码（例如95、98、9x、NT、ME及XP），因此要使用两个非空格字符。</p>

  <p class="calibre2">Gecko在表示Windows NT时会在末尾添加<code class="calibre15">"4.0"</code>，与其查找实际的字符串，不如像下面这样查找小数值更合适。</p>
  <pre class="calibre18">/Win(?:dows )?([^do]{2})<b class="calibre3">(\d+\.\d+)?</b>/
</pre>

  <p class="calibre2">这样，正则表达式中就包含了第二个捕获组，用于取得NT的版本号。由于该版本号对于Windows 95和Windows 98而言是不存在的，所以必须设置为可选。这个模式与Opera表示Windows NT的字符串之间唯一的区别，就是<code class="calibre15">"NT"</code>与<code class="calibre15">"4.0"</code>之间的空格，这在模式中很容易添加。</p>
  <pre class="calibre18">/Win(?:dows )?([^do]{2})\<b class="calibre3">s?</b>(\d+\.\d+)?/
</pre>

  <p class="calibre2">经过一番修改之后，这个正则表达式也可以成功地匹配Windows ME、Windows XP和Windows Vista的字符串了。具体来说，第一个捕获组将会匹配95、98、9x、NT、ME或XP。第二个捕获组则只针对Windows ME及所有Windows NT的变体。这个信息可以作为具体的操作系统信息保存在<code class="calibre15">system.win</code>属性中，如下所示。</p>
  <pre class="calibre18"><code class="calibre15">if (system.win){
    if (/Win(?:dows )?([^do]{2})\s?(\d+\.\d+)?/.test(ua)){
        if (RegExp["$1"] == "NT"){
            switch(RegExp["$2"]){
                case "5.0":
                    system.win = "2000";
                    break;
                case "5.1":
                    system.win = "XP";
                    break;
                case "6.0":
                    system.win = "Vista";
                    break;
                case "6.1":
                    system.win = "7";
                    break;
                default:
                    system.win = "NT";
                    break;                
            }                            
        } else if (RegExp["$1"] == "9x"){
            system.win = "ME";
        } else {
            system.win = RegExp["$1"];
        }
    }
}
</code></pre>

  <p class="calibre2">如果<code class="calibre15">system.win</code>的值为<code class="calibre15">true</code>，那么就使用这个正则表达式从用户代理字符串中提取具体的信息。鉴于Windows将来的某个版本也许不能使用这个方法来检测，所以第一步应该先检测用户代理字符串是否与这个模式匹配。在模式匹配的情况下，第一个捕获组中可能会包含<code class="calibre15">"95"</code>、<code class="calibre15">"98"</code>、<code class="calibre15">"9x"</code>或<code class="calibre15">"NT"</code>。如果这个值是<code class="calibre15">"NT"</code>，可以将<code class="calibre15">system.win</code>设置为相应操作系统的字符串；如果是"9x"，那么system.win就要设置成<code class="calibre15">"ME"</code>；如果是其他值，则将所捕获的值直接赋给<code class="calibre15">system.win</code>。有了这些检测平台的代码后，我们就可以编写如下代码。</p>
  <pre class="calibre18"><code class="calibre15">if (client.system.win){
    if (client.system.win == "XP") {
        //说明是XP
    } else if (client.system.win == "Vista"){
        //说明是Vista
    }
}
</code></pre>

  <p class="calibre2">由于非空字符串会转换为布尔值<code class="calibre15">true</code>，因此可以将<code class="calibre15">client.system.win</code>作为布尔值用在<code class="calibre15">if</code>语句中。而在需要更多有关操作系统的信息时，则可以使用其中保存的字符串值。</p>

  <p class="calibre2">5. <strong class="calibre3">识别移动设备</strong></p>

  <p class="calibre2">2006年到2007年，移动设备中Web浏览器的应用呈爆炸性增长。四大主要浏览器都推出了手机版和在其他设备中运行的版本。要检测相应的设备，第一步是为要检测的所有移动设备添加属性，如下所示。</p>
  <pre class="calibre18">var client = function(){

    var engine = {

        //呈现引擎
        ie: 0,
        gecko: 0,
        webkit: 0,
        khtml: 0,
        opera: 0,

        //具体的版本号
        ver: null
    };

    var browser = {

        //浏览器
        ie: 0,
        firefox: 0,
        safari: 0,
        konq: 0,
        opera: 0,
        chrome: 0,

        //具体的版本号
        ver: null
    };

    var system = {
        win: false,
        mac: false,
        x11: false,

        <b class="calibre3">//移动设备</b>
        <b class="calibre3">iphone: false,</b>
        <b class="calibre3">ipod: false,</b>
        <b class="calibre3">ipad: false,</b>
        <b class="calibre3">ios: false,</b>
        <b class="calibre3">android: false,</b>
        <b class="calibre3">nokiaN: false,</b>
        <b class="calibre3">winMobile: false</b>    };

    //在此检测呈现引擎、平台和设备

    return {
        engine: engine,
        browser: browser,
        system: system
    };

}();
</pre>

  <p class="calibre2">然后，通常简单地检测字符串<code class="calibre15">"iPhone"</code>、<code class="calibre15">"iPod"</code>和<code class="calibre15">"iPad"</code>，就可以分别设置相应属性的值了。</p>
  <pre class="calibre18"><code class="calibre15">system.iphone = ua.indexOf("iPhone") &gt; -1;
system.ipod = ua.indexOf("iPod") &gt; -1;
system.ipod = ua.indexOf("iPad") &gt; -1;
</code></pre>

  <p class="calibre2">除了知道iOS设备，最好还能知道iOS的版本号。在iOS 3之前，用户代理字符串中只包含<code class="calibre15">"CPU like Mac OS"</code>，后来iPhone中又改成<code class="calibre15">"CPU iPhone OS 3_0 like Mac OS X"</code>，iPad中又改成<code class="calibre15">"CPU OS 3_2 like Mac OS X"</code>。也就是说，检测iOS需要正则表达式反映这些变化。</p>
  <pre class="calibre18"><code class="calibre15">//检测iOS版本
if (system.mac &amp;&amp; ua.indexOf("Mobile") &gt; -1){
    if (/CPU (?:iPhone )?OS (\d+_\d+)/.test(ua)){
        system.ios = parseFloat(RegExp.$1.replace("_", "."));
    } else {
        system.ios = 2; //不能真正检测出来，所以只能猜测
    } 
}
</code></pre>

  <p class="calibre2">检查系统是不是Mac OS、字符串中是否存在<code class="calibre15">"Mobile"</code>，可以保证无论是什么版本，<code class="calibre15">system.ios</code>中都不会是0。然后，再使用正则表达式确定是否存在iOS的版本号。如果有，将<code class="calibre15">system.ios</code>设置为表示版本号的浮点值；否则，将版本设置为2。（因为没有办法确定到底是什么版本，所以设置为更早的版本比较稳妥。）</p>

  <p class="calibre2">检测Android操作系统也很简单，也就是搜索字符串<code class="calibre15">"Android"</code>并取得紧随其后的版本号。</p>
  <pre class="calibre18"><code class="calibre15">//检测Android版本
if (/Android (\d+\.\d+)/.test(ua)){ 
    system.android = parseFloat(RegExp.$1);
}
</code></pre>

  <p class="calibre2">由于所有版本的Android都有版本值，因此这个正则表达式可以精确地检测所有版本，并将<code class="calibre15">system.android</code>设置为正确的值。</p>

  <p class="calibre2">诺基亚N系列手机使用的也是WebKit，其用户代理字符串与其他基于WebKit的手机很相似，例如：</p>
  <pre class="calibre18"><code class="calibre15">Mozilla/5.0 (SymbianOS/9.2; U; Series60/3.1 NokiaN95/11.0.026; Profile MIDP-2.0
     Configuration/CLDC-1.1) AppleWebKit/413 (KHTML, like Gecko) Safari/413
</code></pre>

  <p class="calibre2">虽然诺基亚N系列手机在用户代理字符串中声称使用的是<code class="calibre15">"Safari"</code>，但实际上并不是Safari，尽管确实是基于WebKit引擎。只要像下面检测一下用户代理字符串中是否存在<code class="calibre15">"NokiaN"</code>，就足以确定是不是该系列的手机了。</p>
  <pre class="calibre18"><code class="calibre15">system.nokiaN = ua.indexOf("NokiaN") &gt; -1;
</code></pre>

  <p class="calibre2">在了解这些设备信息的基础上，就可以通过下列代码来确定用户使用的是什么设备中的WebKit来访问网页：</p>
  <pre class="calibre18"><code class="calibre15">if (client.engine.webkit){
    if (client.system. iOS){
        //iOS手机的内容
    } else if (client.system.android){
        //Android手机的内容
    } else if (client.system.nokiaN){
        //诺基亚手机的内容
    }
}
</code></pre>

  <p class="calibre2">最后一种主要的移动设备平台是Windows Mobile（也称为Windows CE），用于Pocket PC和Smartphone中。由于从技术上说这些平台都属于Windows平台，因此Windows平台和操作系统都会返回正确的值。对于Windows Mobile 5.0及以前版本，这两种设备的用户代理字符串非常相似，如下所示：</p>
  <pre class="calibre18"><code class="calibre15">Mozilla/4.0 (compatible; MSIE 4.01; Windows CE; PPC; 240x320)
Mozilla/4.0 (compatible; MSIE 4.01; Windows CE; Smartphone; 176x220)
</code></pre>

  <p class="calibre2">第一个来自Pocket PC中的移动Internet Explorer 4.01，第二个来自Smartphone中的同一个浏览器。当Windows操作系统检测脚本检测这两个字符串时，<code class="calibre15">system.win</code>将被设置为<code class="calibre15">"CE"</code>，因此在检测Windows Mobile时可以使用这个值：</p>
  <pre class="calibre18"><code class="calibre15">system.winMobile = (system.win == "CE");
</code></pre>

  <p class="calibre2">不建议测试字符串中的<code class="calibre15">"PPC"</code>或<code class="calibre15">"Smartphone"</code>，因为在Windows Mobile 5.0以后版本的浏览器中，这些记号已经被移除了。不过，一般情况下，只知道某个设备使用的是Windows Mobile也就足够了。</p>

  <p class="calibre2">Windows Phone 7的用户代理字符串稍有改进，基本格式如下：</p>
  <pre class="calibre18"><code class="calibre15">Mozilla/4.0 (compatible; MSIE 7.0; Windows Phone OS 7.0; Trident/3.1; IEMobile/7.0)
    Asus;Galaxy6 
</code></pre>

  <p class="calibre2">其中，Windows操作符的标识符与已往完全不同，因此在这个用户代理中<code class="calibre15">client.system.win</code>等于<code class="calibre15">"Ph"</code>。从中可以取得有关系统的更多信息：</p>
  <pre class="calibre18"><code class="calibre15">//windows mobile
if (system.win == "CE"){
    system.winMobile = system.win;
} else if (system.win == "Ph"){
    if(/Windows Phone OS (\d+.\d+)/.test(ua)){;
        system.win = "Phone";
        system.winMobile = parseFloat(RegExp["$1"]);
    }
}
</code></pre>

  <p class="calibre2">如果<code class="calibre15">system.win</code>的值是<code class="calibre15">"CE"</code>，就说明是老版本的Windows Mobile，因此<code class="calibre15">system.winMobile</code>会被设置为相同的值（只能知道这个信息）。如果<code class="calibre15">system.win</code>的值是<code class="calibre15">"Ph"</code>，那么这个设备就可能是Windows Phone 7或更新版本。因此就用正则表达式来测试格式并提取版本号，将<code class="calibre15">system.win</code>的值重置为<code class="calibre15">"Phone"</code>，而将<code class="calibre15">system.winMobile</code>设置为版本号。</p>

  <p class="calibre2">6. <strong class="calibre3">识别游戏系统</strong></p>

  <p class="calibre2">除了移动设备之外，视频游戏系统中的Web浏览器也开始日益普及。任天堂Wii和Playstation 3或者内置Web浏览器，或者提供了浏览器下载。Wii中的浏览器实际上是定制版的Opera，是专门为Wii Remote设计的。Playstation的浏览器是自己开发的，没有基于前面提到的任何呈现引擎。这两个浏览器中的用户代理字符串如下所示：</p>
  <pre class="calibre18"><code class="calibre15">Opera/9.10 (Nintendo Wii;U; ; 1621; en)
Mozilla/5.0 (PLAYSTATION 3; 2.00)
</code></pre>

  <p class="calibre2">第一个字符串来自运行在Wii中的Opera，它忠实地继承了Opera最初的用户代理字符串格式（Wii上的Opera不具备隐瞒身份的能力）。第二个字符串来自Playstation3，虽然它为了兼容性而将自己标识为Mozilla 5.0，但并没有给出太多信息。而且，设备名称居然全部使用了大写字母，让人觉得很奇怪；强烈希望将来的版本能够改变这种情况。</p>

  <p class="calibre2">在检测这些设备以前，我们必须先为<code class="calibre15">client.system</code>中添加适当的属性，如下所示：</p>
  <pre class="calibre18">var client = function(){

    var engine = {

        //呈现引擎
        ie: 0,
        gecko: 0,
        webkit: 0,
        khtml: 0,
        opera: 0,

        //具体的版本号
        ver: null
    };

    var browser = {

        //浏览器
        ie: 0,
        firefox: 0,
        safari: 0,
        konq: 0,
        opera: 0,
        chrome: 0,

        //具体的版本号
        ver: null
    };

    var system = {
        win: false,
        mac: false,
        x11: false,

        //移动设备
        iphone: false,
        ipod: false,
        ipad: false,
        ios: false,
        android: false,
        nokiaN: false,
        winMobile: false,
        <b class="calibre3">//游戏系统</b>
        <b class="calibre3">wii: false,</b>
        <b class="calibre3">ps: false</b>
    };

    //在此检测呈现引擎、平台和设备

    return {
        engine: engine,
        browser: browser,
        system: system
    };

}();
</pre>

  <p class="calibre2">检测前述游戏系统的代码如下：</p>
  <pre class="calibre18"><code class="calibre15">system.wii = ua.indexOf("Wii") &gt; -1;
system.ps = /playstation/i.test(ua);
</code></pre>

  <p class="calibre2">对于Wii，只要检测字符串<code class="calibre15">"Wii"</code>就够了，而其他代码将发现这是一个Opera浏览器，并将正确的版本号保存在<code class="calibre15">client.browser.opera</code>中。对于Playstation，我们则使用正则表达式来以不区分大小写的方式测试用户代理字符串。</p>

  <h3 class="calibre22" id="nav_point_63">9.3.3　完整的代码</h3>

  <p class="calibre2">以下是完整的用户代理字符串检测脚本，包括检测呈现引擎、平台、Windows操作系统、移动设备和游戏系统。</p>

  <p class="p-img"><img alt="" class="calibre17" src="../Images/00003.gif" /></p>
  <pre class="calibre18"><code class="calibre15">var client = function(){

    //呈现引擎
    var engine = {
        ie: 0,
        gecko: 0,
        webkit: 0,
        khtml: 0,
        opera: 0,

        //完整的版本号
        ver: null  
    };

    //浏览器
    var browser = {

        //主要浏览器
        ie: 0,
        firefox: 0,
        safari: 0,
        konq: 0,
        opera: 0,
        chrome: 0,

        //具体的版本号
        ver: null
    };


    //平台、设备和操作系统
    var system = {
        win: false,
        mac: false,
        x11: false,

        //移动设备
        iphone: false,
        ipod: false,
        ipad: false,
        ios: false,
        android: false,
        nokiaN: false,
        winMobile: false,

        //游戏系统
        wii: false,
        ps: false 
    };    

    //检测呈现引擎和浏览器
    var ua = navigator.userAgent;    
    if (window.opera){
        engine.ver = browser.ver = window.opera.version();
        engine.opera = browser.opera = parseFloat(engine.ver);
    } else if (/AppleWebKit\/(\S+)/.test(ua)){
        engine.ver = RegExp["$1"];
        engine.webkit = parseFloat(engine.ver);

        //确定是Chrome还是Safari
        if (/Chrome\/(\S+)/.test(ua)){
            browser.ver = RegExp["$1"];
            browser.chrome = parseFloat(browser.ver);
        } else if (/Version\/(\S+)/.test(ua)){
            browser.ver = RegExp["$1"];
            browser.safari = parseFloat(browser.ver);
        } else {
            //近似地确定版本号
            var safariVersion = 1;
            if (engine.webkit &lt; 100){
                safariVersion = 1;
            } else if (engine.webkit &lt; 312){
                safariVersion = 1.2;
            } else if (engine.webkit &lt; 412){
                safariVersion = 1.3;
            } else {
                safariVersion = 2;
            }   

            browser.safari = browser.ver = safariVersion;        
        }
    } else if (/KHTML\/(\S+)/.test(ua) || /Konqueror\/([^;]+)/.test(ua)){
        engine.ver = browser.ver = RegExp["$1"];
        engine.khtml = browser.konq = parseFloat(engine.ver);
    } else if (/rv:([^\)]+)\) Gecko\/\d{8}/.test(ua)){    
        engine.ver = RegExp["$1"];
        engine.gecko = parseFloat(engine.ver);

        //确定是不是Firefox
        if (/Firefox\/(\S+)/.test(ua)){
            browser.ver = RegExp["$1"];
            browser.firefox = parseFloat(browser.ver);
        }
    } else if (/MSIE ([^;]+)/.test(ua)){    
        engine.ver = browser.ver = RegExp["$1"];
        engine.ie = browser.ie = parseFloat(engine.ver);
    }

    //检测浏览器
    browser.ie = engine.ie;
    browser.opera = engine.opera;


    //检测平台
    var p = navigator.platform;
    system.win = p.indexOf("Win") == 0;
    system.mac = p.indexOf("Mac") == 0;
    system.x11 = (p == "X11") || (p.indexOf("Linux") == 0);

    //检测Windows操作系统
    if (system.win){
        if (/Win(?:dows )?([^do]{2})\s?(\d+\.\d+)?/.test(ua)){
            if (RegExp["$1"] == "NT"){
                switch(RegExp["$2"]){
                    case "5.0":
                        system.win = "2000";
                        break;
                    case "5.1":
                        system.win = "XP";
                        break;
                    case "6.0":
                        system.win = "Vista";
                        break;
                    case "6.1":
                        system.win = "7";
                        break;
                    default:
                        system.win = "NT";
                        break;                
                }                            
            } else if (RegExp["$1"] == "9x"){
                system.win = "ME";
            } else {
                system.win = RegExp["$1"];
            }
        }
    }

    //移动设备
   system.iphone = ua.indexOf("iPhone") &gt; -1;
   system.ipod = ua.indexOf("iPod") &gt; -1;
   system.ipad = ua.indexOf("iPad") &gt; -1;
   system.nokiaN = ua.indexOf("NokiaN") &gt; -1;

   //windows mobile
   if (system.win == "CE"){
       system.winMobile = system.win;
   } else if (system.win == "Ph"){
       if(/Windows Phone OS (\d+.\d+)/.test(ua)){;
          system.win = "Phone";
          system.winMobile = parseFloat(RegExp["$1"]);
       }
   }

   //检测iOS版本
   if (system.mac &amp;&amp; ua.indexOf("Mobile") &gt; -1){
       if (/CPU (?:iPhone )?OS (\d+_\d+)/.test(ua)){
           system.ios = parseFloat(RegExp.$1.replace("_", "."));
       } else {
          system.ios = 2; //不能真正检测出来，所以只能猜测
       }
   }

   //检测Android版本
   if (/Android (\d+\.\d+)/.test(ua)){
        system.android = parseFloat(RegExp.$1);
   }

    //游戏系统
    system.wii = ua.indexOf("Wii") &gt; -1;
    system.ps = /playstation/i.test(ua);

    //返回这些对象
    return {
        engine:     engine,
        browser:    browser,
        system:     system        
    };

}();
</code></pre>

  <p class="calibre8"><i class="calibre7">client.js</i></p>

  <h3 class="calibre22" id="nav_point_64">9.3.4　使用方法</h3>

  <p class="calibre2">我们在前面已经强调过了，用户代理检测是客户端检测的最后一个选择。只要可能，都应该优先采用能力检测和怪癖检测。用户代理检测一般适用于下列情形。</p>

  <ul class="calibre16">
    <li class="calibre12">
      <p class="calibre2">不能直接准确地使用能力检测或怪癖检测。例如，某些浏览器实现了为将来功能预留的存根（stub）函数。在这种情况下，仅测试相应的函数是否存在还得不到足够的信息。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2">同一款浏览器在不同平台下具备不同的能力。这时候，可能就有必要确定浏览器位于哪个平台下。</p>
    </li>

    <li class="calibre12">
      <p class="calibre2">为了跟踪分析等目的需要知道确切的浏览器。</p>
    </li>
  </ul>
</body>
</html>
